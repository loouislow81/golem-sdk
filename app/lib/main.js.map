{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./app/src/main.js","webpack:///./app/node_modules/source-map-support/register.js","webpack:///./app/node_modules/source-map-support/source-map-support.js","webpack:///./app/node_modules/source-map/source-map.js","webpack:///./app/node_modules/source-map/lib/source-map-generator.js","webpack:///./app/node_modules/source-map/lib/base64-vlq.js","webpack:///./app/node_modules/source-map/lib/base64.js","webpack:///./app/node_modules/source-map/lib/util.js","webpack:///./app/node_modules/source-map/lib/array-set.js","webpack:///./app/node_modules/source-map/lib/mapping-list.js","webpack:///./app/node_modules/source-map/lib/source-map-consumer.js","webpack:///./app/node_modules/source-map/lib/binary-search.js","webpack:///./app/node_modules/source-map/lib/quick-sort.js","webpack:///./app/node_modules/source-map/lib/source-node.js","webpack:///external \"path\"","webpack:///external \"fs\"","webpack:///./app/node_modules/buffer-from/index.js","webpack:///external \"module\"","webpack:///external \"electron\"","webpack:///./app/node_modules/electron-dl/index.js","webpack:///./app/node_modules/unused-filename/index.js","webpack:///./app/node_modules/path-exists/index.js","webpack:///./app/node_modules/modify-filename/index.js","webpack:///./app/node_modules/pupa/index.js","webpack:///./app/node_modules/ext-name/index.js","webpack:///./app/node_modules/ext-list/index.js","webpack:///./app/node_modules/mime-db/index.js","webpack:///./app/node_modules/sort-keys-length/index.js","webpack:///./app/node_modules/sort-keys/index.js","webpack:///./app/node_modules/is-plain-obj/index.js","webpack:///./app/src/components/login/loginWindow.js","webpack:///./app/src/components/mainWindow/mainWindow.js","webpack:///./app/node_modules/electron-window-state/index.js","webpack:///./app/node_modules/jsonfile/index.js","webpack:///./app/node_modules/graceful-fs/graceful-fs.js","webpack:///./app/node_modules/graceful-fs/polyfills.js","webpack:///external \"constants\"","webpack:///./app/node_modules/graceful-fs/legacy-streams.js","webpack:///external \"stream\"","webpack:///./app/node_modules/graceful-fs/clone.js","webpack:///external \"util\"","webpack:///external \"assert\"","webpack:///./app/node_modules/mkdirp/index.js","webpack:///./app/node_modules/deep-equal/index.js","webpack:///./app/node_modules/deep-equal/lib/keys.js","webpack:///./app/node_modules/deep-equal/lib/is_arguments.js","webpack:///./app/src/components/mainWindow/mainWindowHelpers.js","webpack:///./app/src/helpers/helpers.js","webpack:///./app/node_modules/wurl/wurl.js","webpack:///external \"os\"","webpack:///./app/node_modules/loglevel/lib/loglevel.js","webpack:///./app/src/components/menu/menu.js","webpack:///./app/src/components/contextMenu/contextMenu.js","webpack:///./app/node_modules/electron-context-menu/index.js","webpack:///./app/node_modules/electron-is-dev/index.js","webpack:///./app/src/components/trayIcon/trayIcon.js","webpack:///./app/src/helpers/inferFlash.js","webpack:///./app/node_modules/dat/index.js","webpack:///./app/node_modules/dat-node/index.js","webpack:///./app/node_modules/hyperdrive/index.js","webpack:///./app/node_modules/hypercore/index.js","webpack:///./app/node_modules/buffer-equals/index.js","webpack:///./app/node_modules/last-one-wins/index.js","webpack:///./app/node_modules/unordered-array-remove/index.js","webpack:///./app/node_modules/hypercore/node_modules/unordered-set/index.js","webpack:///./app/node_modules/merkle-tree-stream/generator.js","webpack:///./app/node_modules/flat-tree/index.js","webpack:///./app/node_modules/bulk-write-stream/index.js","webpack:///./app/node_modules/readable-stream/readable.js","webpack:///./app/node_modules/readable-stream/lib/_stream_readable.js","webpack:///./app/node_modules/process-nextick-args/index.js","webpack:///./app/node_modules/isarray/index.js","webpack:///external \"events\"","webpack:///./app/node_modules/readable-stream/lib/internal/streams/stream.js","webpack:///./app/node_modules/safe-buffer/index.js","webpack:///external \"buffer\"","webpack:///./app/node_modules/core-util-is/lib/util.js","webpack:///./app/node_modules/inherits/inherits.js","webpack:///./app/node_modules/inherits/inherits_browser.js","webpack:///./app/node_modules/readable-stream/lib/internal/streams/BufferList.js","webpack:///./app/node_modules/readable-stream/lib/internal/streams/destroy.js","webpack:///./app/node_modules/readable-stream/lib/_stream_duplex.js","webpack:///./app/node_modules/readable-stream/lib/_stream_writable.js","webpack:///./app/node_modules/util-deprecate/node.js","webpack:///./app/node_modules/string_decoder/lib/string_decoder.js","webpack:///./app/node_modules/readable-stream/lib/_stream_transform.js","webpack:///./app/node_modules/readable-stream/lib/_stream_passthrough.js","webpack:///./app/node_modules/from2/index.js","webpack:///./app/node_modules/codecs/index.js","webpack:///./app/node_modules/thunky/index.js","webpack:///./app/node_modules/atomic-batcher/index.js","webpack:///./app/node_modules/random-access-file/index.js","webpack:///./app/node_modules/random-access-storage/index.js","webpack:///./app/node_modules/hypercore/lib/bitfield.js","webpack:///./app/node_modules/bitfield-rle/index.js","webpack:///./app/node_modules/bitfield-rle/node_modules/varint/index.js","webpack:///./app/node_modules/bitfield-rle/node_modules/varint/encode.js","webpack:///./app/node_modules/bitfield-rle/node_modules/varint/decode.js","webpack:///./app/node_modules/bitfield-rle/node_modules/varint/length.js","webpack:///./app/node_modules/buffer-alloc-unsafe/index.js","webpack:///./app/node_modules/memory-pager/index.js","webpack:///./app/node_modules/sparse-bitfield/index.js","webpack:///./app/node_modules/hypercore/lib/tree-index.js","webpack:///./app/node_modules/hypercore/lib/storage.js","webpack:///./app/node_modules/uint64be/index.js","webpack:///./app/node_modules/buffer-alloc/index.js","webpack:///./app/node_modules/buffer-fill/index.js","webpack:///./app/node_modules/array-lru/index.js","webpack:///./app/node_modules/array-lru/crc16.js","webpack:///./app/node_modules/hypercore-crypto/index.js","webpack:///./app/node_modules/sodium-universal/index.js","webpack:///./app/node_modules/sodium-native/index.js","webpack:///./app/node_modules/node-gyp-build/index.js","webpack:///./app/node_modules/sodium-javascript/index.js","webpack:///./app/node_modules/sodium-javascript/crypto_stream.js","webpack:///./app/node_modules/xsalsa20/index.js","webpack:///./app/node_modules/xsalsa20/xsalsa20.js","webpack:///./app/node_modules/sodium-javascript/randombytes.js","webpack:///./app/node_modules/nanoassert/index.js","webpack:///external \"crypto\"","webpack:///./app/node_modules/sodium-javascript/crypto_generichash.js","webpack:///./app/node_modules/blake2b/index.js","webpack:///./app/node_modules/blake2b-wasm/index.js","webpack:///./app/node_modules/blake2b-wasm/blake2b.js","webpack:///./app/node_modules/sodium-javascript/crypto_kdf.js","webpack:///./app/node_modules/sodium-javascript/crypto_shorthash.js","webpack:///./app/node_modules/siphash24/index.js","webpack:///./app/node_modules/siphash24/siphash24.js","webpack:///./app/node_modules/siphash24/fallback.js","webpack:///./app/node_modules/hypercore/node_modules/process-nextick-args/index.js","webpack:///./app/node_modules/inspect-custom-symbol/index.js","webpack:///./app/node_modules/pretty-hash/index.js","webpack:///./app/node_modules/hypercore/lib/replicate.js","webpack:///./app/node_modules/hypercore-protocol/index.js","webpack:///./app/node_modules/hypercore-protocol/node_modules/varint/index.js","webpack:///./app/node_modules/hypercore-protocol/node_modules/varint/encode.js","webpack:///./app/node_modules/hypercore-protocol/node_modules/varint/decode.js","webpack:///./app/node_modules/hypercore-protocol/node_modules/varint/length.js","webpack:///./app/node_modules/sorted-indexof/index.js","webpack:///./app/node_modules/hypercore-protocol/feed.js","webpack:///./app/node_modules/hypercore-protocol/messages.js","webpack:///./app/node_modules/protocol-buffers-encodings/index.js","webpack:///./app/node_modules/protocol-buffers-encodings/node_modules/varint/index.js","webpack:///./app/node_modules/protocol-buffers-encodings/node_modules/varint/encode.js","webpack:///./app/node_modules/protocol-buffers-encodings/node_modules/varint/decode.js","webpack:///./app/node_modules/protocol-buffers-encodings/node_modules/varint/length.js","webpack:///./app/node_modules/signed-varint/index.js","webpack:///./app/node_modules/signed-varint/node_modules/varint/index.js","webpack:///./app/node_modules/signed-varint/node_modules/varint/encode.js","webpack:///./app/node_modules/signed-varint/node_modules/varint/decode.js","webpack:///./app/node_modules/signed-varint/node_modules/varint/length.js","webpack:///./app/node_modules/fast-bitfield/index.js","webpack:///./app/node_modules/count-trailing-zeros/ctz.js","webpack:///./app/node_modules/mutexify/index.js","webpack:///./app/node_modules/append-tree/index.js","webpack:///./app/node_modules/append-tree/node_modules/varint/index.js","webpack:///./app/node_modules/append-tree/node_modules/varint/encode.js","webpack:///./app/node_modules/append-tree/node_modules/varint/decode.js","webpack:///./app/node_modules/append-tree/node_modules/varint/length.js","webpack:///./app/node_modules/append-tree/messages.js","webpack:///./app/node_modules/append-tree/node_modules/process-nextick-args/index.js","webpack:///./app/node_modules/stream-collector/index.js","webpack:///./app/node_modules/once/once.js","webpack:///./app/node_modules/wrappy/wrappy.js","webpack:///./app/node_modules/duplexify/index.js","webpack:///./app/node_modules/end-of-stream/index.js","webpack:///./app/node_modules/stream-shift/index.js","webpack:///./app/node_modules/stream-each/index.js","webpack:///./app/node_modules/unixify/index.js","webpack:///./app/node_modules/normalize-path/index.js","webpack:///./app/node_modules/remove-trailing-separator/index.js","webpack:///./app/node_modules/hyperdrive/lib/messages.js","webpack:///./app/node_modules/hyperdrive/lib/stat.js","webpack:///./app/node_modules/hyperdrive/lib/cursor.js","webpack:///./app/node_modules/dat-link-resolve/index.js","webpack:///./app/node_modules/dat-encoding/index.js","webpack:///./app/node_modules/simple-get/index.js","webpack:///./app/node_modules/simple-concat/index.js","webpack:///./app/node_modules/decompress-response/index.js","webpack:///external \"zlib\"","webpack:///./app/node_modules/mimic-response/index.js","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///external \"querystring\"","webpack:///external \"url\"","webpack:///./app/node_modules/dat-dns/index.js","webpack:///./app/node_modules/dat-dns/node_modules/debug/src/index.js","webpack:///./app/node_modules/dat-dns/node_modules/debug/src/browser.js","webpack:///./app/node_modules/dat-dns/node_modules/debug/src/debug.js","webpack:///./app/node_modules/dat-dns/node_modules/ms/index.js","webpack:///./app/node_modules/dat-dns/node_modules/debug/src/node.js","webpack:///external \"tty\"","webpack:///external \"net\"","webpack:///./app/node_modules/dat-dns/cache.js","webpack:///./app/node_modules/call-me-maybe/index.js","webpack:///./app/node_modules/concat-stream/index.js","webpack:///./app/node_modules/typedarray/index.js","webpack:///./app/node_modules/dat-link-resolve/node_modules/debug/src/index.js","webpack:///./app/node_modules/dat-link-resolve/node_modules/debug/src/browser.js","webpack:///./app/node_modules/dat-link-resolve/node_modules/debug/src/common.js","webpack:///./app/node_modules/ms/index.js","webpack:///./app/node_modules/dat-link-resolve/node_modules/debug/src/node.js","webpack:///./app/node_modules/supports-color/index.js","webpack:///./app/node_modules/has-flag/index.js","webpack:///./app/node_modules/dat-node/node_modules/debug/src/index.js","webpack:///./app/node_modules/dat-node/node_modules/debug/src/browser.js","webpack:///./app/node_modules/dat-node/node_modules/debug/src/common.js","webpack:///./app/node_modules/dat-node/node_modules/debug/src/node.js","webpack:///./app/node_modules/dat-node/lib/storage.js","webpack:///./app/node_modules/dat-storage/index.js","webpack:///./app/node_modules/dat-secret-storage/index.js","webpack:///./app/node_modules/os-homedir/index.js","webpack:///./app/node_modules/multi-random-access/index.js","webpack:///./app/node_modules/abstract-random-access/index.js","webpack:///./app/node_modules/sorted-array-functions/index.js","webpack:///./app/node_modules/random-access-memory/index.js","webpack:///./app/node_modules/is-options/index.js","webpack:///./app/node_modules/dat-node/dat.js","webpack:///./app/node_modules/untildify/index.js","webpack:///./app/node_modules/dat-node/lib/import-files.js","webpack:///./app/node_modules/mirror-folder/index.js","webpack:///./app/node_modules/recursive-watch/index.js","webpack:///./app/node_modules/ttl/index.js","webpack:///./app/node_modules/fd-read-stream/index.js","webpack:///./app/node_modules/dat-ignore/index.js","webpack:///./app/node_modules/anymatch/index.js","webpack:///./app/node_modules/micromatch/index.js","webpack:///./app/node_modules/micromatch/lib/expand.js","webpack:///./app/node_modules/micromatch/lib/utils.js","webpack:///./app/node_modules/filename-regex/index.js","webpack:///./app/node_modules/arr-diff/index.js","webpack:///./app/node_modules/arr-flatten/index.js","webpack:///./app/node_modules/array-unique/index.js","webpack:///./app/node_modules/braces/index.js","webpack:///./app/node_modules/expand-range/index.js","webpack:///./app/node_modules/fill-range/index.js","webpack:///./app/node_modules/isobject/index.js","webpack:///./app/node_modules/is-number/index.js","webpack:///./app/node_modules/kind-of/index.js","webpack:///./app/node_modules/is-buffer/index.js","webpack:///./app/node_modules/randomatic/index.js","webpack:///./app/node_modules/randomatic/node_modules/is-number/index.js","webpack:///./app/node_modules/randomatic/node_modules/kind-of/index.js","webpack:///./app/node_modules/math-random/node.js","webpack:///./app/node_modules/repeat-string/index.js","webpack:///./app/node_modules/repeat-element/index.js","webpack:///./app/node_modules/preserve/index.js","webpack:///./app/node_modules/expand-brackets/index.js","webpack:///./app/node_modules/is-posix-bracket/index.js","webpack:///./app/node_modules/extglob/index.js","webpack:///./app/node_modules/is-extglob/index.js","webpack:///./app/node_modules/is-glob/index.js","webpack:///./app/node_modules/object.omit/index.js","webpack:///./app/node_modules/is-extendable/index.js","webpack:///./app/node_modules/for-own/index.js","webpack:///./app/node_modules/for-in/index.js","webpack:///./app/node_modules/parse-glob/index.js","webpack:///./app/node_modules/glob-base/index.js","webpack:///./app/node_modules/glob-parent/index.js","webpack:///./app/node_modules/is-dotfile/index.js","webpack:///./app/node_modules/regex-cache/index.js","webpack:///./app/node_modules/is-equal-shallow/index.js","webpack:///./app/node_modules/is-primitive/index.js","webpack:///./app/node_modules/micromatch/lib/glob.js","webpack:///./app/node_modules/micromatch/lib/chars.js","webpack:///./app/node_modules/xtend/immutable.js","webpack:///./app/node_modules/speedometer/index.js","webpack:///./app/node_modules/dat-node/lib/network.js","webpack:///./app/node_modules/dat-swarm-defaults/index.js","webpack:///./app/node_modules/discovery-swarm/index.js","webpack:///./app/node_modules/discovery-channel/index.js","webpack:///./app/node_modules/dns-discovery/index.js","webpack:///./app/node_modules/dns-socket/index.js","webpack:///external \"dgram\"","webpack:///./app/node_modules/dns-packet/index.js","webpack:///./app/node_modules/dns-packet/types.js","webpack:///./app/node_modules/dns-packet/rcodes.js","webpack:///./app/node_modules/dns-packet/opcodes.js","webpack:///./app/node_modules/dns-packet/classes.js","webpack:///./app/node_modules/ip/lib/ip.js","webpack:///./app/node_modules/network-address/index.js","webpack:///./app/node_modules/multicast-dns/index.js","webpack:///./app/node_modules/dns-discovery/node_modules/debug/src/index.js","webpack:///./app/node_modules/dns-discovery/node_modules/debug/src/browser.js","webpack:///./app/node_modules/dns-discovery/node_modules/debug/src/debug.js","webpack:///./app/node_modules/dns-discovery/node_modules/ms/index.js","webpack:///./app/node_modules/dns-discovery/node_modules/debug/src/node.js","webpack:///./app/node_modules/dns-discovery/store.js","webpack:///./app/node_modules/unordered-set/index.js","webpack:///./app/node_modules/dns-discovery/node_modules/lru/index.js","webpack:///./app/node_modules/bittorrent-dht/index.js","webpack:///./app/node_modules/bittorrent-dht/client.js","webpack:///./app/node_modules/bencode/lib/index.js","webpack:///./app/node_modules/bencode/lib/encode.js","webpack:///./app/node_modules/bencode/lib/decode.js","webpack:///./app/node_modules/debug/src/index.js","webpack:///./app/node_modules/debug/src/browser.js","webpack:///./app/node_modules/debug/src/common.js","webpack:///./app/node_modules/debug/src/node.js","webpack:///./app/node_modules/k-bucket/index.js","webpack:///./app/node_modules/randombytes/index.js","webpack:///./app/node_modules/k-rpc/index.js","webpack:///./app/node_modules/k-rpc-socket/index.js","webpack:///./app/node_modules/k-rpc-socket/node_modules/bencode/lib/index.js","webpack:///./app/node_modules/k-rpc-socket/node_modules/bencode/lib/encode.js","webpack:///./app/node_modules/k-rpc-socket/node_modules/bencode/lib/decode.js","webpack:///external \"dns\"","webpack:///./app/node_modules/k-rpc/node_modules/k-bucket/index.js","webpack:///./app/node_modules/lru/index.js","webpack:///./app/node_modules/simple-sha1/index.js","webpack:///./app/node_modules/bittorrent-dht/peer-store.js","webpack:///./app/node_modules/bittorrent-dht/server.js","webpack:///./app/node_modules/discovery-channel/node_modules/thunky/index.js","webpack:///./app/node_modules/discovery-channel/node_modules/debug/src/index.js","webpack:///./app/node_modules/discovery-channel/node_modules/debug/src/browser.js","webpack:///./app/node_modules/discovery-channel/node_modules/debug/src/debug.js","webpack:///./app/node_modules/discovery-channel/node_modules/ms/index.js","webpack:///./app/node_modules/discovery-channel/node_modules/debug/src/node.js","webpack:///./app/node_modules/pump/index.js","webpack:///./app/node_modules/to-buffer/index.js","webpack:///./app/node_modules/length-prefixed-message/index.js","webpack:///./app/node_modules/varint/index.js","webpack:///./app/node_modules/varint/encode.js","webpack:///./app/node_modules/varint/decode.js","webpack:///./app/node_modules/varint/length.js","webpack:///./app/node_modules/connections/index.js","webpack:///./app/node_modules/discovery-swarm/node_modules/debug/src/index.js","webpack:///./app/node_modules/discovery-swarm/node_modules/debug/src/browser.js","webpack:///./app/node_modules/discovery-swarm/node_modules/debug/src/common.js","webpack:///./app/node_modules/discovery-swarm/node_modules/debug/src/node.js","webpack:///./app/node_modules/utp-native/index.js","webpack:///./app/node_modules/utp-native/timers.js","webpack:///external \"timers\"","webpack:///./app/node_modules/dat-node/lib/stats.js","webpack:///./app/node_modules/hyperdrive-network-speed/index.js","webpack:///./app/node_modules/dat-node/lib/serve.js","webpack:///./app/node_modules/hyperdrive-http/index.js","webpack:///./app/node_modules/directory-index-html/index.js","webpack:///./app/node_modules/mime/index.js","webpack:///./app/node_modules/mime/Mime.js","webpack:///./app/node_modules/range-parser/index.js","webpack:///./app/node_modules/corsify/index.js","webpack:///./app/node_modules/http-methods/index.js","webpack:///./app/node_modules/content-types/index.js","webpack:///./app/node_modules/iterators/index.js","webpack:///./app/node_modules/iterators/lib/sync/forEach.js","webpack:///./app/node_modules/iterators/lib/sync/filter.js","webpack:///./app/node_modules/iterators/lib/sync/map.js","webpack:///./app/node_modules/iterators/lib/sync/reduce.js","webpack:///./app/node_modules/iterators/lib/sync/reduceRight.js","webpack:///./app/node_modules/iterators/lib/sync/every.js","webpack:///./app/node_modules/iterators/lib/sync/some.js","webpack:///./app/node_modules/iterators/lib/async/forEach.js","webpack:///./app/node_modules/iterators/lib/async/filter.js","webpack:///./app/node_modules/ap/index.js","webpack:///./app/node_modules/iterators/lib/async/map.js","webpack:///./app/node_modules/iterators/lib/async/reduce.js","webpack:///./app/node_modules/iterators/lib/async/reduceRight.js","webpack:///./app/node_modules/iterators/lib/async/every.js","webpack:///./app/node_modules/iterators/lib/async/some.js","webpack:///./app/node_modules/body/index.js","webpack:///external \"string_decoder\""],"names":["isOSX","helpers","APP_ARGS_FILE_PATH","path","join","__dirname","appArgs","JSON","parse","fs","readFileSync","fileDownloadOptions","Object","assign","gaele","require","getPath","thisAppDir","resolve","key","err","dat","joinNetwork","processEnvs","keys","forEach","process","env","mainWindow","flashPluginDir","app","commandLine","appendSwitch","flashPath","ignoreCertificate","disableGpu","disableHardwareAcceleration","ignoreGpuBlacklist","enableEs3Apis","diskCacheSize","basicAuthUsername","basicAuthPassword","setDockBadge","currentBadgeCount","count","bounce","dock","setBadge","on","fastQuit","quit","event","hasVisibleWindows","show","exit","crashReporter","start","companyName","productName","name","submitURL","uploadToServer","globalShortcuts","shortcut","globalShortcut","register","inputEvents","inputEvent","webContents","sendInputEvent","emit","request","authInfo","callback","preventDefault","singleInstance","shouldQuit","makeSingleInstance","isVisible","isMinimized","restore","focus","createLoginWindow","loginCallback","loginWindow","BrowserWindow","width","height","frame","resizable","loadURL","ipcMain","once","usernameAndPassword","close","linkIsInternal","getCssToInject","shouldInjectCss","getAppIcon","nativeTabsSupported","getCounterValue","onNewWindowHelper","mainWindowHelpers","ZOOM_INTERVAL","maybeHideWindow","window","tray","hide","maybeInjectCss","browserWindow","cssToInject","injectCss","insertCSS","onHeadersReceived","details","cancel","responseHeaders","session","webRequest","createMainWindow","inpOptions","onAppQuit","options","mainWindowState","defaultWidth","defaultHeight","DEFAULT_WINDOW_OPTIONS","title","tabbingIdentifier","undefined","webPreferences","javascript","plugins","nodeIntegration","webSecurity","insecure","preload","zoomFactor","zoom","hideWindowFrame","minWidth","minHeight","maxWidth","maxHeight","x","y","autoHideMenuBar","showMenuBar","icon","fullscreen","fullScreen","alwaysOnTop","titleBarStyle","manage","maximize","writeFileSync","stringify","withFocusedWindow","block","focusedWindow","getFocusedWindow","adjustWindowZoom","adjustment","getZoomFactor","setZoomFactor","onZoomIn","onZoomOut","onZoomReset","clearAppData","dialog","showMessageBox","type","buttons","defaultId","message","response","clearStorageData","clearCache","targetUrl","onGoBack","goBack","onGoForward","goForward","getCurrentUrl","getURL","onWillNavigate","urlToGo","internalUrls","shell","openExternal","createNewWindow","createNewTab","url","foreground","newTab","addTabbedWindow","createAboutBlankWindow","onNewWindow","_","disposition","newGuest","sendParamsOnDidFinishLoad","send","userAgent","setUserAgent","menuOptions","golemVersion","appQuit","zoomIn","zoomOut","zoomReset","zoomBuildTimeValue","disableDevTools","disableContextMenu","counter","e","counterValue","isFocused","isFullScreen","moveTabToNewWindow","setFullScreen","bind","newWindow","INJECT_CSS_PATH","log","os","platform","isLinux","isWindows","currentUrl","newUrl","internalUrlRegex","regex","RegExp","test","currentDomain","newDomain","accessSync","F_OK","toString","debugLog","setTimeout","info","itemCountRegex","match","exec","createMenu","Menu","getApplicationMenu","zoomResetLabel","template","label","role","submenu","accelerator","click","item","reload","currentURL","clipboard","writeText","toggleDevTools","splice","length","unshift","push","menu","buildFromTemplate","setApplicationMenu","initContextMenu","prepend","params","items","linkURL","Tray","nativeImage","createTrayIcon","iconPath","nimage","createFromPath","appIcon","onClick","contextMenu","setHighlightMode","setToolTip","setContextMenu","findSync","pattern","basePath","findDir","matches","findSyncRecurse","base","children","readdirSync","exception","code","child","childPath","childIsDirectory","lstatSync","isDirectory","patternMatches","linuxMatch","windowsMatch","darwinMatch","inferFlash","warn"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;AClFA;;AACA;;;;AACA;;;;AACA;;AACA;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;IAEQA,K,GAAUC,iB,CAAVD,K;;;AAER,IAAME,qBAAqBC,eAAKC,IAAL,CAAUC,SAAV,EAAqB,IAArB,EAA2B,YAA3B,CAA3B;AACA,IAAMC,UAAUC,KAAKC,KAAL,CAAWC,aAAGC,YAAH,CAAgBR,kBAAhB,EAAoC,MAApC,CAAX,CAAhB;;AAEA,IAAMS,sBAAsBC,OAAOC,MAAP,CAAc,EAAd,EAAkBP,QAAQK,mBAA1B,CAA5B;AACA,0BAAiBA,mBAAjB;;AAEA,IAAMG,QAAQC,mBAAOA,CAAC,EAAR,CAAd;AACA,IAAMC,UAAUD,mBAAOA,CAAC,EAAR,CAAhB;AACA,IAAME,aAAaD,QAAQE,OAAR,CAAgB,IAAhB,CAAnB;;AAEA;AACAJ,MAAMG,aAAa,iBAAnB,EAAsC;AACpCE,OAAK;AAD+B,CAAtC,EAEG,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AACrB,MAAID,GAAJ,EAAS,MAAMA,GAAN;AACTC,MAAIC,WAAJ;AACD,CALD;;AAOA,IAAIhB,QAAQiB,WAAZ,EAAyB;AACvBX,SAAOY,IAAP,CAAYlB,QAAQiB,WAApB,EAAiCE,OAAjC,CAAyC,UAACN,GAAD,EAAS;AAChD;AACAO,YAAQC,GAAR,CAAYR,GAAZ,IAAmBb,QAAQiB,WAAR,CAAoBJ,GAApB,CAAnB;AACD,GAHD;AAID;;AAED,IAAIS,mBAAJ;;AAEA,IAAI,OAAOtB,QAAQuB,cAAf,KAAkC,QAAtC,EAAgD;AAC9CC,gBAAIC,WAAJ,CAAgBC,YAAhB,CAA6B,kBAA7B,EAAiD1B,QAAQuB,cAAzD;AACD,CAFD,MAEO,IAAIvB,QAAQuB,cAAZ,EAA4B;AACjC,MAAMI,YAAY,2BAAlB;AACAH,gBAAIC,WAAJ,CAAgBC,YAAhB,CAA6B,kBAA7B,EAAiDC,SAAjD;AACD;;AAED,IAAI3B,QAAQ4B,iBAAZ,EAA+B;AAC7BJ,gBAAIC,WAAJ,CAAgBC,YAAhB,CAA6B,2BAA7B;AACD;;AAED,IAAI1B,QAAQ6B,UAAZ,EAAwB;AACtBL,gBAAIM,2BAAJ;AACD;;AAED,IAAI9B,QAAQ+B,kBAAZ,EAAgC;AAC9BP,gBAAIC,WAAJ,CAAgBC,YAAhB,CAA6B,sBAA7B;AACD;;AAED,IAAI1B,QAAQgC,aAAZ,EAA2B;AACzBR,gBAAIC,WAAJ,CAAgBC,YAAhB,CAA6B,iBAA7B;AACD;;AAED,IAAI1B,QAAQiC,aAAZ,EAA2B;AACzBT,gBAAIC,WAAJ,CAAgBC,YAAhB,CAA6B,iBAA7B,EAAgD1B,QAAQiC,aAAxD;AACD;;AAED,IAAIjC,QAAQkC,iBAAZ,EAA+B;AAC7BV,gBAAIC,WAAJ,CAAgBC,YAAhB,CACE,qBADF,EAEE1B,QAAQkC,iBAFV;AAID;;AAED,IAAIlC,QAAQmC,iBAAZ,EAA+B;AAC7BX,gBAAIC,WAAJ,CAAgBC,YAAhB,CACE,qBADF,EAEE1B,QAAQmC,iBAFV;AAID;;AAED;AACA,IAAIC,eAAe,wBAAM,CAAE,CAA3B;;AAEA,IAAI1C,OAAJ,EAAa;AACX,MAAI2C,oBAAoB,CAAxB;;AAEAD,iBAAe,sBAACE,KAAD,EAA2B;AAAA,QAAnBC,MAAmB,uEAAV,KAAU;;AACxCf,kBAAIgB,IAAJ,CAASC,QAAT,CAAkBH,KAAlB;AACA,QAAIC,UAAUD,QAAQD,iBAAtB,EAAyCb,cAAIgB,IAAJ,CAASD,MAAT;AACzCF,wBAAoBC,KAApB;AACD,GAJD;AAKD;;AAEDd,cAAIkB,EAAJ,CAAO,mBAAP,EAA4B,YAAM;AAChC,MAAI,CAAChD,OAAD,IAAYM,QAAQ2C,QAAxB,EAAkC;AAChCnB,kBAAIoB,IAAJ;AACD;AACF,CAJD;;AAMApB,cAAIkB,EAAJ,CAAO,UAAP,EAAmB,UAACG,KAAD,EAAQC,iBAAR,EAA8B;AAC/C,MAAIpD,OAAJ,EAAa;AACX;AACA,QAAI,CAACoD,iBAAL,EAAwB;AACtBxB,iBAAWyB,IAAX;AACD;AACF;AACF,CAPD;;AASAvB,cAAIkB,EAAJ,CAAO,aAAP,EAAsB,YAAM;AAC1B;AACA,MAAIhD,OAAJ,EAAa;AACX;AACA;AACA;;AAEA;AACA8B,kBAAIwB,IAAJ,CAAS,CAAT;AACD;AACF,CAVD;;AAYA,IAAIhD,QAAQiD,aAAZ,EAA2B;AACzBzB,gBAAIkB,EAAJ,CAAO,uBAAP,EAAgC,YAAM;AACpCO,4BAAcC,KAAd,CAAoB;AAClBC,mBAAanD,QAAQmD,WAAR,IAAuB,EADlB;AAElBC,mBAAapD,QAAQqD,IAFH;AAGlBC,iBAAWtD,QAAQiD,aAHD;AAIlBM,sBAAgB;AAJE,KAApB;AAMD,GAPD;AAQD;;AAED/B,cAAIkB,EAAJ,CAAO,OAAP,EAAgB,YAAM;AACpBpB,eAAa,0BAAiBtB,OAAjB,EAA0BwB,cAAIoB,IAA9B,EAAoCR,YAApC,CAAb;AACA,0BAAepC,OAAf,EAAwBsB,UAAxB;;AAEA;AACA,MAAItB,QAAQwD,eAAZ,EAA6B;AAC3BxD,YAAQwD,eAAR,CAAwBrC,OAAxB,CAAgC,UAACsC,QAAD,EAAc;AAC5CC,+BAAeC,QAAf,CAAwBF,SAAS5C,GAAjC,EAAsC,YAAM;AAC1C4C,iBAASG,WAAT,CAAqBzC,OAArB,CAA6B,UAAC0C,UAAD,EAAgB;AAC3CvC,qBAAWwC,WAAX,CAAuBC,cAAvB,CAAsCF,UAAtC;AACD,SAFD;AAGD,OAJD;AAKD,KAND;AAOD;AACF,CAdD;;AAgBArC,cAAIkB,EAAJ,CAAO,oBAAP,EAA6B,YAAM;AACjCpB,aAAW0C,IAAX,CAAgB,SAAhB;AACD,CAFD;;AAIAxC,cAAIkB,EAAJ,CAAO,OAAP,EAAgB,UAACG,KAAD,EAAQiB,WAAR,EAAqBG,OAArB,EAA8BC,QAA9B,EAAwCC,QAAxC,EAAqD;AACnE;AACAtB,QAAMuB,cAAN;;AAEA,MACEpE,QAAQkC,iBAAR,KAA8B,IAA9B,IACAlC,QAAQmC,iBAAR,KAA8B,IAFhC,EAGE;AACAgC,aAASnE,QAAQkC,iBAAjB,EAAoClC,QAAQmC,iBAA5C;AACD,GALD,MAKO;AACL,+BAAkBgC,QAAlB;AACD;AACF,CAZD;;AAcA,IAAInE,QAAQqE,cAAZ,EAA4B;AAC1B,MAAMC,aAAa9C,cAAI+C,kBAAJ,CAAuB,YAAM;AAC9C;AACA,QAAIjD,UAAJ,EAAgB;AACd,UAAI,CAACA,WAAWkD,SAAX,EAAL,EAA6B;AAC3B;AACAlD,mBAAWyB,IAAX;AACD;AACD,UAAIzB,WAAWmD,WAAX,EAAJ,EAA8B;AAC5B;AACAnD,mBAAWoD,OAAX;AACD;AACDpD,iBAAWqD,KAAX;AACD;AACF,GAbkB,CAAnB;;AAeA,MAAIL,UAAJ,EAAgB;AACd9C,kBAAIoB,IAAJ;AACD;AACF,C;;;;;;AC1LD,mBAAO,CAAC,CAAI;;;;;;;ACAZ,wBAAwB,mBAAO,CAAC,CAAY;AAC5C,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA,OAAO,mBAAO,CAAC,EAAI;AACnB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,YAAY,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,gCAAgC,EAAE;AAC5F,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wCAAwC,gDAAgD;AACxF,oCAAoC,wBAAwB;AAC5D,sCAAsC,sBAAsB;AAC5D,wCAAwC,4BAA4B;AACpE,iDAAiD,wBAAwB;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2FAA2F,oBAAoB;AAC/G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC/iBA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAO,CAAC,CAA4B;AACjE,4BAA4B,mBAAO,CAAC,EAA2B;AAC/D,qBAAqB,mBAAO,CAAC,EAAmB;;;;;;;ACPhD,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,CAAc;AACtC,WAAW,mBAAO,CAAC,CAAQ;AAC3B,eAAe,mBAAO,CAAC,CAAa;AACpC,kBAAkB,mBAAO,CAAC,CAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxaA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,CAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;;;;AC3IA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB,mBAAmB;AACnB,oBAAoB;;AAEpB,gBAAgB;AAChB,gBAAgB;;AAEhB,gBAAgB;AAChB,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AClEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACveA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,CAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxHA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,CAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9EA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,CAAQ;AAC3B,mBAAmB,mBAAO,CAAC,EAAiB;AAC5C,eAAe,mBAAO,CAAC,CAAa;AACpC,gBAAgB,mBAAO,CAAC,CAAc;AACtC,gBAAgB,mBAAO,CAAC,EAAc;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB,EAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACxnCA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC9GA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;;;;;;ACjHA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mBAAO,CAAC,CAAwB;AACzD,WAAW,mBAAO,CAAC,CAAQ;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,UAAU;AACV;;AAEA;;;;;;;AC5ZA,iC;;;;;;ACAA,+B;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACpEA,mC;;;;;;ACAA,qC;;;;;;;ACAa;AACb,aAAa,mBAAO,CAAC,EAAM;AAC3B,iBAAiB,mBAAO,CAAC,EAAU;AACnC,uBAAuB,mBAAO,CAAC,EAAiB;AAChD,aAAa,mBAAO,CAAC,EAAM;AAC3B,gBAAgB,mBAAO,CAAC,EAAU;;AAElC,OAAO,WAAW;;AAElB;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,KAAK,GAAG,YAAY;AAC/B;;AAEA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,iEAAiE,SAAS;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,wCAAwC,6BAA6B;AACrE;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA,EAAE;AACF;;AAEA;AACA,2BAA2B,YAAY,yBAAyB;;AAEhE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;;;;;;;AChJY;AACb,mBAAmB,mBAAO,CAAC,EAAa;AACxC,uBAAuB,mBAAO,CAAC,EAAiB;;AAEhD;AACA;AACA,uDAAuD,SAAS,IAAI,IAAI,GAAG,IAAI;AAC/E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACnBa;AACb,WAAW,mBAAO,CAAC,EAAI;;AAEvB;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;AChBa;AACb,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;;AChBa;AACb;AACA;AACA,sEAAsE,WAAW;AACjF;;AAEA;AACA,8EAA8E,YAAY;AAC1F;;AAEA,cAAc,MAAM;;AAEpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;;;;;;;ACrBa;AACb,gBAAgB,mBAAO,CAAC,EAAU;AAClC,uBAAuB,mBAAO,CAAC,EAAkB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;;;;;;;AC9Ba;AACb,aAAa,mBAAO,CAAC,EAAS;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAAW;;;;;;;;;;;;;;ACVvB;;AAEb,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,EAAE;AACF;;;;;;;;ACrBa;AACb,iBAAiB,mBAAO,CAAC,EAAc;;AAEvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;AC3Ca;AACb;;AAEA;AACA;AACA,qJAAqJ;AACrJ;;;;;;;;;;;;;;ACNA;;AACA;;;;;;AAEA,SAASgC,iBAAT,CAA2BC,aAA3B,EAA0C;AACxC,MAAMC,cAAc,IAAIC,uBAAJ,CAAkB;AACpCC,WAAO,GAD6B;AAEpCC,YAAQ,GAF4B;AAGpCC,WAAO,KAH6B;AAIpCC,eAAW;AAJyB,GAAlB,CAApB;AAMAL,cAAYM,OAAZ,CACG,UAASvF,eAAKC,IAAL,CAAUC,SAAV,EAAqB,0BAArB,CAAiD,EAD7D;;AAIAsF,oBAAQC,IAAR,CAAa,eAAb,EAA8B,UAACzC,KAAD,EAAQ0C,mBAAR,EAAgC;AAC5DV,kBAAcU,oBAAoB,CAApB,CAAd,EAAsCA,oBAAoB,CAApB,CAAtC;AACAT,gBAAYU,KAAZ;AACD,GAHD;AAIA,SAAOV,WAAP;AACD;;kBAEcF,iB;;;;;;;;;;;;;ACrBf;;;;AACA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;IAGElF,K,GAOEC,iB,CAPFD,K;IACA+F,c,GAME9F,iB,CANF8F,c;IACAC,c,GAKE/F,iB,CALF+F,c;IACAC,e,GAIEhG,iB,CAJFgG,e;IACAC,U,GAGEjG,iB,CAHFiG,U;IACAC,mB,GAEElG,iB,CAFFkG,mB;IACAC,e,GACEnG,iB,CADFmG,e;IAGMC,iB,GAAsBC,2B,CAAtBD,iB;;;AAER,IAAME,gBAAgB,GAAtB;;AAEA,SAASC,eAAT,CAAyBC,MAAzB,EAAiCtD,KAAjC,EAAwCF,QAAxC,EAAkDyD,IAAlD,EAAwD;AACtD,MAAI1G,WAAW,CAACiD,QAAhB,EAA0B;AACxB;AACAE,UAAMuB,cAAN;AACA+B,WAAOE,IAAP;AACD,GAJD,MAIO,IAAI,CAAC1D,QAAD,IAAayD,IAAjB,EAAuB;AAC5BvD,UAAMuB,cAAN;AACA+B,WAAOE,IAAP;AACD;AACD;AACD;;AAED,SAASC,cAAT,CAAwBC,aAAxB,EAAuC;AACrC,MAAI,CAACZ,iBAAL,EAAwB;AACtB;AACD;;AAED,MAAMa,cAAcd,gBAApB;;AAEA,MAAMe,YAAY,SAAZA,SAAY,GAAM;AACtBF,kBAAczC,WAAd,CAA0B4C,SAA1B,CAAoCF,WAApC;AACD,GAFD;AAGA,MAAMG,oBAAoB,SAApBA,iBAAoB,CAACC,OAAD,EAAUzC,QAAV,EAAuB;AAC/CsC;AACAtC,aAAS,EAAE0C,QAAQ,KAAV,EAAiBC,iBAAiBF,QAAQE,eAA1C,EAAT;AACD,GAHD;;AAKAP,gBAAczC,WAAd,CAA0BpB,EAA1B,CAA6B,iBAA7B,EAAgD,YAAM;AACpD;AACA6D,kBAAczC,WAAd,CAA0BiD,OAA1B,CAAkCC,UAAlC,CAA6CL,iBAA7C,CAA+D,IAA/D;AACD,GAHD;;AAKA;AACAJ,gBAAczC,WAAd,CAA0BpB,EAA1B,CAA6B,cAA7B,EAA6C,YAAM;AACjD;AACA;AACA6D,kBAAczC,WAAd,CAA0BiD,OAA1B,CAAkCC,UAAlC,CAA6CL,iBAA7C,CACE,EADF,EACM;AACJA,qBAFF;AAID,GAPD;AAQD;;AAED;;;;;;;AAOA,SAASM,gBAAT,CAA0BC,UAA1B,EAAsCC,SAAtC,EAAiD/E,YAAjD,EAA+D;AAAA;;AAC7D,MAAMgF,UAAU9G,OAAOC,MAAP,CAAc,EAAd,EAAkB2G,UAAlB,CAAhB;AACA,MAAMG,kBAAkB,mCAAkB;AACxCC,kBAAcF,QAAQpC,KAAR,IAAiB,IADS;AAExCuC,mBAAeH,QAAQnC,MAAR,IAAkB;AAFO,GAAlB,CAAxB;;AAKA,MAAMuC,yBAAyB;AAC7B;AACAC,WAAOL,QAAQ/D,IAFc;AAG7BqE,uBAAmB7B,wBAAwBuB,QAAQ/D,IAAhC,GAAuCsE,SAH7B;AAI7BC,oBAAgB;AACdC,kBAAY,IADE;AAEdC,eAAS,IAFK;AAGd;AACAC,uBAAiB,KAJH;AAKdC,mBAAa,CAACZ,QAAQa,QALR;AAMdC,eAASrI,eAAKC,IAAL,CAAUC,SAAV,EAAqB,QAArB,EAA+B,YAA/B,CANK;AAOdoI,kBAAYf,QAAQgB;AAPN;AAJa,GAA/B;;AAeA,MAAM9G,aAAa,IAAIyD,uBAAJ,CACjBzE,OAAOC,MAAP,CACE;AACE2E,WAAO,CAACkC,QAAQiB,eADlB;AAEErD,WAAOqC,gBAAgBrC,KAFzB;AAGEC,YAAQoC,gBAAgBpC,MAH1B;AAIEqD,cAAUlB,QAAQkB,QAJpB;AAKEC,eAAWnB,QAAQmB,SALrB;AAMEC,cAAUpB,QAAQoB,QANpB;AAOEC,eAAWrB,QAAQqB,SAPrB;AAQEC,OAAGtB,QAAQsB,CARb;AASEC,OAAGvB,QAAQuB,CATb;AAUEC,qBAAiB,CAACxB,QAAQyB,WAV5B;AAWE;AACAC,UAAMlD,YAZR;AAaE;AACAmD,gBAAY3B,QAAQ4B,UAAR,IAAsBrB,SAdpC;AAeE;AACAsB,iBAAa7B,QAAQ6B,WAhBvB;AAiBEC,mBAAe9B,QAAQ8B,aAjBzB;AAkBEnG,UAAMqE,QAAQhB,IAAR,KAAiB;AAlBzB,GADF,EAqBEoB,sBArBF,CADiB,CAAnB;;AA0BAH,kBAAgB8B,MAAhB,CAAuB7H,UAAvB;;AAEA;AACA,MAAI8F,QAAQgC,QAAZ,EAAsB;AACpB9H,eAAW8H,QAAX;AACAhC,YAAQgC,QAAR,GAAmBzB,SAAnB;AACAxH,iBAAGkJ,aAAH,CACExJ,eAAKC,IAAL,CAAUC,SAAV,EAAqB,IAArB,EAA2B,YAA3B,CADF,EAEEE,KAAKqJ,SAAL,CAAelC,OAAf,CAFF;AAID;;AAED,MAAMmC,oBAAoB,SAApBA,iBAAoB,CAACC,KAAD,EAAW;AACnC,QAAMC,gBAAgB1E,wBAAc2E,gBAAd,EAAtB;AACA,QAAID,aAAJ,EAAmB;AACjB,aAAOD,MAAMC,aAAN,CAAP;AACD;AACD,WAAO9B,SAAP;AACD,GAND;;AAQA,MAAMgC,mBAAmB,SAAnBA,gBAAmB,CAACxD,MAAD,EAASyD,UAAT,EAAwB;AAC/CzD,WAAOrC,WAAP,CAAmB+F,aAAnB,CAAiC,UAAC1B,UAAD,EAAgB;AAC/ChC,aAAOrC,WAAP,CAAmBgG,aAAnB,CAAiC3B,aAAayB,UAA9C;AACD,KAFD;AAGD,GAJD;;AAMA,MAAMG,WAAW,SAAXA,QAAW,GAAM;AACrBR,sBAAkB,UAACE,aAAD;AAAA,aAChBE,iBAAiBF,aAAjB,EAAgCxD,aAAhC,CADgB;AAAA,KAAlB;AAGD,GAJD;;AAMA,MAAM+D,YAAY,SAAZA,SAAY,GAAM;AACtBT,sBAAkB,UAACE,aAAD;AAAA,aAChBE,iBAAiBF,aAAjB,EAAgC,CAACxD,aAAjC,CADgB;AAAA,KAAlB;AAGD,GAJD;;AAMA,MAAMgE,cAAc,SAAdA,WAAc,GAAM;AACxBV,sBAAkB,UAACE,aAAD,EAAmB;AACnCA,oBAAc3F,WAAd,CAA0BgG,aAA1B,CAAwC1C,QAAQgB,IAAhD;AACD,KAFD;AAGD,GAJD;;AAMA,MAAM8B,eAAe,SAAfA,YAAe,GAAM;AACzBC,qBAAOC,cAAP,CACE9I,UADF,EAEE;AACE+I,YAAM,SADR;AAEEC,eAAS,CAAC,KAAD,EAAQ,QAAR,CAFX;AAGEC,iBAAW,CAHb;AAIE9C,aAAO,iBAJT;AAKE+C,eACE;AANJ,KAFF,EAUE,UAACC,QAAD,EAAc;AACZ,UAAIA,aAAa,CAAjB,EAAoB;AAClB;AACD;AAHW,UAIJ1D,OAJI,GAIQzF,WAAWwC,WAJnB,CAIJiD,OAJI;;AAKZA,cAAQ2D,gBAAR,CAAyB,YAAM;AAC7B3D,gBAAQ4D,UAAR,CAAmB,YAAM;AACvBrJ,qBAAW8D,OAAX,CAAmBgC,QAAQwD,SAA3B;AACD,SAFD;AAGD,OAJD;AAKD,KApBH;AAsBD,GAvBD;;AAyBA,MAAMC,WAAW,SAAXA,QAAW,GAAM;AACrBtB,sBAAkB,UAACE,aAAD,EAAmB;AACnCA,oBAAc3F,WAAd,CAA0BgH,MAA1B;AACD,KAFD;AAGD,GAJD;;AAMA,MAAMC,cAAc,SAAdA,WAAc,GAAM;AACxBxB,sBAAkB,UAACE,aAAD,EAAmB;AACnCA,oBAAc3F,WAAd,CAA0BkH,SAA1B;AACD,KAFD;AAGD,GAJD;;AAMA,MAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,WACpB1B,kBAAkB,UAACE,aAAD;AAAA,aAAmBA,cAAc3F,WAAd,CAA0BoH,MAA1B,EAAnB;AAAA,KAAlB,CADoB;AAAA,GAAtB;;AAGA,MAAMC,iBAAiB,SAAjBA,cAAiB,CAACtI,KAAD,EAAQuI,OAAR,EAAoB;AACzC,QAAI,CAAC3F,eAAe2B,QAAQwD,SAAvB,EAAkCQ,OAAlC,EAA2ChE,QAAQiE,YAAnD,CAAL,EAAuE;AACrExI,YAAMuB,cAAN;AACAkH,sBAAMC,YAAN,CAAmBH,OAAnB;AACD;AACF,GALD;;AAOA,MAAII,wBAAJ;;AAEA,MAAMC,eAAe,SAAfA,YAAe,CAACC,GAAD,EAAMC,UAAN,EAAqB;AACxCpC,sBAAkB,UAACE,aAAD,EAAmB;AACnC,UAAMmC,SAASJ,gBAAgBE,GAAhB,CAAf;AACAjC,oBAAcoC,eAAd,CAA8BD,MAA9B;AACA,UAAI,CAACD,UAAL,EAAiB;AACflC,sBAAc9E,KAAd;AACD;AACD,aAAOiH,MAAP;AACD,KAPD;AAQA,WAAOjE,SAAP;AACD,GAVD;;AAYA,MAAMmE,yBAAyB,SAAzBA,sBAAyB,GAAM;AACnC,QAAM3F,SAASqF,gBAAgB,aAAhB,CAAf;AACArF,WAAOE,IAAP;AACAF,WAAOrC,WAAP,CAAmBwB,IAAnB,CAAwB,kBAAxB,EAA4C,YAAM;AAChD,UAAIa,OAAOrC,WAAP,CAAmBoH,MAAnB,OAAgC,aAApC,EAAmD;AACjD/E,eAAOX,KAAP;AACD,OAFD,MAEO;AACLW,eAAOpD,IAAP;AACD;AACF,KAND;AAOA,WAAOoD,MAAP;AACD,GAXD;;AAaA,MAAM4F,cAAc,SAAdA,WAAc,CAAClJ,KAAD,EAAQuI,OAAR,EAAiBY,CAAjB,EAAoBC,WAApB,EAAoC;AACtD,QAAM7H,iBAAiB,SAAjBA,cAAiB,CAAC8H,QAAD,EAAc;AACnCrJ,YAAMuB,cAAN;AACA,UAAI8H,QAAJ,EAAc;AACZ;AACArJ,cAAMqJ,QAAN,GAAiBA,QAAjB;AACD;AACF,KAND;AAOAnG,sBACEqF,OADF,EAEEa,WAFF,EAGE7E,QAAQwD,SAHV,EAIExD,QAAQiE,YAJV,EAKEjH,cALF,EAMEkH,gBAAMC,YANR,EAOEO,sBAPF,EAQEjG,mBARF,EASE4F,YATF;AAWD,GAnBD;;AAqBA,MAAMU,4BAA4B,SAA5BA,yBAA4B,CAAChG,MAAD,EAAY;AAC5CA,WAAOrC,WAAP,CAAmBpB,EAAnB,CAAsB,iBAAtB,EAAyC,YAAM;AAC7CyD,aAAOrC,WAAP,CAAmBsI,IAAnB,CAAwB,QAAxB,EAAkCnM,KAAKqJ,SAAL,CAAelC,OAAf,CAAlC;AACD,KAFD;AAGD,GAJD;;AAMAoE,oBAAkB,yBAACE,GAAD,EAAS;AACzB,QAAMvF,SAAS,IAAIpB,uBAAJ,CAAkByC,sBAAlB,CAAf;AACA,QAAIJ,QAAQiF,SAAZ,EAAuB;AACrBlG,aAAOrC,WAAP,CAAmBwI,YAAnB,CAAgClF,QAAQiF,SAAxC;AACD;AACD/F,mBAAeH,MAAf;AACAgG,8BAA0BhG,MAA1B;AACAA,WAAOrC,WAAP,CAAmBpB,EAAnB,CAAsB,YAAtB,EAAoCqJ,WAApC;AACA5F,WAAOrC,WAAP,CAAmBpB,EAAnB,CAAsB,eAAtB,EAAuCyI,cAAvC;AACAhF,WAAOf,OAAP,CAAesG,GAAf;AACA,WAAOvF,MAAP;AACD,GAXD;;AAaA,MAAMoG,cAAc;AAClBC,kBAAcpF,QAAQoF,YADJ;AAElBC,aAAStF,SAFS;AAGlBuF,YAAQ3C,QAHU;AAIlB4C,aAAS3C,SAJS;AAKlB4C,eAAW3C,WALO;AAMlB4C,wBAAoBzF,QAAQgB,IANV;AAOlB0C,YAAQD,QAPU;AAQlBG,eAAWD,WARO;AASlBE,iBATkB;AAUlBf,gBAVkB;AAWlB4C,qBAAiB1F,QAAQ0F;AAXP,GAApB;;AAcA,sBAAWP,WAAX;AACA,MAAI,CAACnF,QAAQ2F,kBAAb,EAAiC;AAC/B,+BACEvB,eADF,EAEE3F,wBAAwB4F,YAAxB,GAAuC9D,SAFzC;AAID;;AAED,MAAIP,QAAQiF,SAAZ,EAAuB;AACrB/K,eAAWwC,WAAX,CAAuBwI,YAAvB,CAAoClF,QAAQiF,SAA5C;AACD;;AAED/F,iBAAehF,UAAf;AACA6K,4BAA0B7K,UAA1B;;AAEA,MAAI8F,QAAQ4F,OAAZ,EAAqB;AACnB1L,eAAWoB,EAAX,CAAc,oBAAd,EAAoC,UAACuK,CAAD,EAAIxF,KAAJ,EAAc;AAChD,UAAMyF,eAAepH,gBAAgB2B,KAAhB,CAArB;AACA,UAAIyF,YAAJ,EAAkB;AAChB9K,qBAAa8K,YAAb,EAA2B9F,QAAQ7E,MAAnC;AACD,OAFD,MAEO;AACLH,qBAAa,EAAb;AACD;AACF,KAPD;AAQD,GATD,MASO;AACLiD,sBAAQ3C,EAAR,CAAW,cAAX,EAA2B,YAAM;AAC/B,UAAI,CAAChD,OAAD,IAAY4B,WAAW6L,SAAX,EAAhB,EAAwC;AACtC;AACD;AACD/K,mBAAa,GAAb,EAAkBgF,QAAQ7E,MAA1B;AACD,KALD;AAMAjB,eAAWoB,EAAX,CAAc,OAAd,EAAuB,YAAM;AAC3BN,mBAAa,EAAb;AACD,KAFD;AAGD;;AAEDiD,oBAAQ3C,EAAR,CAAW,oBAAX,EAAiC,YAAM;AACrCpB,eAAWyB,IAAX;AACD,GAFD;;AAIAzB,aAAWwC,WAAX,CAAuBpB,EAAvB,CAA0B,YAA1B,EAAwCqJ,WAAxC;AACAzK,aAAWwC,WAAX,CAAuBpB,EAAvB,CAA0B,eAA1B,EAA2CyI,cAA3C;;AAEA7J,aAAW8D,OAAX,CAAmBgC,QAAQwD,SAA3B;;AAEAtJ,aAAWoB,EAAX,CAAc,SAAd,EAAyB;AAAA,WAAM+I,aAAarE,QAAQwD,SAArB,EAAgC,IAAhC,CAAN;AAAA,GAAzB;;AAEAtJ,aAAWoB,EAAX,CAAc,OAAd,EAAuB,UAACG,KAAD,EAAW;AAChC,QAAIvB,WAAW8L,YAAX,EAAJ,EAA+B;AAC7B,UAAIvH,qBAAJ,EAA2B;AACzBvE,mBAAW+L,kBAAX;AACD;AACD/L,iBAAWgM,aAAX,CAAyB,KAAzB;AACAhM,iBAAWgE,IAAX,CACE,mBADF,EAEEY,gBAAgBqH,IAAhB,CAAqB,KAArB,EAA2BjM,UAA3B,EAAuCuB,KAAvC,EAA8CuE,QAAQzE,QAAtD,CAFF;AAID;AACDuD,oBAAgB5E,UAAhB,EAA4BuB,KAA5B,EAAmCuE,QAAQzE,QAA3C,EAAqDyE,QAAQhB,IAA7D;AACD,GAZD;;AAcA,SAAO9E,UAAP;AACD;;kBAEc2F,gB;;;;;;;ACrWF;;AAEb,WAAW,mBAAO,CAAC,EAAM;AACzB,eAAe,mBAAO,CAAC,EAAU;AACjC,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,gBAAgB,EAAE;AAC/B,aAAa,gBAAgB,EAAE;AAC/B,iBAAiB,oBAAoB,EAAE;AACvC,kBAAkB,qBAAqB,EAAE;AACzC,uBAAuB,0BAA0B,EAAE;AACnD,wBAAwB,2BAA2B,EAAE;AACrD;AACA;AACA;AACA;AACA;;;;;;;AC7KA;AACA;AACA,QAAQ,mBAAO,CAAC,EAAa;AAC7B,CAAC;AACD,QAAQ,mBAAO,CAAC,EAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpIA,SAAS,mBAAO,CAAC,EAAI;AACrB,gBAAgB,mBAAO,CAAC,EAAgB;AACxC,aAAa,mBAAO,CAAC,EAAqB;AAC1C,YAAY,mBAAO,CAAC,EAAY;;AAEhC;;AAEA,WAAW,mBAAO,CAAC,EAAM;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,EAAQ;AACpB,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtRA,gBAAgB,mBAAO,CAAC,EAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACxUA,sC;;;;;;ACAA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrHA,mC;;;;;;;ACAY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;AClBA,iC;;;;;;ACAA,mC;;;;;;ACAA,WAAW,mBAAO,CAAC,EAAM;AACzB,SAAS,mBAAO,CAAC,EAAI;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACjGA;AACA,iBAAiB,mBAAO,CAAC,EAAe;AACxC,kBAAkB,mBAAO,CAAC,EAAuB;;AAEjD;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;;;;;;;AC7FA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;;;;;;IAEQxB,c,GAAmB9F,iB,CAAnB8F,c;;;AAER,SAASM,iBAAT,CACEqF,OADF,EAEEa,WAFF,EAGErB,SAHF,EAIES,YAJF,EAKEjH,cALF,EAMEmH,YANF,EAOEO,sBAPF,EAQEjG,mBARF,EASE4F,YATF,EAUE;AACA,MAAI,CAAChG,eAAemF,SAAf,EAA0BQ,OAA1B,EAAmCC,YAAnC,CAAL,EAAuD;AACrDE,iBAAaH,OAAb;AACAhH;AACD,GAHD,MAGO,IAAIgH,YAAY,aAAhB,EAA+B;AACpC,QAAMoC,YAAY1B,wBAAlB;AACA1H,mBAAeoJ,SAAf;AACD,GAHM,MAGA,IAAI3H,qBAAJ,EAA2B;AAChC,QAAIoG,gBAAgB,gBAApB,EAAsC;AACpC,UAAML,SAASH,aAAaL,OAAb,EAAsB,KAAtB,CAAf;AACAhH,qBAAewH,MAAf;AACD,KAHD,MAGO,IAAIK,gBAAgB,gBAApB,EAAsC;AAC3C,UAAML,UAASH,aAAaL,OAAb,EAAsB,IAAtB,CAAf;AACAhH,qBAAewH,OAAf;AACD;AACF;AACF;;kBAEc,EAAE7F,iBAAF,E;;;;;;;;;;;;;AChCf;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAM0H,kBAAkB5N,eAAKC,IAAL,CAAUC,SAAV,EAAqB,IAArB,EAA2B,mBAA3B,CAAxB;AACA,IAAM2N,MAAMjN,mBAAOA,CAAC,EAAR,CAAZ;;AAEA,SAASf,KAAT,GAAiB;AACf,SAAOiO,aAAGC,QAAH,OAAkB,QAAzB;AACD;;AAED,SAASC,OAAT,GAAmB;AACjB,SAAOF,aAAGC,QAAH,OAAkB,OAAzB;AACD;;AAED,SAASE,SAAT,GAAqB;AACnB,SAAOH,aAAGC,QAAH,OAAkB,OAAzB;AACD;;AAED,SAASnI,cAAT,CAAwBsI,UAAxB,EAAoCC,MAApC,EAA4CC,gBAA5C,EAA8D;AAC5D,MAAID,WAAW,aAAf,EAA8B;AAC5B,WAAO,IAAP;AACD;;AAED,MAAIC,gBAAJ,EAAsB;AACpB,QAAMC,QAAQC,OAAOF,gBAAP,CAAd;AACA,WAAOC,MAAME,IAAN,CAAWJ,MAAX,CAAP;AACD;;AAED,MAAMK,gBAAgB,oBAAK,QAAL,EAAeN,UAAf,CAAtB;AACA,MAAMO,YAAY,oBAAK,QAAL,EAAeN,MAAf,CAAlB;AACA,SAAOK,kBAAkBC,SAAzB;AACD;;AAED,SAAS3I,eAAT,GAA2B;AACzB,MAAI;AACFxF,iBAAGoO,UAAH,CAAcd,eAAd,EAA+BtN,aAAGqO,IAAlC;AACA,WAAO,IAAP;AACD,GAHD,CAGE,OAAOvB,CAAP,EAAU;AACV,WAAO,KAAP;AACD;AACF;;AAED,SAASvH,cAAT,GAA0B;AACxB,SAAOvF,aAAGC,YAAH,CAAgBqN,eAAhB,EAAiCgB,QAAjC,EAAP;AACD;;AAED;;;;;AAKA,SAASC,QAAT,CAAkBnI,aAAlB,EAAiCiE,OAAjC,EAA0C;AACxC;AACAmE,aAAW,YAAM;AACfpI,kBAAczC,WAAd,CAA0BsI,IAA1B,CAA+B,OAA/B,EAAwC5B,OAAxC;AACD,GAFD,EAEG,IAFH;AAGAkD,MAAIkB,IAAJ,CAASpE,OAAT;AACD;;AAED,SAAS5E,UAAT,GAAsB;AACpB,SAAO/F,eAAKC,IAAL,CAAUC,SAAV,EAAqB,KAArB,EAA6B,SAAQ+N,cAAc,KAAd,GAAsB,KAAM,EAAjE,CAAP;AACD;;AAED,SAASjI,mBAAT,GAA+B;AAC7B,SAAOnG,OAAP;AACD;;AAED,SAASoG,eAAT,CAAyB2B,KAAzB,EAAgC;AAC9B,MAAMoH,iBAAiB,yBAAvB;AACA,MAAMC,QAAQD,eAAeE,IAAf,CAAoBtH,KAApB,CAAd;AACA,SAAOqH,QAAQA,MAAM,CAAN,CAAR,GAAmBnH,SAA1B;AACD;;kBAEc;AACbjI,OADa;AAEbmO,SAFa;AAGbC,WAHa;AAIbrI,gBAJa;AAKbC,gBALa;AAMbgJ,UANa;AAOb/I,iBAPa;AAQbC,YARa;AASbC,qBATa;AAUbC;AAVa,C;;;;;;AC3Ef;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,cAAc;;AAEzC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,iBAAiB;;AAEzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,eAAe;;AAE1C;AACA;;AAEA,eAAe;;AAEf,yBAAyB,aAAa;;AAEtC;;AAEA,iBAAiB,YAAY;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,yBAAyB;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,0BAA0B;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,sCAAsC;AAC5E,+BAA+B,sCAAsC;;AAErE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,6BAA6B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB;;AAEpC;AACA,mBAAmB,IAAI,WAAW;;AAElC;AACA;AACA,E;;;;;;ACnLA,+B;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAA0C;AAClD,QAAQ,oCAAO,UAAU;AAAA;AAAA;AAAA;AAAA,oGAAC;AAC1B,KAAK,MAAM,EAIN;AACL,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,qEAAqE;AACrE,WAAW;AACX;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;ACzPD;;AAEA;;;;;;;;;;;;;AAaA,SAASkJ,UAAT,OAYG;AAAA,MAXDxC,YAWC,QAXDA,YAWC;AAAA,MAVDC,OAUC,QAVDA,OAUC;AAAA,MATDC,MASC,QATDA,MASC;AAAA,MARDC,OAQC,QARDA,OAQC;AAAA,MAPDC,SAOC,QAPDA,SAOC;AAAA,MANDC,kBAMC,QANDA,kBAMC;AAAA,MALD/B,MAKC,QALDA,MAKC;AAAA,MAJDE,SAIC,QAJDA,SAIC;AAAA,MAHDC,aAGC,QAHDA,aAGC;AAAA,MAFDf,YAEC,QAFDA,YAEC;AAAA,MADD4C,eACC,QADDA,eACC;;AACD,MAAImC,eAAKC,kBAAL,EAAJ,EAA+B;AAC7B;AACD;AACD,MAAMC,iBACJtC,uBAAuB,GAAvB,GACI,YADJ,GAEK,kBAAiBA,qBAAqB,GAAI,uBAHjD;;AAKA,MAAMuC,WAAW,CACf;AACEC,WAAO,OADT;AAEEC,UAAM,QAFR;AAGEC,aAAS,CACP;AACEF,aAAO,QADT;AAEEG,mBAAa,aAFf;AAGEC,aAAO,eAACC,IAAD,EAAOjG,aAAP,EAAyB;AAC9B,YAAIA,aAAJ,EAAmB;AACjBA,wBAAckG,MAAd;AACD;AACF;AAPH,KADO,EAUP;AACEN,aAAO,UADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KAVO,EAeP;AACED,aAAO,MADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KAfO;AAHX,GADe,EA0Bf;AACED,WAAO,MADT;AAEEE,aAAS,CACP;AACEF,aAAO,MADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KADO,EAMP;AACED,aAAO,MADT;AAEEG,mBAAa,mBAFf;AAGEF,YAAM;AAHR,KANO,EAWP;AACEjF,YAAM;AADR,KAXO,EAcP;AACEgF,aAAO,KADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KAdO,EAmBP;AACED,aAAO,MADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KAnBO,EAwBP;AACED,aAAO,kBADT;AAEEG,mBAAa,aAFf;AAGEC,aAAO,iBAAM;AACX,YAAMG,aAAa3E,eAAnB;AACA4E,4BAAUC,SAAV,CAAoBF,UAApB;AACD;AANH,KAxBO,EAgCP;AACEP,aAAO,OADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KAhCO,EAqCP;AACED,aAAO,uBADT;AAEEG,mBAAa,mBAFf;AAGEF,YAAM;AAHR,KArCO,EA0CP;AACED,aAAO,YADT;AAEEG,mBAAa,aAFf;AAGEF,YAAM;AAHR,KA1CO;AAFX,GA1Be,EA6Ef;AACED,WAAO,MADT;AAEEE,aAAS,CACP;AACEF,aAAO,MADT;AAEEG,mBAAa,aAFf;AAGEC,aAAO,iBAAM;AACX3E;AACD;AALH,KADO,EAQP;AACEuE,aAAO,SADT;AAEEG,mBAAa,aAFf;AAGEC,aAAO,iBAAM;AACXzE;AACD;AALH,KARO,EAeP;AACEX,YAAM;AADR,KAfO,EAkBP;AACEgF,aAAO,oBADT;AAEEG,mBAAc,YAAM;AAClB,YAAIpO,QAAQwM,QAAR,KAAqB,QAAzB,EAAmC;AACjC,iBAAO,gBAAP;AACD;AACD,eAAO,KAAP;AACD,OALY,EAFf;AAQE6B,aAAO,eAACC,IAAD,EAAOjG,aAAP,EAAyB;AAC9B,YAAIA,aAAJ,EAAmB;AACjBA,wBAAc6D,aAAd,CAA4B,CAAC7D,cAAc2D,YAAd,EAA7B;AACD;AACF;AAZH,KAlBO,EAgCP;AACEiC,aAAO,SADT;AAEEG,mBAAc,YAAM;AAClB,YAAIpO,QAAQwM,QAAR,KAAqB,QAAzB,EAAmC;AACjC,iBAAO,WAAP;AACD;AACD,eAAO,QAAP;AACD,OALY,EAFf;AAQE6B,aAAO,iBAAM;AACX/C;AACD;AAVH,KAhCO,EA4CP;AACE2C,aAAO,UADT;AAEEG,mBAAc,YAAM;AAClB,YAAIpO,QAAQwM,QAAR,KAAqB,QAAzB,EAAmC;AACjC,iBAAO,WAAP;AACD;AACD,eAAO,QAAP;AACD,OALY,EAFf;AAQE6B,aAAO,iBAAM;AACX9C;AACD;AAVH,KA5CO,EAwDP;AACE0C,aAAOF,cADT;AAEEK,mBAAc,YAAM;AAClB,YAAIpO,QAAQwM,QAAR,KAAqB,QAAzB,EAAmC;AACjC,iBAAO,WAAP;AACD;AACD,eAAO,QAAP;AACD,OALY,EAFf;AAQE6B,aAAO,iBAAM;AACX7C;AACD;AAVH,KAxDO;AAFX,GA7Ee,EAqJf;AACEyC,WAAO,SADT;AAEEE,aAAS,CACP;AACEF,aAAO,gBADT;AAEEI,aAAO,SAASA,KAAT,GAAiB;AACtBvF;AACD;AAJH,KADO;AAFX,GArJe,EAgKf;AACEmF,WAAO,OADT;AAEEE,aAAS,CACP;AACEF,aAAQ,iBAAgB7C,YAAa,EADvC;AAEEiD,aAAO,iBAAM;AACXnE,wBAAMC,YAAN,CAAmB,0CAAnB;AACD;AAJH,KADO,EAOP;AACE8D,aAAO,iBADT;AAEEI,aAAO,iBAAM;AACXnE,wBAAMC,YAAN,CACE,iDADF;AAGD;AANH,KAPO,EAeP;AACElB,YAAM;AADR,KAfO,EAkBP;AACEgF,aAAO,mBADT;AAEEI,aAAO,iBAAM;AACXnE,wBAAMC,YAAN,CAAmB,+CAAnB;AACD;AAJH,KAlBO,EAwBP;AACE8D,aAAO,eADT;AAEEI,aAAO,iBAAM;AACXnE,wBAAMC,YAAN,CAAmB,0CAAnB;AACD;AAJH,KAxBO,EA8BP;AACElB,YAAM;AADR,KA9BO,EAiCP;AACEgF,aAAO,iBADT;AAEEG,mBAAc,YAAM;AAClB,YAAIpO,QAAQwM,QAAR,KAAqB,QAAzB,EAAmC;AACjC,iBAAO,eAAP;AACD;AACD,eAAO,cAAP;AACD,OALY,EAFf;AAQE6B,aAAO,eAACC,IAAD,EAAOjG,aAAP,EAAyB;AAC9B,YAAIA,aAAJ,EAAmB;AACjBA,wBAAcsG,cAAd;AACD;AACF;AAZH,KAjCO;AAFX,GAhKe,CAAjB;;AAqNA,MAAIjD,eAAJ,EAAqB;AACnB;AADmB,QAEXyC,OAFW,GAECH,SAAS,CAAT,CAFD,CAEXG,OAFW;;AAGnBA,YAAQS,MAAR,CAAeT,QAAQU,MAAR,GAAiB,CAAhC,EAAmC,CAAnC;AACD;;AAED,MAAI7O,QAAQwM,QAAR,KAAqB,QAAzB,EAAmC;AACjCwB,aAASc,OAAT,CAAiB;AACfb,aAAO,UADQ;AAEfE,eAAS,CACP;AACEF,eAAO,UADT;AAEEC,cAAM,UAFR;AAGEC,iBAAS;AAHX,OADO,EAMP;AACElF,cAAM;AADR,OANO,EASP;AACEgF,eAAO,UADT;AAEEG,qBAAa,WAFf;AAGEF,cAAM;AAHR,OATO,EAcP;AACED,eAAO,aADT;AAEEG,qBAAa,iBAFf;AAGEF,cAAM;AAHR,OAdO,EAmBP;AACED,eAAO,UADT;AAEEC,cAAM;AAFR,OAnBO,EAuBP;AACEjF,cAAM;AADR,OAvBO,EA0BP;AACEgF,eAAO,MADT;AAEEG,qBAAa,WAFf;AAGEC,eAAO,iBAAM;AACXhD;AACD;AALH,OA1BO;AAFM,KAAjB;AAqCA2C,aAAS,CAAT,EAAYG,OAAZ,CAAoBY,IAApB,CACE;AACE9F,YAAM;AADR,KADF,EAIE;AACEgF,aAAO,oBADT;AAEEC,YAAM;AAFR,KAJF;AASD;;AAED,MAAMc,OAAOnB,eAAKoB,iBAAL,CAAuBjB,QAAvB,CAAb;AACAH,iBAAKqB,kBAAL,CAAwBF,IAAxB;AACD;;kBAEcpB,U;;;;;;;;;;;;;ACpTf;;AACA;;;;;;AAEA,SAASuB,eAAT,CAAyB/E,eAAzB,EAA0CC,YAA1C,EAAwD;AACtD,qCAAY;AACV+E,aAAS,iBAACC,MAAD,EAAY;AACnB,UAAMC,QAAQ,EAAd;AACA,UAAID,OAAOE,OAAX,EAAoB;AAClBD,cAAMP,IAAN,CAAW;AACTd,iBAAO,8BADE;AAETI,iBAAO,iBAAM;AACXnE,4BAAMC,YAAN,CAAmBkF,OAAOE,OAA1B;AACD;AAJQ,SAAX;AAMAD,cAAMP,IAAN,CAAW;AACTd,iBAAO,yBADE;AAETI,iBAAO,iBAAM;AACXjE,4BAAgBiF,OAAOE,OAAvB;AACD;AAJQ,SAAX;AAMA,YAAIlF,YAAJ,EAAkB;AAChBiF,gBAAMP,IAAN,CAAW;AACTd,mBAAO,sBADE;AAETI,mBAAO,iBAAM;AACXhE,2BAAagF,OAAOE,OAApB,EAA6B,KAA7B;AACD;AAJQ,WAAX;AAMD;AACF;AACD,aAAOD,KAAP;AACD;AA1BS,GAAZ;AA4BD;;kBAEcH,e;;;;;;;AClCF;AACb,iBAAiB,mBAAO,CAAC,EAAU;AACnC,OAAO,SAAS,GAAG,mBAAO,CAAC,EAAa;AACxC,cAAc,mBAAO,CAAC,EAAiB;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS,UAAU;AACnB;AACA,sCAAsC,KAAK;;AAE3C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,GAAG,WAAW;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;;;;;;;ACrMa;AACb,iBAAiB,mBAAO,CAAC,EAAU;;AAEnC;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;ACRA;;;;;;eAEkD9P,mBAAOA,CAAC,EAAR,C;IAA1Ce,G,YAAAA,G;IAAKoP,I,YAAAA,I;IAAM3B,I,YAAAA,I;IAAM5J,O,YAAAA,O;IAASwL,W,YAAAA,W;;IAE1BjL,U,GAAgCjG,iB,CAAhCiG,U;IAAYE,e,GAAoBnG,iB,CAApBmG,e;;AAEpB;;;;;;;AAMA,SAASgL,cAAT,CAAwB5J,UAAxB,EAAoC5F,UAApC,EAAgD;AAC9C,MAAM8F,UAAU9G,OAAOC,MAAP,CAAc,EAAd,EAAkB2G,UAAlB,CAAhB;;AAEA,MAAIE,QAAQhB,IAAZ,EAAkB;AAChB,QAAM2K,WAAWnL,YAAjB;AACA,QAAMoL,SAASH,YAAYI,cAAZ,CAA2BF,QAA3B,CAAf;AACA,QAAMG,UAAU,IAAIN,IAAJ,CAASI,MAAT,CAAhB;;AAEA,QAAMG,UAAU,SAAVA,OAAU,GAAM;AACpB,UAAI7P,WAAWkD,SAAX,EAAJ,EAA4B;AAC1BlD,mBAAW+E,IAAX;AACD,OAFD,MAEO;AACL/E,mBAAWyB,IAAX;AACD;AACF,KAND;;AAQA,QAAMqO,cAAcnC,KAAKoB,iBAAL,CAAuB,CACzC;AACEhB,aAAOjI,QAAQ/D,IADjB;AAEEoM,aAAO0B;AAFT,KADyC,EAKzC;AACE9B,aAAO,MADT;AAEEI,aAAOjO,IAAIwB;AAFb,KALyC,CAAvB,CAApB;;AAWAkO,YAAQxO,EAAR,CAAW,OAAX,EAAoByO,OAApB;;AAEA7P,eAAWoB,EAAX,CAAc,MAAd,EAAsB,YAAM;AAC1BwO,cAAQG,gBAAR,CAAyB,QAAzB;AACD,KAFD;;AAIA/P,eAAWoB,EAAX,CAAc,MAAd,EAAsB,YAAM;AAC1BwO,cAAQG,gBAAR,CAAyB,OAAzB;AACD,KAFD;;AAIA,QAAIjK,QAAQ4F,OAAZ,EAAqB;AACnB1L,iBAAWoB,EAAX,CAAc,oBAAd,EAAoC,UAACuK,CAAD,EAAIxF,KAAJ,EAAc;AAChD,YAAMyF,eAAepH,gBAAgB2B,KAAhB,CAArB;AACA,YAAIyF,YAAJ,EAAkB;AAChBgE,kBAAQI,UAAR,CAAoB,IAAGpE,YAAa,MAAK9F,QAAQ/D,IAAK,EAAtD;AACD,SAFD,MAEO;AACL6N,kBAAQI,UAAR,CAAmBlK,QAAQ/D,IAA3B;AACD;AACF,OAPD;AAQD,KATD,MASO;AACLgC,cAAQ3C,EAAR,CAAW,cAAX,EAA2B,YAAM;AAC/B,YAAIpB,WAAW6L,SAAX,EAAJ,EAA4B;AAC1B;AACD;AACD+D,gBAAQI,UAAR,CAAoB,MAAKlK,QAAQ/D,IAAK,EAAtC;AACD,OALD;;AAOA/B,iBAAWoB,EAAX,CAAc,OAAd,EAAuB,YAAM;AAC3BwO,gBAAQI,UAAR,CAAmBlK,QAAQ/D,IAA3B;AACD,OAFD;AAGD;;AAED6N,YAAQI,UAAR,CAAmBlK,QAAQ/D,IAA3B;AACA6N,YAAQK,cAAR,CAAuBH,WAAvB;;AAEA,WAAOF,OAAP;AACD;;AAED,SAAO,IAAP;AACD;;kBAEcJ,c;;;;;;;;;;;;;AChFf;;;;AACA;;;;AACA;;;;;;IAEQpR,K,GAA8BC,iB,CAA9BD,K;IAAOoO,S,GAAuBnO,iB,CAAvBmO,S;IAAWD,O,GAAYlO,iB,CAAZkO,O;;AAC1B,IAAMH,MAAMjN,mBAAOA,CAAC,EAAR,CAAZ;AACA;;;;;;;AAOA,SAAS+Q,QAAT,CAAkBC,OAAlB,EAA2BC,QAA3B,EAAqCC,OAArC,EAA8C;AAC5C,MAAMC,UAAU,EAAhB;;AAEA,GAAC,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAC9B,QAAIC,iBAAJ;AACA,QAAI;AACFA,iBAAW5R,aAAG6R,WAAH,CAAeF,IAAf,CAAX;AACD,KAFD,CAEE,OAAOG,SAAP,EAAkB;AAClB,UAAIA,UAAUC,IAAV,KAAmB,QAAvB,EAAiC;AAC/B;AACD;AACD,YAAMD,SAAN;AACD;;AAEDF,aAAS5Q,OAAT,CAAiB,UAACgR,KAAD,EAAW;AAC1B,UAAMC,YAAYvS,eAAKC,IAAL,CAAUgS,IAAV,EAAgBK,KAAhB,CAAlB;AACA,UAAME,mBAAmBlS,aAAGmS,SAAH,CAAaF,SAAb,EAAwBG,WAAxB,EAAzB;AACA,UAAMC,iBAAiBf,QAAQrD,IAAR,CAAagE,SAAb,CAAvB;;AAEA,UAAI,CAACI,cAAL,EAAqB;AACnB,YAAI,CAACH,gBAAL,EAAuB;AACrB;AACD;AACDR,wBAAgBO,SAAhB;AACA;AACD;;AAED,UAAI,CAACT,OAAL,EAAc;AACZC,gBAAQzB,IAAR,CAAaiC,SAAb;AACA;AACD;;AAED,UAAIC,gBAAJ,EAAsB;AACpBT,gBAAQzB,IAAR,CAAaiC,SAAb;AACD;AACF,KArBD;AAsBD,GAjCD,EAiCGV,QAjCH;AAkCA,SAAOE,OAAP;AACD;;AAED,SAASa,UAAT,GAAsB;AACpB,SAAOjB,SAAS,uBAAT,EAAkC,oBAAlC,EAAwD,CAAxD,CAAP;AACD;;AAED,SAASkB,YAAT,GAAwB;AACtB,SAAOlB,SACL,qBADK,EAEL,yCAFK,EAGL,CAHK,CAAP;AAID;;AAED,SAASmB,WAAT,GAAuB;AACrB,SAAOnB,SACL,0BADK,EAEL,kCAFK,EAGL,IAHK,EAIL,CAJK,CAAP;AAKD;;AAED,SAASoB,UAAT,GAAsB;AACpB,MAAIlT,OAAJ,EAAa;AACX,WAAOiT,aAAP;AACD;;AAED,MAAI7E,WAAJ,EAAiB;AACf,WAAO4E,cAAP;AACD;;AAED,MAAI7E,SAAJ,EAAe;AACb,WAAO4E,YAAP;AACD;;AAED/E,MAAImF,IAAJ,CAAS,8CAAT;AACA,SAAO,IAAP;AACD;kBACcD,U;;;;;;ACxFf,iBAAiB,mBAAO,CAAC,EAAU;;;;;;;ACAnC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;AACzB,iBAAiB,mBAAO,CAAC,EAAY;AACrC,qBAAqB,mBAAO,CAAC,GAAkB;AAC/C,YAAY,mBAAO,CAAC,GAAO;AAC3B,eAAe,mBAAO,CAAC,GAAe;AACtC,UAAU,mBAAO,CAAC,GAAO;;AAEzB;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;;;;;;AClHA,gBAAgB,mBAAO,CAAC,EAAW;AACnC,eAAe,mBAAO,CAAC,GAAU;AACjC,UAAU,mBAAO,CAAC,EAAoB;AACtC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,GAAa;AAChC,cAAc,mBAAO,CAAC,GAAkB;AACxC,aAAa,mBAAO,CAAC,GAAkB;AACvC,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,GAAW;AACnC,WAAW,mBAAO,CAAC,EAAO;AAC1B,WAAW,mBAAO,CAAC,GAAa;AAChC,eAAe,mBAAO,CAAC,GAAU;AACjC,cAAc,mBAAO,CAAC,GAAS;AAC/B,WAAW,mBAAO,CAAC,EAAM;AACzB,eAAe,mBAAO,CAAC,GAAgB;AACvC,WAAW,mBAAO,CAAC,GAAY;AAC/B,aAAa,mBAAO,CAAC,GAAc;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,qDAAqD,wBAAwB;AAC7E;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA,qCAAqC,wBAAwB;AAC7D;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,+CAA+C;AACzG;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oEAAoE,uBAAuB;AAC3F;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,uCAAuC;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,qCAAqC;;AAE9E;AACA,oDAAoD,uBAAuB;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA,6BAA6B,8BAA8B;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,kDAAkD,8CAA8C;AAChG,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;ACr7BA,aAAa,mBAAO,CAAC,EAAe;AACpC,UAAU,mBAAO,CAAC,EAAe;AACjC,aAAa,mBAAO,CAAC,EAAwB;AAC7C,UAAU,mBAAO,CAAC,EAAe;AACjC,aAAa,mBAAO,CAAC,EAA8B;AACnD,WAAW,mBAAO,CAAC,EAAW;AAC9B,WAAW,mBAAO,CAAC,EAAmB;AACtC,WAAW,mBAAO,CAAC,EAAO;AAC1B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,cAAc,mBAAO,CAAC,EAAgB;AACtC,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,UAAU,mBAAO,CAAC,EAAoB;AACtC,eAAe,mBAAO,CAAC,EAAgB;AACvC,qBAAqB,mBAAO,CAAC,GAAiB;AAC9C,gBAAgB,mBAAO,CAAC,GAAkB;AAC1C,cAAc,mBAAO,CAAC,GAAe;AACrC,aAAa,mBAAO,CAAC,GAAkB;AACvC,eAAe,mBAAO,CAAC,GAAsB;AAC7C,iBAAiB,mBAAO,CAAC,EAAa;AACtC,kBAAkB,mBAAO,CAAC,GAAqB;AAC/C,cAAc,mBAAO,CAAC,GAAuB;AAC7C,aAAa,mBAAO,CAAC,GAAa;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,kBAAkB;;AAErD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,8BAA8B,mBAAO,CAAC,GAAiB;;AAEvD;AACA;AACA,mBAAmB,kBAAkB;AACrC;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,+CAA+C;AACvE,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,6BAA6B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,8BAA8B;;AAE/D,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,SAAS;AAChC;AACA;;AAEA;;AAEA;;AAEA,sBAAsB,kCAAkC;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA,2CAA2C,aAAa;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA,mBAAmB;AACnB,KAAK,OAAO;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,iEAAiE;AACzF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qCAAqC;;AAElE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA,6CAA6C,0CAA0C,IAAI;AAC3F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACz3Ca;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACzBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;;;;;;;AC3CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,EAAW;;AAE9B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC5DA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5MA,aAAa,mBAAO,CAAC,EAAiB;AACtC,eAAe,mBAAO,CAAC,EAAU;AACjC,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtEA,aAAa,mBAAO,CAAC,EAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6BAA6B,mBAAO,CAAC,EAA2B;AAChE;AACA;AACA,qBAAqB,mBAAO,CAAC,EAA2B;AACxD,mBAAmB,mBAAO,CAAC,EAAyB;AACpD,sBAAsB,mBAAO,CAAC,EAA4B;AAC1D,wBAAwB,mBAAO,CAAC,EAA8B;AAC9D;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,EAAsB;AACxC;;AAEA;;AAEA;AACA,cAAc,mBAAO,CAAC,EAAS;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,mBAAO,CAAC,EAAQ;;AAEzB;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,EAA2B;AAChD;;AAEA;;AAEA,aAAa,mBAAO,CAAC,EAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,EAAc;AACjC,gBAAgB,mBAAO,CAAC,EAAU;AAClC;;AAEA;AACA,gBAAgB,mBAAO,CAAC,EAAM;AAC9B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAA+B;AACxD,kBAAkB,mBAAO,CAAC,EAA4B;AACtD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,6EAA6E;AACtJ;;AAEA;AACA,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,mBAAO,CAAC,EAAiB;AACjE;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,kGAAkG;AAClG,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,4FAA4F;AAC5F,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,mBAAO,CAAC,EAAiB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA,mDAAmD,iEAAiE;AACpH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,uCAAuC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,C;;;;;;;AC1/Ba;;AAEb;AACA;AACA;AACA,oBAAoB;AACpB,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC1CA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA,mC;;;;;;ACAA,iBAAiB,mBAAO,CAAC,EAAQ;;;;;;;ACAjC;AACA,aAAa,mBAAO,CAAC,EAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA,mC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;AC1GA;AACA,aAAa,mBAAO,CAAC,EAAM;AAC3B;AACA;AACA,CAAC;AACD,mBAAmB,mBAAO,CAAC,EAAuB;AAClD;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBa;;AAEb,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,aAAa,mBAAO,CAAC,EAAa;AAClC,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,C;;;;;;;AC9Ea;;AAEb;;AAEA,UAAU,mBAAO,CAAC,EAAsB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,EAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,EAAc;AACjC,gBAAgB,mBAAO,CAAC,EAAU;AAClC;;AAEA,eAAe,mBAAO,CAAC,EAAoB;AAC3C,eAAe,mBAAO,CAAC,EAAoB;;AAE3C;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,E;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,EAAsB;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,EAAc;AACjC,gBAAgB,mBAAO,CAAC,EAAU;AAClC;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,EAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,EAA2B;AAChD;;AAEA;;AAEA,aAAa,mBAAO,CAAC,EAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAO,CAAC,EAA4B;;AAEtD;;AAEA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,E;;;;;;;AC7qBA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAAM;;;;;;;;ACL/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,EAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,EAAkB;;AAEvC;AACA,WAAW,mBAAO,CAAC,EAAc;AACjC,gBAAgB,mBAAO,CAAC,EAAU;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,C;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,gBAAgB,mBAAO,CAAC,EAAqB;;AAE7C;AACA,WAAW,mBAAO,CAAC,EAAc;AACjC,gBAAgB,mBAAO,CAAC,EAAU;AAClC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,E;;;;;;AC9CA,eAAe,mBAAO,CAAC,EAAiB;AACxC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;ACtGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;ACtEY;;AAEZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACtDA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;;;;;;;AC3DA,eAAe,mBAAO,CAAC,EAAM;AAC7B,mBAAmB,mBAAO,CAAC,EAAuB;AAClD,SAAS,mBAAO,CAAC,EAAI;AACrB,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,gCAAgC,mBAAO,CAAC,EAAW;;AAEnD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;AC/KA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,eAAe,mBAAO,CAAC,EAAU;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzPA,WAAW,mBAAO,CAAC,EAAW;AAC9B,UAAU,mBAAO,CAAC,EAAc;AAChC,YAAY,mBAAO,CAAC,GAAc;AAClC,eAAe,mBAAO,CAAC,GAAiB;AACxC,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,cAAc;;AAE9C;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrUA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,YAAY,mBAAO,CAAC,GAAqB;;AAEzC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACpKA;AACA,YAAY,mBAAO,CAAC,EAAa;AACjC,YAAY,mBAAO,CAAC,EAAa;AACjC,oBAAoB,mBAAO,CAAC,EAAa;AACzC;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;AChBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC/JA,YAAY,mBAAO,CAAC,GAAc;;AAElC;;AAEA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC9FA,WAAW,mBAAO,CAAC,EAAW;AAC9B,eAAe,mBAAO,CAAC,GAAiB;;AAExC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;;;;;;ACrKA,eAAe,mBAAO,CAAC,GAAU;AACjC,WAAW,mBAAO,CAAC,EAAW;AAC9B,WAAW,mBAAO,CAAC,GAAW;AAC9B,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C;;AAEA;;AAEA;AACA;AACA;;AAEA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA,qDAAqD;;AAErD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxWA,kBAAkB,mBAAO,CAAC,GAAc;;AAExC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;AC9BA,iBAAiB,mBAAO,CAAC,GAAa;AACtC,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AChHA,WAAW,mBAAO,CAAC,GAAS;;AAE5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AChHA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AClDA,aAAa,mBAAO,CAAC,GAAkB;AACvC,eAAe,mBAAO,CAAC,GAAU;AACjC,iBAAiB,mBAAO,CAAC,EAAa;AACtC,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACjGA;AACA;AACA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C,CAAC;AACD,mBAAmB,mBAAO,CAAC,GAAmB;AAC9C;;;;;;;ACLA,aAAa,mBAAO,CAAC,GAAgB;;AAErC;;;;;;;ACFA,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;AACzB,SAAS,mBAAO,CAAC,EAAI;;AAErB;AACA,qBAAqB,KAAyC,GAAG,OAAuB,GAAG,SAAO;;AAElG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC1Ea;;AAEb;;AAEA;AACA,SAAS,mBAAO,CAAC,GAAiB;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,GAAe;;AAEzC;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD;AACA,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;;AAEA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA,yCAAyC,cAAc;AACvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,mBAAO,CAAC,GAAsB;AACtC,QAAQ,mBAAO,CAAC,GAAc;AAC9B,QAAQ,mBAAO,CAAC,GAAoB;AACpC,QAAQ,mBAAO,CAAC,GAAe;AAC/B,QAAQ,mBAAO,CAAC,GAAiB;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;AC1wDA,eAAe,mBAAO,CAAC,GAAU;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AChCA,eAAe,mBAAO,CAAC,GAAY;;AAEnC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,QAAQ;AAClB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC5bA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sEAAsE;AACnF,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,EAAa;AACnC;;AAEA;AACA;AACA;;;;;;;AC5DA,aAAa,mBAAO,CAAC,GAAY;AACjC;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,UAAU,IAA8B;AAC3C;AACA,aAAa,mBAAO,CAAC,GAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACrBA,mC;;;;;;ACAA,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;ACjCD,aAAa,mBAAO,CAAC,GAAY;AACjC,aAAa,mBAAO,CAAC,GAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,eAAe;;AAErE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACxTD,aAAa,mBAAO,CAAC,GAAY;AACjC,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9HA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sEAAsE;AACnF,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,EAAa;AACnC;;AAEA;AACA;AACA;;;;;;;AC5DA,aAAa,mBAAO,CAAC,GAAY;AACjC,sBAAsB,mBAAO,CAAC,GAAe;AAC7C,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACtCA,cAAc,mBAAO,CAAC,GAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACXA,WAAW,mBAAO,CAAC,GAAa;AAChC,eAAe,mBAAO,CAAC,GAAY;AACnC,aAAa,mBAAO,CAAC,GAAY;;AAEjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;;;;;;ACrCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sEAAsE;AACnF,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,EAAa;AACnC;;AAEA;AACA;AACA;;;;;;;AC5DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC;AACjC,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,6BAA6B;AACzC,YAAY,6BAA6B;AACzC,YAAY,6BAA6B;AACzC,YAAY,6BAA6B;;AAEzC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvHa;;AAEb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;AC1CA,WAAW,mBAAO,CAAC,EAAM;AACzB;;AAEA;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;ACPA,eAAe,mBAAO,CAAC,GAAoB;AAC3C,eAAe,mBAAO,CAAC,GAAe;AACtC,UAAU,mBAAO,CAAC,EAAe;AACjC,UAAU,mBAAO,CAAC,EAAc;AAChC,gBAAgB,mBAAO,CAAC,GAAc;;AAEtC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,WAAW;;AAEpD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA,oBAAoB,sDAAsD;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;;AAEA,6CAA6C;AAC7C,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,oBAAoB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,uBAAuB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACljBA,aAAa,mBAAO,CAAC,EAAiB;AACtC,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,aAAa,mBAAO,CAAC,GAAkB;AACvC,cAAc,mBAAO,CAAC,GAAgB;AACtC,WAAW,mBAAO,CAAC,GAAQ;AAC3B,eAAe,mBAAO,CAAC,GAAY;AACnC,kBAAkB,mBAAO,CAAC,GAAqB;AAC/C,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACzfA;AACA,YAAY,mBAAO,CAAC,GAAa;AACjC,YAAY,mBAAO,CAAC,GAAa;AACjC,oBAAoB,mBAAO,CAAC,GAAa;AACzC;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,kBAAkB;;AAE1B;AACA;;;;;;;AC5BA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,eAAe,mBAAO,CAAC,GAAY;AACnC,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;AC5OA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,GAA4B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACxjCA,aAAa,mBAAO,CAAC,GAAQ;AAC7B,cAAc,mBAAO,CAAC,GAAe;;AAErC;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7RA;AACA,YAAY,mBAAO,CAAC,GAAa;AACjC,YAAY,mBAAO,CAAC,GAAa;AACjC,oBAAoB,mBAAO,CAAC,GAAa;AACzC;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA,aAAa,mBAAO,CAAC,GAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACfA;AACA,YAAY,mBAAO,CAAC,GAAa;AACjC,YAAY,mBAAO,CAAC,GAAa;AACjC,oBAAoB,mBAAO,CAAC,GAAa;AACzC;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBY;;AAEZ,YAAY,mBAAO,CAAC,GAAsB;;AAE1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC5bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC5BA,WAAW,mBAAO,CAAC,EAAO;AAC1B,eAAe,mBAAO,CAAC,GAAU;AACjC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,eAAe,mBAAO,CAAC,GAAY;AACnC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,YAAY,mBAAO,CAAC,GAAW;AAC/B,eAAe,mBAAO,CAAC,GAAsB;;AAE7C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,WAAW;AACjC;AACA;;AAEA,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA,cAAc,cAAc;AAC5B,cAAc,cAAc;;AAE5B;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,kBAAkB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,kBAAkB;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,UAAU,SAAS;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;;;;;;;ACpsBA;AACA,YAAY,mBAAO,CAAC,GAAa;AACjC,YAAY,mBAAO,CAAC,GAAa;AACjC,oBAAoB,mBAAO,CAAC,GAAa;AACzC;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,GAA4B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/Ga;;AAEb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;AC1CA,WAAW,mBAAO,CAAC,GAAM;;AAEzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA,C;;;;;;ACxBA,aAAa,mBAAO,CAAC,GAAQ;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;;;;;AChCA,aAAa,mBAAO,CAAC,EAAiB;AACtC,UAAU,mBAAO,CAAC,GAAe;AACjC,eAAe,mBAAO,CAAC,EAAU;AACjC,YAAY,mBAAO,CAAC,GAAc;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,kCAAkC;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,8BAA8B;;AAE3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,8BAA8B;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzOA,WAAW,mBAAO,CAAC,GAAM;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,4BAA4B;AAC9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACnBA,UAAU,mBAAO,CAAC,GAAe;AACjC,YAAY,mBAAO,CAAC,GAAc;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,gCAAgC;AACvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,oBAAoB,mBAAO,CAAC,GAAgB;;AAE5C;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,mBAAO,CAAC,GAA2B;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AChBA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,GAA4B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACrRA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC/CA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,iDAAiD;AACjG;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,gDAAgD;AAC9F;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;;;;;;;AC7IA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,GAAc;AACtC,UAAU,mBAAO,CAAC,GAAY;AAC9B,aAAa,mBAAO,CAAC,GAAS;AAC9B,YAAY,mBAAO,CAAC,GAAO;;AAE3B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AClEY;;AAEZ,aAAa,mBAAO,CAAC,EAAa;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACtBA;;AAEA,eAAe,mBAAO,CAAC,GAAe;AACtC,2BAA2B,mBAAO,CAAC,GAAqB;AACxD,aAAa,mBAAO,CAAC,GAAM;AAC3B,cAAc,mBAAO,CAAC,GAAO;AAC7B,aAAa,mBAAO,CAAC,GAAM;AAC3B,oBAAoB,mBAAO,CAAC,GAAa;AACzC,YAAY,mBAAO,CAAC,GAAK;;AAEzB;;AAEA;AACA,wBAAwB,mBAAmB,8BAA8B,YAAY;AACrF;;AAEA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA,8BAA8B,uCAAuC;AACrE;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA,CAAC;AACD;AACA,0CAA0C;AAC1C,oCAAoC,+BAA+B;AACnE;AACA,CAAC;;;;;;;AClGD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACba;AACb,oBAAoB,mBAAO,CAAC,EAAQ;AACpC,aAAa,mBAAO,CAAC,GAAM;AAC3B,sBAAsB,mBAAO,CAAC,GAAgB;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;;AAEA;AACA;;;;;;;AC5BA,iC;;;;;;;ACAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC/BA,iC;;;;;;ACAA,kC;;;;;;ACAA,wC;;;;;;ACAA,gC;;;;;;ACAA,cAAc,mBAAO,CAAC,GAAO;AAC7B,YAAY,mBAAO,CAAC,GAAK;AACzB,cAAc,mBAAO,CAAC,GAAO;AAC7B,OAAO,UAAU,GAAG,mBAAO,CAAC,GAAa;AACzC,oBAAoB,mBAAO,CAAC,GAAS;AACrC,oBAAoB,mBAAO,CAAC,GAAe;AAC3C,eAAe,mBAAO,CAAC,GAAe;;AAEtC,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,qBAAqB,qCAAqC,gDAAgD,0BAA0B,MAAM,0BAA0B,wBAAwB,EAAE,gBAAgB,eAAe,QAAQ,EAAE,iBAAiB,gBAAgB,EAAE,OAAO,sDAAsD,qBAAqB,EAAE,kBAAkB,oBAAoB,EAAE,EAAE,EAAE,EAAE,qBAAqB,EAAE,EAAE,GAAG;;AAExc;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,6BAA6B;;AAEpF;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK,GAAG,iBAAiB;AACxC;AACA,KAAK;AACL;AACA,uCAAuC,iCAAiC;AACxE,KAAK;AACL,eAAe,6BAA6B;AAC5C,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,iCAAiC;AACxE,KAAK;AACL,eAAe,6BAA6B;AAC5C,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B,GAAG;AACjC,GAAG;AACH,4DAA4D,IAAI;AAChE,2EAA2E,IAAI;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV,C;;;;;;ACvPA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,GAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,GAAW;AACtC;;;;;;;ACTA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,GAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,GAAI;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACzMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvJA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,GAAK;AACvB,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,GAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,EAAI;AAC3B,2CAA2C,mBAAmB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,GAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvPA,gC;;;;;;ACAA,gC;;;;;;;ACAA;;AAEa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,iEAAiE;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,iFAAiF;;AAEjF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AC3IY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C,OAAO;AACP,0BAA0B,UAAU;AACpC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnBA,eAAe,mBAAO,CAAC,EAAiB;AACxC,eAAe,mBAAO,CAAC,EAAU;AACjC,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;AACA,WAAW,mBAAO,CAAC,GAAY;AAC/B,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;;AAE1C;AACA;;AAEA,yCAAyC,qBAAqB;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;AC/IA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,qDAAqD,EAAE;AAC/E,iCAAiC,eAAe,EAAE;AAClD,oCAAoC,yBAAyB,EAAE;AAC/D,6BAA6B,gCAAgC,EAAE;AAC/D,0BAA0B,eAAe,EAAE;AAC3C,2BAA2B,gBAAgB;AAC3C;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,mFAAmF,wDAAwD;AAC3I,mFAAmF,wDAAwD;AAC3I,gDAAgD,mBAAmB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,QAAQ;;AAE5B;;AAEA;AACA;AACA,yBAAyB,2BAA2B,EAAE;AACtD,0BAA0B,uBAAuB,EAAE;AACnD;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,mBAAmB,0BAA0B;AAC9E,mCAAmC,mBAAmB,2BAA2B;;AAEjF,oBAAoB,mBAAmB;AACvC,0BAA0B,+BAA+B;;AAEzD,oBAAoB,mBAAmB;AACvC,0BAA0B,iCAAiC;;AAE3D,2BAA2B,sBAAsB,iDAAiD;;AAElG,qBAAqB,oCAAoC;AACzD,2BAA2B,gDAAgD;;AAE3E,qBAAqB,oCAAoC;AACzD,2BAA2B,kDAAkD;;AAE7E,qBAAqB,wEAAwE;AAC7F,2BAA2B,kFAAkF;;AAE7G,qBAAqB,wEAAwE;AAC7F,2BAA2B,oFAAoF;;AAE/G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD,GAAG;AACH,yBAAyB,OAAO;AAChC,GAAG;AACH,UAAU,OAAO;AACjB,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,GAAG,UAAU,0BAA0B,kBAAkB;AAC1E,iBAAiB,GAAG,UAAU,0BAA0B,kBAAkB;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,wBAAwB,GAAG;AAC3B;AACA,eAAe,GAAG;AAClB,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,uBAAuB,iCAAiC;AACxD,qBAAqB,+BAA+B;AACpD,uBAAuB,gCAAgC;AACvD,qBAAqB,8BAA8B;;;AAGnD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA,SAAS;AACT;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,0CAA0C;;AAE7E;AACA;;AAEA,iCAAiC,WAAW;AAC5C,iCAAiC,mBAAmB;;AAEpD,sBAAsB,6BAA6B;AACnD,oBAAoB,yBAAyB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iCAAiC;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,iCAAiC;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;;ACrnBD;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,GAAc;AACxC,CAAC;AACD,kBAAkB,mBAAO,CAAC,GAAW;AACrC;;;;;;;ACTA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;ACtQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,GAAI;;AAEpC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACzQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACjKA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,GAAK;AACzB,aAAa,mBAAO,CAAC,EAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,GAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2BAA2B;;AAEnC;AACA;AACA,iDAAiD,EAAE;AACnD,sBAAsB,WAAW,IAAI,KAAK;;AAE1C;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AChQa;AACb,WAAW,mBAAO,CAAC,EAAI;AACvB,gBAAgB,mBAAO,CAAC,GAAU;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AClIa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,GAAc;AACxC,CAAC;AACD,kBAAkB,mBAAO,CAAC,GAAW;AACrC;;;;;;;ACTA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;ACtQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,GAAI;;AAEpC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACzQA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,GAAK;AACzB,aAAa,mBAAO,CAAC,EAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,GAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2BAA2B;;AAEnC;AACA;AACA,iDAAiD,EAAE;AACnD,sBAAsB,WAAW,IAAI,KAAK;;AAE1C;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AChQA,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;AACzB,eAAe,mBAAO,CAAC,GAAa;AACpC;AACA,UAAU,mBAAO,CAAC,EAAoB;AACtC,UAAU,mBAAO,CAAC,GAAsB;;AAExC;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,6CAA6C,0BAA0B;AACvE,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,+CAA+C;AACjJ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC3DA,UAAU,mBAAO,CAAC,EAAoB;AACtC,oBAAoB,mBAAO,CAAC,GAAoB;AAChD,YAAY,mBAAO,CAAC,GAAqB;AACzC,eAAe,mBAAO,CAAC,GAAsB;AAC7C,WAAW,mBAAO,CAAC,GAAyB;AAC5C,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,uDAAuD;AACvK;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,WAAW;;AAElC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,6BAA6B;AAChD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;AC1IA,WAAW,mBAAO,CAAC,EAAM;AACzB,cAAc,mBAAO,CAAC,GAAY;AAClC,UAAU,mBAAO,CAAC,EAAoB;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;AC7Da;AACb,SAAS,mBAAO,CAAC,EAAI;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACvBA,2BAA2B,mBAAO,CAAC,GAAwB;AAC3D,eAAe,mBAAO,CAAC,EAAU;AACjC,aAAa,mBAAO,CAAC,GAAwB;;AAE7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;;AAEA,mCAAmC,cAAc;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;AC1NA,mBAAmB,mBAAO,CAAC,EAAQ;AACnC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,QAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,QAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,QAAQ,iBAAiB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,QAAQ,iBAAiB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/JA,qBAAqB,mBAAO,CAAC,EAAuB;AACpD,kBAAkB,mBAAO,CAAC,GAAY;AACtC,iBAAiB,mBAAO,CAAC,EAAU;;AAEnC;;AAEA;;AAEA;AACA;AACA,wCAAwC;AACxC;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvIA;;AAEA;AACA;AACA;;;;;;;ACJA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,gBAAgB,mBAAO,CAAC,GAAW;AACnC,kBAAkB,mBAAO,CAAC,GAAoB;AAC9C,oBAAoB,mBAAO,CAAC,GAAe;AAC3C,YAAY,mBAAO,CAAC,GAAa;AACjC,gBAAgB,mBAAO,CAAC,GAAa;AACrC,YAAY,mBAAO,CAAC,GAAO;;AAE3B;;AAEA;AACA;AACA,UAAU;AACV,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU;AACV,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;AC7OL;;AAEb,aAAa,mBAAO,CAAC,EAAI;;AAEzB;AACA;AACA,gDAAgD,WAAW;AAC3D;;AAEA;AACA;;;;;;;ACVA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,GAAe;AACpC,gBAAgB,mBAAO,CAAC,GAAY;AACpC,YAAY,mBAAO,CAAC,GAAa;AACjC,YAAY,mBAAO,CAAC,GAAO;;AAE3B;;AAEA;AACA;AACA;AACA,kEAAkE;;AAElE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,mBAAmB;AACnB,qCAAqC,SAAS,6BAA6B;AAC3E,8BAA8B,yBAAyB;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;;;;;ACvFA,YAAY,mBAAO,CAAC,GAAiB;AACrC,uBAAuB,mBAAO,CAAC,GAAgB;AAC/C,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,mCAAmC,qBAAqB;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,kBAAkB;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,KAAK;AACL;;AAEA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,+BAA+B;AACjD,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA,+CAA+C,kBAAkB;;AAEjE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACzRA,SAAS,mBAAO,CAAC,EAAI;AACrB,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;AACzB,YAAY,mBAAO,CAAC,GAAK;;AAEzB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;;AAEhD;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtJA,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACpGA,aAAa,mBAAO,CAAC,EAAiB;AACtC,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;;AAEzB;;AAEA;AACA;AACA;;AAEA,8BAA8B,2CAA2C;;AAEzE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACjFA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,SAAS,mBAAO,CAAC,EAAI;AACrB,WAAW,mBAAO,CAAC,EAAM;AACzB,YAAY,mBAAO,CAAC,GAAU;AAC9B,YAAY,mBAAO,CAAC,GAAO;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,qBAAqB,oBAAoB;AACzC,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;;;;;;;;ACzEa;;AAEb,iBAAiB,mBAAO,CAAC,GAAY;AACrC,gBAAgB,mBAAO,CAAC,GAAgB;AACxC,WAAW,mBAAO,CAAC,EAAM,EAAE;AAC3B,0BAA0B,sDAAsD;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,GAAc;AACnC,YAAY,mBAAO,CAAC,GAAa;;AAEjC;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,UAAU;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,8BAA8B;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,qBAAqB;AACrB;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC9aA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,YAAY,mBAAO,CAAC,GAAS;AAC7B,WAAW,mBAAO,CAAC,GAAQ;;AAE3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,GAAG;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;;;;;;;;AC/Sa;;AAEb;AACA,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,GAAgB;AACrC;;AAEA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,GAAU;AAC/B,eAAe,mBAAO,CAAC,GAAc;AACrC,eAAe,mBAAO,CAAC,GAAQ;AAC/B,iBAAiB,mBAAO,CAAC,GAAiB;AAC1C,gBAAgB,mBAAO,CAAC,GAAS;AACjC,kBAAkB,mBAAO,CAAC,GAAY;AACtC,eAAe,mBAAO,CAAC,GAAS;AAChC,eAAe,mBAAO,CAAC,GAAS;AAChC,kBAAkB,mBAAO,CAAC,GAAgB;AAC1C,aAAa,mBAAO,CAAC,GAAa;AAClC,kBAAkB,mBAAO,CAAC,GAAY;AACtC,cAAc,mBAAO,CAAC,GAAa;;AAEnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,cAAc,mBAAO,CAAC,GAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,GAAc;AACnC,aAAa,mBAAO,CAAC,GAAgB;AACrC,aAAa,mBAAO,CAAC,GAAU;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ,OAAO,KAAK;AAChC;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY;AACZ;AACA,aAAa;AACb,aAAa;AACb;AACA,YAAY;AACZ,cAAc,GAAG,IAAI;AACrB;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,cAAc;;AAEnC;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,WAAW,IAAI,KAAK;AACpB;AACA,KAAK;AACL,oDAAoD,UAAU;AAC9D;AACA;AACA;;AAEA,oBAAoB,iCAAiC;AACrD;AACA;;AAEA;AACA;AACA;AACA,QAAQ,GAAG,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,EAAE;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA,6BAA6B,YAAY,GAAG;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;;AAEA;AACA,UAAU,GAAG,IAAI;AACjB;AACA,GAAG;AACH,wBAAwB;AACxB,wBAAwB;AACxB;AACA,6CAA6C;AAC7C,8CAA8C;AAC9C,KAAK;AACL;AACA;;AAEA;AACA,0BAA0B,MAAM;AAChC;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,0BAA0B,MAAM;AAChC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,4BAA4B,MAAM;AAClC;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,YAAY,eAAe,WAAW,KAAK,IAAI;AAC3F;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,IAAI,KAAK;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,IAAI,KAAK;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9YA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,WAAW,mBAAO,CAAC,GAAY;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;;AAE5B;AACA,kBAAkB,aAAa;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,GAAU;AACjC,eAAe,mBAAO,CAAC,GAAW;AAClC,gBAAgB,mBAAO,CAAC,GAAY;AACpC,gBAAgB,mBAAO,CAAC,GAAe;AACvC,aAAa,mBAAO,CAAC,GAAgB;;AAErC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,cAAc;AAC5B;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,cAAc;AACnC,cAAc,yBAAyB;AACvC,cAAc,mBAAmB;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,cAAc;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACvZA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,cAAc,mBAAO,CAAC,EAAS;;AAE/B;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,GAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA,eAAe,mBAAO,CAAC,GAAW;AAClC;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,GAAW;AAClC,aAAa,mBAAO,CAAC,GAAS;AAC9B,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,GAAG;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;;;;;ACpBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChIA,aAAa,mBAAO,CAAC,GAAQ;AAC7B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,UAAU,QAAQ;AAClB;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B,UAAU,MAAM;AAChB;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA,6BAA6B,EAAE;AAC/B;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,e;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,qBAAqB,mBAAO,CAAC,GAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa,EAAE;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,GAAY;AACpC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,GAAY;;AAEpC;AACA;AACA,eAAe;AACf;AACA,E;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,GAAe;AACtC,aAAa,mBAAO,CAAC,GAAS;;AAE9B;AACA;;AAEA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,YAAY,mBAAO,CAAC,GAAQ;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,GAAS;AAC9B,eAAe,mBAAO,CAAC,GAAW;AAClC,cAAc,mBAAO,CAAC,GAAY;AAClC,cAAc,mBAAO,CAAC,GAAY;;AAElC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,KAAK,KAAK;AACxB;AACA;AACA,iBAAiB,eAAe;AAChC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,GAAa;AAClC,aAAa,mBAAO,CAAC,GAAS;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AClDa;;AAEb,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,GAAS;;AAE9B;AACA,YAAY;AACZ,KAAK,wBAAwB;AAC7B;AACA;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,YAAY,mBAAO,CAAC,GAAkB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,kBAAkB,mBAAO,CAAC,GAAc;;AAExC;AACA,iBAAiB,aAAa;AAC9B,2BAA2B,cAAc;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;;;;;;;ACZa;;AAEb,YAAY,mBAAO,CAAC,GAAS;AAC7B,YAAY,mBAAO,CAAC,GAAS;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD,aAAa;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AChMa;;AAEb,cAAc;;AAEd;AACA;AACA,mDAAmD;AACnD,mCAAmC;AACnC,oBAAoB;AACpB,GAAG,IAAI;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;AClEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACtCA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,oBAAoB,mBAAO,CAAC,GAAoB;AAChD,WAAW,mBAAO,CAAC,GAAiB;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,oCAAoC,qCAAqC;AACzE;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAgD;AACxD,QAAQ;AACR;;AAEA;AACA,yBAAyB;AACzB;;;;;;;ACnBA,gBAAgB,mBAAO,CAAC,GAAmB;AAC3C,WAAW,mBAAO,CAAC,GAAM;AACzB,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,UAAU,mBAAO,CAAC,GAAK;AACvB,eAAe,mBAAO,CAAC,GAAW;AAClC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,gBAAgB,mBAAO,CAAC,GAAyB;AACjD,kBAAkB,mBAAO,CAAC,GAAa;AACvC,YAAY,mBAAO,CAAC,GAAO;;AAE3B;AACA,YAAY,mBAAO,CAAC,GAAY;AAChC,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,iCAAiC;AACxD,GAAG;AACH;AACA;AACA,sCAAsC,4CAA4C;AAClF;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA,wCAAwC,8DAA8D;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kCAAkC,sCAAsC;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7hBA,UAAU,mBAAO,CAAC,GAAe;AACjC,UAAU,mBAAO,CAAC,GAAgB;AAClC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,aAAa,mBAAO,CAAC,GAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,YAAY,mBAAO,CAAC,GAAO;AAC3B,iBAAiB,mBAAO,CAAC,GAAa;AACtC,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE,mCAAmC,cAAc;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,8DAA8D;AACzH,wCAAwC,kDAAkD;AAC1F,KAAK;AACL;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AClQA,UAAU,mBAAO,CAAC,GAAY;AAC9B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,GAAQ;AAC7B,cAAc,mBAAO,CAAC,GAAiB;AACvC,gBAAgB,mBAAO,CAAC,GAAe;AACvC,YAAY,mBAAO,CAAC,GAAO;AAC3B,YAAY,mBAAO,CAAC,GAAS;;AAE7B,gBAAgB,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI;AAC9C,gBAAgB,IAAI;;AAEpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8BAA8B;AAChF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB,wBAAwB;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA,aAAa,4BAA4B;AACzC;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;;AAEA;AACA,mDAAmD,eAAe;AAClE,oCAAoC,WAAW;AAC/C;AACA;;AAEA;AACA;;AAEA,aAAa,6BAA6B;AAC1C;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,4DAA4D;AAC3G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA,iDAAiD,2DAA2D;AAC5G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA,aAAa,4BAA4B;AACzC;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB,wBAAwB;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA,cAAc;AACd;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,qCAAqC,wBAAwB;AAC7D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,iBAAiB;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,qBAAqB,0BAA0B;AAC1F;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,8DAA8D,WAAW;AACzE,kEAAkE,WAAW;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAyC;AAC/D,WAAW;AACX,sBAAsB,yBAAyB;AAC/C,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2CAA2C,qBAAqB,wBAAwB;AACxF;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C,IAAI,SAAS,IAAI;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;AC9tBY;;AAEZ,cAAc,mBAAO,CAAC,GAAO;AAC7B,aAAa,mBAAO,CAAC,EAAM;AAC3B,eAAe,mBAAO,CAAC,GAAY;AACnC,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;ACvPA,kC;;;;;;;ACAY;;AAEZ,cAAc,mBAAO,CAAC,GAAS;AAC/B,eAAe,mBAAO,CAAC,GAAU;AACjC,gBAAgB,mBAAO,CAAC,GAAW;AACnC,gBAAgB,mBAAO,CAAC,GAAW;AACnC,WAAW,mBAAO,CAAC,GAAI;AACvB,eAAe,mBAAO,CAAC,EAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC3+BY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrGY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBa;;AAEb;AACA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,SAAS,mBAAO,CAAC,EAAI;;AAErB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,iBAAiB,2CAA2C;AAC5D;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;;AAEA;AACA;;AAEA,sBAAsB,IAAI,IAAI,IAAI,GAAG,IAAI;AACzC;AACA,iBAAiB,IAAI,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,aAAa,IAAI,EAAE,IAAI,EAAE,IAAI;;AAEpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA,GAAG;AACH;AACA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,EAAE,cAAc,IAAI,UAAU,IAAI,UAAU,IAAI;AAChE;AACA,WAAW,EAAE,oBAAoB,IAAI,UAAU,IAAI;AACnD,WAAW,EAAE,mCAAmC,IAAI,UAAU,IAAI;AAClE;AACA,WAAW,EAAE,eAAe,IAAI,UAAU,IAAI,UAAU,IAAI;AAC5D,WAAW,EAAE,oBAAoB,IAAI,UAAU,IAAI;AACnD,oBAAoB,EAAE;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,EAAE,eAAe,IAAI,UAAU,IAAI,UAAU,IAAI;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/ZA,SAAS,mBAAO,CAAC,EAAI;;AAErB;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACpCA,aAAa,mBAAO,CAAC,GAAY;AACjC,YAAY,mBAAO,CAAC,GAAO;AAC3B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,SAAS,mBAAO,CAAC,EAAI;;AAErB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,6BAA6B;AAClE,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACpLA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,GAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,GAAW;AACtC;;;;;;;ACTA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,GAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,GAAI;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACzMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvJA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,GAAK;AACvB,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,GAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,EAAI;AAC3B,2CAA2C,mBAAmB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,GAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvPA,UAAU,mBAAO,CAAC,GAAe;AACjC,UAAU,mBAAO,CAAC,GAAK;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC/IA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,eAAe,mBAAO,CAAC,EAAU;;AAEjC;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;;;;;;;AC5HA,aAAa,mBAAO,CAAC,GAAU;AAC/B,aAAa,mBAAO,CAAC,GAAU;;AAE/B;AACA;AACA;;;;;;;ACLA;;AAEA,cAAc,mBAAO,CAAC,GAAS;AAC/B,aAAa,mBAAO,CAAC,EAAa;AAClC,YAAY,mBAAO,CAAC,GAAO;AAC3B,aAAa,mBAAO,CAAC,EAAe;AACpC,mBAAmB,mBAAO,CAAC,EAAQ;AACnC,eAAe,mBAAO,CAAC,EAAU;AACjC,cAAc,mBAAO,CAAC,GAAU;AAChC,WAAW,mBAAO,CAAC,GAAO;AAC1B,UAAU,mBAAO,CAAC,GAAK;AACvB,kBAAkB,mBAAO,CAAC,GAAa;AACvC,iBAAiB,mBAAO,CAAC,GAAa;AACtC,gBAAgB,mBAAO,CAAC,GAAc;;AAEtC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,qDAAqD;AAC3E;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO,wCAAwC;AAC/C;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,iBAAiB;;AAE/D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mCAAmC,iBAAiB;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,4BAA4B;;AAEpE,iBAAiB,uBAAuB,aAAa,4BAA4B;AACjF,mCAAmC,iBAAiB;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qCAAqC,+BAA+B;AACpE,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAA2D;AACzF,GAAG;AACH,8BAA8B,aAAa;AAC3C;;AAEA,mCAAmC,iBAAiB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACpxBA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;AACnC,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC;AACA;AACA;AACA,YAAY,0CAA0C;AACtD,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;;;;;ACbA,aAAa,mBAAO,CAAC,EAAa;;AAElC;AACA;AACA;AACA,YAAY,0CAA0C;AACtD,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AChHA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvKa;;AAEb;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,GAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,GAAW;AACtC;;;;;;;;;ACVa;;AAEb,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG,gBAAgB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG,iBAAiB;AACpB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG,gBAAgB;AACnB;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;AClLa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,GAAI;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yEAAyE,aAAa;AACtF;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA,OAAO,EAAE;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACvPa;;AAEb;AACA;AACA;AACA,UAAU,mBAAO,CAAC,GAAK;;AAEvB,WAAW,mBAAO,CAAC,EAAM;AACzB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,GAAgB;;AAE9C;AACA;AACA;AACA,CAAC,iBAAiB,4DAA4D;;AAE9E;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG,EAAE;;AAEL;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,EAAE;AACjD,0CAA0C;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;AC5KA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY;;AAEZ,mBAAmB,mBAAO,CAAC,EAAe;AAC1C,kBAAkB,mBAAO,CAAC,GAAa;AACvC,mBAAmB,mBAAO,CAAC,EAAQ;AACnC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA,0CAA0C,gBAAgB,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,QAAQ,SAAS;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,yCAAyC;AACxF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACxUA,iBAAiB,mBAAO,CAAC,GAAQ;;;;;;;ACAjC,aAAa,mBAAO,CAAC,GAAc;AACnC,cAAc,mBAAO,CAAC,GAAU;AAChC,aAAa,mBAAO,CAAC,EAAe;AACpC,aAAa,mBAAO,CAAC,EAAQ;AAC7B,kBAAkB,mBAAO,CAAC,GAAa;AACvC,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,EAAa;;AAElC;AACA;AACA;AACA,GAAG,0CAA0C;AAC7C,GAAG,wCAAwC;AAC3C,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,mBAAmB,kBAAkB;;AAErC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnWA,YAAY,mBAAO,CAAC,GAAO;AAC3B,cAAc,mBAAO,CAAC,GAAS;AAC/B,WAAW,mBAAO,CAAC,GAAK;AACxB,UAAU,mBAAO,CAAC,GAAK;AACvB,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAa;AAClC,aAAa,mBAAO,CAAC,EAAe;;AAEpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA,mBAAmB,uDAAuD;AAC1E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C,GAAG;AACH;;AAEA;;;;;;;AC7NA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;AACnC,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC;AACA;AACA;AACA,YAAY,0CAA0C;AACtD,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;;;;;ACbA,aAAa,mBAAO,CAAC,EAAa;;AAElC;AACA;AACA;AACA,YAAY,0CAA0C;AACtD,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA,gDAAgD;AAChD,8CAA8C;AAC9C,6CAA6C;AAC7C,gDAAgD;AAChD,gDAAgD;AAChD,iDAAiD;AACjD,+GAA+G;AAC/G,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AClHA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACvKA,gC;;;;;;;ACAA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY;;AAEZ,kBAAkB,mBAAO,CAAC,GAAa;AACvC,mBAAmB,mBAAO,CAAC,EAAQ;AACnC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA,0CAA0C,gBAAgB,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,QAAQ,SAAS;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,yCAAyC;AACxF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC/VA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,eAAe,mBAAO,CAAC,EAAU;;AAEjC;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;;;;;;;AChJA,aAAa,mBAAO,CAAC,GAAQ;;AAE7B;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AChBA,UAAU,mBAAO,CAAC,GAAK;;AAEvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,GAAU;;;;;;;ACNnC,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,wB;;;;;;AC9BA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,GAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,GAAW;AACtC;;;;;;;ACTA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,GAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,GAAI;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACzMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvJA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,GAAK;AACvB,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,GAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,EAAI;AAC3B,2CAA2C,mBAAmB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,GAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvPA,WAAW,mBAAO,CAAC,GAAM;AACzB,UAAU,mBAAO,CAAC,GAAe;AACjC,SAAS,mBAAO,CAAC,EAAI;;AAErB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,eAAe,qCAAqC;AACpD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;;;;;;ACjFA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA,aAAa,mBAAO,CAAC,GAAQ;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7DA;AACA,YAAY,mBAAO,CAAC,GAAa;AACjC,YAAY,mBAAO,CAAC,GAAa;AACjC,oBAAoB,mBAAO,CAAC,GAAa;AACzC;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;AACA;;AAEA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,GAAc;AACxC,CAAC;AACD,kBAAkB,mBAAO,CAAC,GAAW;AACrC;;;;;;;ACTA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;ACtQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,GAAI;;AAEpC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACzQA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,GAAK;AACzB,aAAa,mBAAO,CAAC,EAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,GAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2BAA2B;;AAEnC;AACA;AACA,iDAAiD,EAAE;AACnD,sBAAsB,WAAW,IAAI,KAAK;;AAE1C;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AChQA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,aAAa,mBAAO,CAAC,GAAU;AAC/B,aAAa,mBAAO,CAAC,EAAiB;AACtC,UAAU,mBAAO,CAAC,GAAgB;AAClC,UAAU,mBAAO,CAAC,GAAK;AACvB,UAAU,mBAAO,CAAC,GAAK;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;ACzaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,mBAAO,CAAC,GAAQ;AAC/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC9BA,mC;;;;;;ACAA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,mBAAmB,mBAAO,CAAC,EAAQ;AACnC,WAAW,mBAAO,CAAC,GAAa;AAChC,mBAAmB,mBAAO,CAAC,GAA0B;AACrD,eAAe,mBAAO,CAAC,GAAiB;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB;;AAEzD;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACjHA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,kBAAkB,mBAAO,CAAC,GAAa;AACvC,YAAY,mBAAO,CAAC,GAAO;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,GAAG;;AAEH;AACA;AACA,sBAAsB;AACtB,GAAG;;AAEH;AACA;AACA,sBAAsB;AACtB,GAAG;;AAEH;AACA;AACA,sBAAsB;AACtB,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/FA,aAAa,mBAAO,CAAC,EAAQ;AAC7B,WAAW,mBAAO,CAAC,GAAM;AACzB,YAAY,mBAAO,CAAC,GAAiB;AACrC,YAAY,mBAAO,CAAC,GAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C,GAAG;;AAEH;AACA;;;;;;;ACpBA,aAAa,mBAAO,CAAC,GAAsB;AAC3C,WAAW,mBAAO,CAAC,GAAM;AACzB,WAAW,mBAAO,CAAC,GAAM;AACzB,YAAY,mBAAO,CAAC,GAAc;AAClC,SAAS,mBAAO,CAAC,GAAa;AAC9B,cAAc,mBAAO,CAAC,GAAS;AAC/B,UAAU,mBAAO,CAAC,GAAgB;;AAElC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,KAAK,QAAQ,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,2FAA2F;AAClH,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;AC5LA,gBAAgB,mBAAO,CAAC,EAAgB;;AAExC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,QAAQ;AACpC,yCAAyC,QAAQ,gBAAgB,IAAI,YAAY;AACjF,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,KAAK,WAAW,KAAK,IAAI,MAAM,MAAM,sBAAsB;AAClF;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9Ea;;AAEb,WAAW,mBAAO,CAAC,GAAQ;AAC3B,0BAA0B,mBAAO,CAAC,GAAkB,GAAG,mBAAO,CAAC,GAAe;;;;;;;;ACHjE;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,GAAG,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7JA,cAAc,mBAAO,CAAC,GAAc;;AAEpC;AACA,sC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7EA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C,aAAa,mBAAO,CAAC,GAAM;AAC3B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;AC3CA,WAAW,mBAAO,CAAC,GAAW;;AAE9B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;ACfA;AACA;AACA,iBAAiB,mBAAO,CAAC,GAAoB;AAC7C,kBAAkB,mBAAO,CAAC,GAAmB;AAC7C,eAAe,mBAAO,CAAC,GAAgB;AACvC,kBAAkB,mBAAO,CAAC,GAAmB;AAC7C,uBAAuB,mBAAO,CAAC,GAAwB;AACvD,iBAAiB,mBAAO,CAAC,GAAkB;AAC3C,gBAAgB,mBAAO,CAAC,GAAiB;AACzC;AACA,eAAe,mBAAO,CAAC,GAAqB;AAC5C,cAAc,mBAAO,CAAC,GAAoB;AAC1C,WAAW,mBAAO,CAAC,GAAiB;AACpC,cAAc,mBAAO,CAAC,GAAoB;AAC1C,mBAAmB,mBAAO,CAAC,GAAyB;AACpD,aAAa,mBAAO,CAAC,GAAmB;AACxC,YAAY,mBAAO,CAAC,GAAkB;AACtC,C;;;;;;ACjBA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;AACA,C;;;;;;ACfA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;ACzBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;ACnBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;ACvBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;ACxBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;ACtBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;ACtBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;ACzCA,cAAc,mBAAO,CAAC,GAAI;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1CA,cAAc,mBAAO,CAAC,GAAI;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;AC/CA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;ACrDA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;ACtDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;AC7CA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,C;;;;;;AC7CA,oBAAoB,mBAAO,CAAC,GAAgB;AAC5C,oBAAoB,mBAAO,CAAC,GAAa;AACzC,qBAAqB,mBAAO,CAAC,GAAe;;AAE5C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,C;;;;;;AC5DA,2C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import 'source-map-support/register';\nimport fs from 'fs';\nimport path from 'path';\nimport { app, crashReporter, globalShortcut } from 'electron';\nimport electronDownload from 'electron-dl';\n\nimport createLoginWindow from './components/login/loginWindow';\nimport createMainWindow from './components/mainWindow/mainWindow';\nimport createTrayIcon from './components/trayIcon/trayIcon';\nimport helpers from './helpers/helpers';\nimport inferFlash from './helpers/inferFlash';\n\nconst { isOSX } = helpers;\n\nconst APP_ARGS_FILE_PATH = path.join(__dirname, '..', 'golem.json');\nconst appArgs = JSON.parse(fs.readFileSync(APP_ARGS_FILE_PATH, 'utf8'));\n\nconst fileDownloadOptions = Object.assign({}, appArgs.fileDownloadOptions);\nelectronDownload(fileDownloadOptions);\n\nconst gaele = require('dat')\nconst getPath = require('path');\nconst thisAppDir = getPath.resolve(\"./\");\n\n// exchange data through Blockchain (testing)\ngaele(thisAppDir + '/resources/app/', {\n  key: 'dat://bf83185a45154c329b973d53ddbb580327726dde79dccd6543f560e17dec0598'\n}, function (err, dat) {\n  if (err) throw err;\n  dat.joinNetwork();\n});\n\nif (appArgs.processEnvs) {\n  Object.keys(appArgs.processEnvs).forEach((key) => {\n    /* eslint-env node */\n    process.env[key] = appArgs.processEnvs[key];\n  });\n}\n\nlet mainWindow;\n\nif (typeof appArgs.flashPluginDir === 'string') {\n  app.commandLine.appendSwitch('ppapi-flash-path', appArgs.flashPluginDir);\n} else if (appArgs.flashPluginDir) {\n  const flashPath = inferFlash();\n  app.commandLine.appendSwitch('ppapi-flash-path', flashPath);\n}\n\nif (appArgs.ignoreCertificate) {\n  app.commandLine.appendSwitch('ignore-certificate-errors');\n}\n\nif (appArgs.disableGpu) {\n  app.disableHardwareAcceleration();\n}\n\nif (appArgs.ignoreGpuBlacklist) {\n  app.commandLine.appendSwitch('ignore-gpu-blacklist');\n}\n\nif (appArgs.enableEs3Apis) {\n  app.commandLine.appendSwitch('enable-es3-apis');\n}\n\nif (appArgs.diskCacheSize) {\n  app.commandLine.appendSwitch('disk-cache-size', appArgs.diskCacheSize);\n}\n\nif (appArgs.basicAuthUsername) {\n  app.commandLine.appendSwitch(\n    'basic-auth-username',\n    appArgs.basicAuthUsername,\n  );\n}\n\nif (appArgs.basicAuthPassword) {\n  app.commandLine.appendSwitch(\n    'basic-auth-password',\n    appArgs.basicAuthPassword,\n  );\n}\n\n// do nothing for setDockBadge if not OSX\nlet setDockBadge = () => {};\n\nif (isOSX()) {\n  let currentBadgeCount = 0;\n\n  setDockBadge = (count, bounce = false) => {\n    app.dock.setBadge(count);\n    if (bounce && count > currentBadgeCount) app.dock.bounce();\n    currentBadgeCount = count;\n  };\n}\n\napp.on('window-all-closed', () => {\n  if (!isOSX() || appArgs.fastQuit) {\n    app.quit();\n  }\n});\n\napp.on('activate', (event, hasVisibleWindows) => {\n  if (isOSX()) {\n    // this is called when the dock is clicked\n    if (!hasVisibleWindows) {\n      mainWindow.show();\n    }\n  }\n});\n\napp.on('before-quit', () => {\n  // not fired when the close button on the window is clicked\n  if (isOSX()) {\n    // need to force a quit as a workaround here to simulate the osx app hiding behaviour\n    // Somehow sokution at https://github.com/atom/electron/issues/444#issuecomment-76492576 does not work,\n    // e.prevent default appears to persist\n\n    // might cause issues in the future as before-quit and will-quit events are not called\n    app.exit(0);\n  }\n});\n\nif (appArgs.crashReporter) {\n  app.on('will-finish-launching', () => {\n    crashReporter.start({\n      companyName: appArgs.companyName || '',\n      productName: appArgs.name,\n      submitURL: appArgs.crashReporter,\n      uploadToServer: true,\n    });\n  });\n}\n\napp.on('ready', () => {\n  mainWindow = createMainWindow(appArgs, app.quit, setDockBadge);\n  createTrayIcon(appArgs, mainWindow);\n\n  // Register global shortcuts\n  if (appArgs.globalShortcuts) {\n    appArgs.globalShortcuts.forEach((shortcut) => {\n      globalShortcut.register(shortcut.key, () => {\n        shortcut.inputEvents.forEach((inputEvent) => {\n          mainWindow.webContents.sendInputEvent(inputEvent);\n        });\n      });\n    });\n  }\n});\n\napp.on('new-window-for-tab', () => {\n  mainWindow.emit('new-tab');\n});\n\napp.on('login', (event, webContents, request, authInfo, callback) => {\n  // for http authentication\n  event.preventDefault();\n\n  if (\n    appArgs.basicAuthUsername !== null &&\n    appArgs.basicAuthPassword !== null\n  ) {\n    callback(appArgs.basicAuthUsername, appArgs.basicAuthPassword);\n  } else {\n    createLoginWindow(callback);\n  }\n});\n\nif (appArgs.singleInstance) {\n  const shouldQuit = app.makeSingleInstance(() => {\n    // Someone tried to run a second instance, we should focus our window.\n    if (mainWindow) {\n      if (!mainWindow.isVisible()) {\n        // tray\n        mainWindow.show();\n      }\n      if (mainWindow.isMinimized()) {\n        // minimized\n        mainWindow.restore();\n      }\n      mainWindow.focus();\n    }\n  });\n\n  if (shouldQuit) {\n    app.quit();\n  }\n}\n","require('./').install();\n","var SourceMapConsumer = require('source-map').SourceMapConsumer;\nvar path = require('path');\n\nvar fs;\ntry {\n  fs = require('fs');\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\nvar bufferFrom = require('buffer-from');\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (/^file:/.test(path)) {\n    // existsSync/readFileSync can't handle file protocol, but once stripped, it works\n    path = path.replace(/file:\\/\\/\\/(\\w:)?/, function(protocol, drive) {\n      return drive ?\n        '' : // file:///C:/dir/file -> C:/dir/file\n        '/'; // file:///root-dir/file -> /root-dir/file\n    });\n  }\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = '';\n  try {\n    if (!fs) {\n      // Use SJAX if we are in the browser\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', path, /** async */ false);\n      xhr.send(null);\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        contents = xhr.responseText;\n      }\n    } else if (fs.existsSync(path)) {\n      // Otherwise, use the filesystem\n      contents = fs.readFileSync(path, 'utf8');\n    }\n  } catch (er) {\n    /* ignore any errors */\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\" or \"file:///\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  var startPath = dir.slice(protocol.length);\n  if (protocol && /^\\/\\w\\:/.test(startPath)) {\n    // handle file:///C:/ paths\n    protocol += '/';\n    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\\\/g, '/');\n  }\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = bufferFrom(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map) {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame) {\n  if(frame.isNative()) {\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    var headerLength = 62;\n    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {\n      column -= headerLength;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    frame = cloneCallSite(frame);\n    var originalFunctionName = frame.getFunctionName;\n    frame.getFunctionName = function() { return position.name || originalFunctionName(); };\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  return error + stack.map(function(frame) {\n    return '\\n    at ' + wrapCallSite(frame);\n  }).join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      try {\n        contents = fs.readFileSync(source, 'utf8');\n      } catch (er) {\n        contents = '';\n      }\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  // Ensure error is printed synchronously and not truncated\n  if (process.stderr._handle && process.stderr._handle.setBlocking) {\n    process.stderr._handle.setBlocking(true);\n  }\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nvar originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);\nvar originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    var Module;\n    try {\n      Module = require('module');\n    } catch (err) {\n      // NOP: Loading in catch block to convert webpack error to warning.\n    }\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n\nexports.resetRetrieveHandlers = function() {\n  retrieveFileHandlers.length = 0;\n  retrieveMapHandlers.length = 0;\n\n  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);\n  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);\n}\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","module.exports = require(\"path\");","module.exports = require(\"fs\");","var toString = Object.prototype.toString\n\nvar isModern = (\n  typeof Buffer.alloc === 'function' &&\n  typeof Buffer.allocUnsafe === 'function' &&\n  typeof Buffer.from === 'function'\n)\n\nfunction isArrayBuffer (input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer'\n}\n\nfunction fromArrayBuffer (obj, byteOffset, length) {\n  byteOffset >>>= 0\n\n  var maxLength = obj.byteLength - byteOffset\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\")\n  }\n\n  if (length === undefined) {\n    length = maxLength\n  } else {\n    length >>>= 0\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\")\n    }\n  }\n\n  return isModern\n    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))\n    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  return isModern\n    ? Buffer.from(string, encoding)\n    : new Buffer(string, encoding)\n}\n\nfunction bufferFrom (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return isModern\n    ? Buffer.from(value)\n    : new Buffer(value)\n}\n\nmodule.exports = bufferFrom\n","module.exports = require(\"module\");","module.exports = require(\"electron\");","'use strict';\nconst path = require('path');\nconst electron = require('electron');\nconst unusedFilename = require('unused-filename');\nconst pupa = require('pupa');\nconst extName = require('ext-name');\n\nconst {app, shell} = electron;\n\nfunction getFilenameFromMime(name, mime) {\n\tconst exts = extName.mime(mime);\n\n\tif (exts.length !== 1) {\n\t\treturn name;\n\t}\n\n\treturn `${name}.${exts[0].ext}`;\n}\n\nfunction registerListener(session, options, cb = () => {}) {\n\tconst downloadItems = new Set();\n\tlet receivedBytes = 0;\n\tlet completedBytes = 0;\n\tlet totalBytes = 0;\n\tconst activeDownloadItems = () => downloadItems.size;\n\tconst progressDownloadItems = () => receivedBytes / totalBytes;\n\n\toptions = Object.assign({\n\t\tshowBadge: true\n\t}, options);\n\n\tconst listener = (e, item, webContents) => {\n\t\tdownloadItems.add(item);\n\t\ttotalBytes += item.getTotalBytes();\n\n\t\tlet hostWebContents = webContents;\n\t\tif (webContents.getType() === 'webview') {\n\t\t\t({hostWebContents} = webContents);\n\t\t}\n\t\tconst win = electron.BrowserWindow.fromWebContents(hostWebContents);\n\n\t\tconst dir = options.directory || app.getPath('downloads');\n\t\tlet filePath;\n\t\tif (options.filename) {\n\t\t\tfilePath = path.join(dir, options.filename);\n\t\t} else {\n\t\t\tconst filename = item.getFilename();\n\t\t\tconst name = path.extname(filename) ? filename : getFilenameFromMime(filename, item.getMimeType());\n\n\t\t\tfilePath = unusedFilename.sync(path.join(dir, name));\n\t\t}\n\n\t\tconst errorMessage = options.errorMessage || 'The download of {filename} was interrupted';\n\t\tconst errorTitle = options.errorTitle || 'Download Error';\n\n\t\tif (!options.saveAs) {\n\t\t\titem.setSavePath(filePath);\n\t\t}\n\n\t\tif (typeof options.onStarted === 'function') {\n\t\t\toptions.onStarted(item);\n\t\t}\n\n\t\titem.on('updated', () => {\n\t\t\treceivedBytes = [...downloadItems].reduce((receivedBytes, item) => {\n\t\t\t\treceivedBytes += item.getReceivedBytes();\n\t\t\t\treturn receivedBytes;\n\t\t\t}, completedBytes);\n\n\t\t\tif (options.showBadge && ['darwin', 'linux'].includes(process.platform)) {\n\t\t\t\tapp.setBadgeCount(activeDownloadItems());\n\t\t\t}\n\n\t\t\tif (!win.isDestroyed()) {\n\t\t\t\twin.setProgressBar(progressDownloadItems());\n\t\t\t}\n\n\t\t\tif (typeof options.onProgress === 'function') {\n\t\t\t\toptions.onProgress(progressDownloadItems());\n\t\t\t}\n\t\t});\n\n\t\titem.on('done', (e, state) => {\n\t\t\tcompletedBytes += item.getTotalBytes();\n\t\t\tdownloadItems.delete(item);\n\n\t\t\tif (options.showBadge && ['darwin', 'linux'].includes(process.platform)) {\n\t\t\t\tapp.setBadgeCount(activeDownloadItems());\n\t\t\t}\n\n\t\t\tif (!win.isDestroyed() && !activeDownloadItems()) {\n\t\t\t\twin.setProgressBar(-1);\n\t\t\t\treceivedBytes = 0;\n\t\t\t\tcompletedBytes = 0;\n\t\t\t\ttotalBytes = 0;\n\t\t\t}\n\n\t\t\tif (options.unregisterWhenDone) {\n\t\t\t\tsession.removeListener('will-download', listener);\n\t\t\t}\n\n\t\t\tif (state === 'cancelled') {\n\t\t\t\tif (typeof options.onCancel === 'function') {\n\t\t\t\t\toptions.onCancel(item);\n\t\t\t\t}\n\t\t\t} else if (state === 'interrupted') {\n\t\t\t\tconst message = pupa(errorMessage, {filename: item.getFilename()});\n\t\t\t\telectron.dialog.showErrorBox(errorTitle, message);\n\t\t\t\tcb(new Error(message));\n\t\t\t} else if (state === 'completed') {\n\t\t\t\tif (process.platform === 'darwin') {\n\t\t\t\t\tapp.dock.downloadFinished(filePath);\n\t\t\t\t}\n\n\t\t\t\tif (options.openFolderWhenDone) {\n\t\t\t\t\tshell.showItemInFolder(path.join(dir, item.getFilename()));\n\t\t\t\t}\n\n\t\t\t\tcb(null, item);\n\t\t\t}\n\t\t});\n\t};\n\n\tsession.on('will-download', listener);\n}\n\nmodule.exports = (options = {}) => {\n\tapp.on('session-created', session => {\n\t\tregisterListener(session, options);\n\t});\n};\n\nmodule.exports.download = (win, url, options) => new Promise((resolve, reject) => {\n\toptions = Object.assign({}, options, {unregisterWhenDone: true});\n\n\tregisterListener(win.webContents.session, options, (err, item) => {\n\t\tif (err) {\n\t\t\treject(err);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n\n\twin.webContents.downloadURL(url);\n});\n","'use strict';\nconst pathExists = require('path-exists');\nconst modifyFilename = require('modify-filename');\n\nconst incrementer = fp => {\n\tlet i = 0;\n\treturn () => modifyFilename(fp, (filename, ext) => `${filename} (${++i})${ext}`);\n};\n\nmodule.exports = fp => {\n\tconst getFp = incrementer(fp);\n\tconst find = newFp => pathExists(newFp).then(x => x ? find(getFp()) : newFp);\n\treturn find(fp);\n};\n\nmodule.exports.sync = fp => {\n\tconst getFp = incrementer(fp);\n\tconst find = newFp => pathExists.sync(newFp) ? find(getFp()) : newFp;\n\treturn find(fp);\n};\n","'use strict';\nconst fs = require('fs');\n\nmodule.exports = fp => new Promise(resolve => {\n\tfs.access(fp, err => {\n\t\tresolve(!err);\n\t});\n});\n\nmodule.exports.sync = fp => {\n\ttry {\n\t\tfs.accessSync(fp);\n\t\treturn true;\n\t} catch (err) {\n\t\treturn false;\n\t}\n};\n","'use strict';\nvar path = require('path');\n\nmodule.exports = function modifyFilename(pth, modifier) {\n\tif (arguments.length !== 2) {\n\t\tthrow new Error('`path` and `modifier` required');\n\t}\n\n\tif (Array.isArray(pth)) {\n\t\treturn pth.map(function (el) {\n\t\t\treturn modifyFilename(el, modifier);\n\t\t});\n\t}\n\n\tvar ext = path.extname(pth);\n\treturn path.join(path.dirname(pth), modifier(path.basename(pth, ext), ext));\n};\n","'use strict';\nmodule.exports = (tpl, data) => {\n\tif (typeof tpl !== 'string') {\n\t\tthrow new TypeError(`Expected a string in the first argument, got ${typeof tpl}`);\n\t}\n\n\tif (typeof data !== 'object') {\n\t\tthrow new TypeError(`Expected an Object/Array in the second argument, got ${typeof data}`);\n\t}\n\n\tconst re = /{(.*?)}/g;\n\n\treturn tpl.replace(re, (_, key) => {\n\t\tlet ret = data;\n\n\t\tfor (const prop of key.split('.')) {\n\t\t\tret = ret ? ret[prop] : '';\n\t\t}\n\n\t\treturn ret || '';\n\t});\n};\n","'use strict';\nconst extList = require('ext-list');\nconst sortKeysLength = require('sort-keys-length');\n\nmodule.exports = str => {\n\tconst obj = sortKeysLength.desc(extList());\n\tconst exts = Object.keys(obj).filter(x => str.endsWith(x));\n\n\tif (exts.length === 0) {\n\t\treturn [];\n\t}\n\n\treturn exts.map(x => ({\n\t\text: x,\n\t\tmime: obj[x]\n\t}));\n};\n\nmodule.exports.mime = str => {\n\tconst obj = sortKeysLength.desc(extList());\n\tconst exts = Object.keys(obj).filter(x => obj[x] === str);\n\n\tif (exts.length === 0) {\n\t\treturn [];\n\t}\n\n\treturn exts.map(x => ({\n\t\text: x,\n\t\tmime: obj[x]\n\t}));\n};\n","'use strict';\nvar mimeDb = require('mime-db');\n\nmodule.exports = function () {\n\tvar ret = {};\n\n\tObject.keys(mimeDb).forEach(function (x) {\n\t\tvar val = mimeDb[x];\n\n\t\tif (val.extensions && val.extensions.length > 0) {\n\t\t\tval.extensions.forEach(function (y) {\n\t\t\t\tret[y] = x;\n\t\t\t});\n\t\t}\n\t});\n\n\treturn ret;\n};\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","'use strict';\n\nvar sortKeys = require('sort-keys');\n\n/**\n * Sort object keys by length\n *\n * @param obj\n * @api public\n */\n\nmodule.exports.desc = function (obj) {\n\treturn sortKeys(obj, function (a, b) {\n\t\treturn b.length - a.length;\n\t});\n}\n\nmodule.exports.asc = function (obj) {\n\treturn sortKeys(obj, function (a, b) {\n\t\treturn a.length - b.length;\n\t});\n}\n","'use strict';\nvar isPlainObj = require('is-plain-obj');\n\nmodule.exports = function (obj, opts) {\n\tif (!isPlainObj(obj)) {\n\t\tthrow new TypeError('Expected a plain object');\n\t}\n\n\topts = opts || {};\n\n\t// DEPRECATED\n\tif (typeof opts === 'function') {\n\t\topts = {compare: opts};\n\t}\n\n\tvar deep = opts.deep;\n\tvar seenInput = [];\n\tvar seenOutput = [];\n\n\tvar sortKeys = function (x) {\n\t\tvar seenIndex = seenInput.indexOf(x);\n\n\t\tif (seenIndex !== -1) {\n\t\t\treturn seenOutput[seenIndex];\n\t\t}\n\n\t\tvar ret = {};\n\t\tvar keys = Object.keys(x).sort(opts.compare);\n\n\t\tseenInput.push(x);\n\t\tseenOutput.push(ret);\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tvar val = x[key];\n\n\t\t\tret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\treturn sortKeys(obj);\n};\n","'use strict';\nvar toString = Object.prototype.toString;\n\nmodule.exports = function (x) {\n\tvar prototype;\n\treturn toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));\n};\n","import { BrowserWindow, ipcMain } from 'electron';\nimport path from 'path';\n\nfunction createLoginWindow(loginCallback) {\n  const loginWindow = new BrowserWindow({\n    width: 300,\n    height: 400,\n    frame: false,\n    resizable: false,\n  });\n  loginWindow.loadURL(\n    `file://${path.join(__dirname, '/static/login/login.html')}`,\n  );\n\n  ipcMain.once('login-message', (event, usernameAndPassword) => {\n    loginCallback(usernameAndPassword[0], usernameAndPassword[1]);\n    loginWindow.close();\n  });\n  return loginWindow;\n}\n\nexport default createLoginWindow;\n","import fs from 'fs';\nimport path from 'path';\nimport { BrowserWindow, shell, ipcMain, dialog } from 'electron';\nimport windowStateKeeper from 'electron-window-state';\nimport mainWindowHelpers from './mainWindowHelpers';\nimport helpers from '../../helpers/helpers';\nimport createMenu from '../menu/menu';\nimport initContextMenu from '../contextMenu/contextMenu';\n\nconst {\n  isOSX,\n  linkIsInternal,\n  getCssToInject,\n  shouldInjectCss,\n  getAppIcon,\n  nativeTabsSupported,\n  getCounterValue,\n} = helpers;\n\nconst { onNewWindowHelper } = mainWindowHelpers;\n\nconst ZOOM_INTERVAL = 0.1;\n\nfunction maybeHideWindow(window, event, fastQuit, tray) {\n  if (isOSX() && !fastQuit) {\n    // this is called when exiting from clicking the cross button on the window\n    event.preventDefault();\n    window.hide();\n  } else if (!fastQuit && tray) {\n    event.preventDefault();\n    window.hide();\n  }\n  // will close the window on other platforms\n}\n\nfunction maybeInjectCss(browserWindow) {\n  if (!shouldInjectCss()) {\n    return;\n  }\n\n  const cssToInject = getCssToInject();\n\n  const injectCss = () => {\n    browserWindow.webContents.insertCSS(cssToInject);\n  };\n  const onHeadersReceived = (details, callback) => {\n    injectCss();\n    callback({ cancel: false, responseHeaders: details.responseHeaders });\n  };\n\n  browserWindow.webContents.on('did-finish-load', () => {\n    // remove the injection of css the moment the page is loaded\n    browserWindow.webContents.session.webRequest.onHeadersReceived(null);\n  });\n\n  // on every page navigation inject the css\n  browserWindow.webContents.on('did-navigate', () => {\n    // we have to inject the css in onHeadersReceived so they're early enough\n    // will run multiple times, so did-finish-load will remove this handler\n    browserWindow.webContents.session.webRequest.onHeadersReceived(\n      [], // Pass an empty filter list; null will not match _any_ urls\n      onHeadersReceived,\n    );\n  });\n}\n\n/**\n *\n * @param {{}} inpOptions AppArgs from golem.json\n * @param {function} onAppQuit\n * @param {function} setDockBadge\n * @returns {electron.BrowserWindow}\n */\nfunction createMainWindow(inpOptions, onAppQuit, setDockBadge) {\n  const options = Object.assign({}, inpOptions);\n  const mainWindowState = windowStateKeeper({\n    defaultWidth: options.width || 1280,\n    defaultHeight: options.height || 800,\n  });\n\n  const DEFAULT_WINDOW_OPTIONS = {\n    // Convert dashes to spaces because on linux the app name is joined with dashes\n    title: options.name,\n    tabbingIdentifier: nativeTabsSupported() ? options.name : undefined,\n    webPreferences: {\n      javascript: true,\n      plugins: true,\n      // node globals causes problems with sites like messenger.com\n      nodeIntegration: false,\n      webSecurity: !options.insecure,\n      preload: path.join(__dirname, 'static', 'preload.js'),\n      zoomFactor: options.zoom,\n    },\n  };\n\n  const mainWindow = new BrowserWindow(\n    Object.assign(\n      {\n        frame: !options.hideWindowFrame,\n        width: mainWindowState.width,\n        height: mainWindowState.height,\n        minWidth: options.minWidth,\n        minHeight: options.minHeight,\n        maxWidth: options.maxWidth,\n        maxHeight: options.maxHeight,\n        x: options.x,\n        y: options.y,\n        autoHideMenuBar: !options.showMenuBar,\n        // after webpack path here should reference `resources/app/`\n        icon: getAppIcon(),\n        // set to undefined and not false because explicitly setting to false will disable full screen\n        fullscreen: options.fullScreen || undefined,\n        // Whether the window should always stay on top of other windows. Default is false.\n        alwaysOnTop: options.alwaysOnTop,\n        titleBarStyle: options.titleBarStyle,\n        show: options.tray !== 'start-in-tray',\n      },\n      DEFAULT_WINDOW_OPTIONS,\n    ),\n  );\n\n  mainWindowState.manage(mainWindow);\n\n  // after first run, no longer force maximize to be true\n  if (options.maximize) {\n    mainWindow.maximize();\n    options.maximize = undefined;\n    fs.writeFileSync(\n      path.join(__dirname, '..', 'golem.json'),\n      JSON.stringify(options),\n    );\n  }\n\n  const withFocusedWindow = (block) => {\n    const focusedWindow = BrowserWindow.getFocusedWindow();\n    if (focusedWindow) {\n      return block(focusedWindow);\n    }\n    return undefined;\n  };\n\n  const adjustWindowZoom = (window, adjustment) => {\n    window.webContents.getZoomFactor((zoomFactor) => {\n      window.webContents.setZoomFactor(zoomFactor + adjustment);\n    });\n  };\n\n  const onZoomIn = () => {\n    withFocusedWindow((focusedWindow) =>\n      adjustWindowZoom(focusedWindow, ZOOM_INTERVAL),\n    );\n  };\n\n  const onZoomOut = () => {\n    withFocusedWindow((focusedWindow) =>\n      adjustWindowZoom(focusedWindow, -ZOOM_INTERVAL),\n    );\n  };\n\n  const onZoomReset = () => {\n    withFocusedWindow((focusedWindow) => {\n      focusedWindow.webContents.setZoomFactor(options.zoom);\n    });\n  };\n\n  const clearAppData = () => {\n    dialog.showMessageBox(\n      mainWindow,\n      {\n        type: 'warning',\n        buttons: ['Yes', 'Cancel'],\n        defaultId: 1,\n        title: 'Flush App Cache',\n        message:\n          'This will absolute delete all data (cookies, web cache, local storage, gpu cache, etc) from this app. Are you sure you wish to proceed?',\n      },\n      (response) => {\n        if (response !== 0) {\n          return;\n        }\n        const { session } = mainWindow.webContents;\n        session.clearStorageData(() => {\n          session.clearCache(() => {\n            mainWindow.loadURL(options.targetUrl);\n          });\n        });\n      },\n    );\n  };\n\n  const onGoBack = () => {\n    withFocusedWindow((focusedWindow) => {\n      focusedWindow.webContents.goBack();\n    });\n  };\n\n  const onGoForward = () => {\n    withFocusedWindow((focusedWindow) => {\n      focusedWindow.webContents.goForward();\n    });\n  };\n\n  const getCurrentUrl = () =>\n    withFocusedWindow((focusedWindow) => focusedWindow.webContents.getURL());\n\n  const onWillNavigate = (event, urlToGo) => {\n    if (!linkIsInternal(options.targetUrl, urlToGo, options.internalUrls)) {\n      event.preventDefault();\n      shell.openExternal(urlToGo);\n    }\n  };\n\n  let createNewWindow;\n\n  const createNewTab = (url, foreground) => {\n    withFocusedWindow((focusedWindow) => {\n      const newTab = createNewWindow(url);\n      focusedWindow.addTabbedWindow(newTab);\n      if (!foreground) {\n        focusedWindow.focus();\n      }\n      return newTab;\n    });\n    return undefined;\n  };\n\n  const createAboutBlankWindow = () => {\n    const window = createNewWindow('about:blank');\n    window.hide();\n    window.webContents.once('did-stop-loading', () => {\n      if (window.webContents.getURL() === 'about:blank') {\n        window.close();\n      } else {\n        window.show();\n      }\n    });\n    return window;\n  };\n\n  const onNewWindow = (event, urlToGo, _, disposition) => {\n    const preventDefault = (newGuest) => {\n      event.preventDefault();\n      if (newGuest) {\n        // eslint-disable-next-line no-param-reassign\n        event.newGuest = newGuest;\n      }\n    };\n    onNewWindowHelper(\n      urlToGo,\n      disposition,\n      options.targetUrl,\n      options.internalUrls,\n      preventDefault,\n      shell.openExternal,\n      createAboutBlankWindow,\n      nativeTabsSupported,\n      createNewTab,\n    );\n  };\n\n  const sendParamsOnDidFinishLoad = (window) => {\n    window.webContents.on('did-finish-load', () => {\n      window.webContents.send('params', JSON.stringify(options));\n    });\n  };\n\n  createNewWindow = (url) => {\n    const window = new BrowserWindow(DEFAULT_WINDOW_OPTIONS);\n    if (options.userAgent) {\n      window.webContents.setUserAgent(options.userAgent);\n    }\n    maybeInjectCss(window);\n    sendParamsOnDidFinishLoad(window);\n    window.webContents.on('new-window', onNewWindow);\n    window.webContents.on('will-navigate', onWillNavigate);\n    window.loadURL(url);\n    return window;\n  };\n\n  const menuOptions = {\n    golemVersion: options.golemVersion,\n    appQuit: onAppQuit,\n    zoomIn: onZoomIn,\n    zoomOut: onZoomOut,\n    zoomReset: onZoomReset,\n    zoomBuildTimeValue: options.zoom,\n    goBack: onGoBack,\n    goForward: onGoForward,\n    getCurrentUrl,\n    clearAppData,\n    disableDevTools: options.disableDevTools,\n  };\n\n  createMenu(menuOptions);\n  if (!options.disableContextMenu) {\n    initContextMenu(\n      createNewWindow,\n      nativeTabsSupported() ? createNewTab : undefined,\n    );\n  }\n\n  if (options.userAgent) {\n    mainWindow.webContents.setUserAgent(options.userAgent);\n  }\n\n  maybeInjectCss(mainWindow);\n  sendParamsOnDidFinishLoad(mainWindow);\n\n  if (options.counter) {\n    mainWindow.on('page-title-updated', (e, title) => {\n      const counterValue = getCounterValue(title);\n      if (counterValue) {\n        setDockBadge(counterValue, options.bounce);\n      } else {\n        setDockBadge('');\n      }\n    });\n  } else {\n    ipcMain.on('notification', () => {\n      if (!isOSX() || mainWindow.isFocused()) {\n        return;\n      }\n      setDockBadge('', options.bounce);\n    });\n    mainWindow.on('focus', () => {\n      setDockBadge('');\n    });\n  }\n\n  ipcMain.on('notification-click', () => {\n    mainWindow.show();\n  });\n\n  mainWindow.webContents.on('new-window', onNewWindow);\n  mainWindow.webContents.on('will-navigate', onWillNavigate);\n\n  mainWindow.loadURL(options.targetUrl);\n\n  mainWindow.on('new-tab', () => createNewTab(options.targetUrl, true));\n\n  mainWindow.on('close', (event) => {\n    if (mainWindow.isFullScreen()) {\n      if (nativeTabsSupported()) {\n        mainWindow.moveTabToNewWindow();\n      }\n      mainWindow.setFullScreen(false);\n      mainWindow.once(\n        'leave-full-screen',\n        maybeHideWindow.bind(this, mainWindow, event, options.fastQuit),\n      );\n    }\n    maybeHideWindow(mainWindow, event, options.fastQuit, options.tray);\n  });\n\n  return mainWindow;\n}\n\nexport default createMainWindow;\n","'use strict';\n\nvar path = require('path');\nvar electron = require('electron');\nvar jsonfile = require('jsonfile');\nvar mkdirp = require('mkdirp');\nvar deepEqual = require('deep-equal');\n\nmodule.exports = function (options) {\n  var app = electron.app || electron.remote.app;\n  var screen = electron.screen || electron.remote.screen;\n  var state;\n  var winRef;\n  var stateChangeTimer;\n  var eventHandlingDelay = 100;\n  var config = Object.assign({\n    file: 'window-state.json',\n    path: app.getPath('userData'),\n    maximize: true,\n    fullScreen: true\n  }, options);\n  var fullStoreFileName = path.join(config.path, config.file);\n\n  function isNormal(win) {\n    return !win.isMaximized() && !win.isMinimized() && !win.isFullScreen();\n  }\n\n  function hasBounds() {\n    return state &&\n      Number.isInteger(state.x) &&\n      Number.isInteger(state.y) &&\n      Number.isInteger(state.width) && state.width > 0 &&\n      Number.isInteger(state.height) && state.height > 0;\n  }\n\n  function validateState() {\n    var isValid = state && (hasBounds() || state.isMaximized || state.isFullScreen);\n    if (!isValid) {\n      state = null;\n      return;\n    }\n\n    if (hasBounds() && state.displayBounds) {\n      // Check if the display where the window was last open is still available\n      var displayBounds = screen.getDisplayMatching(state).bounds;\n      var sameBounds = deepEqual(state.displayBounds, displayBounds, {strict: true});\n      if (!sameBounds) {\n        if (displayBounds.width < state.displayBounds.width) {\n          if (state.x > displayBounds.width) {\n            state.x = 0;\n          }\n\n          if (state.width > displayBounds.width) {\n            state.width = displayBounds.width;\n          }\n        }\n\n        if (displayBounds.height < state.displayBounds.height) {\n          if (state.y > displayBounds.height) {\n            state.y = 0;\n          }\n\n          if (state.height > displayBounds.height) {\n            state.height = displayBounds.height;\n          }\n        }\n      }\n    }\n  }\n\n  function updateState(win) {\n    win = win || winRef;\n    if (!win) {\n      return;\n    }\n    // don't throw an error when window was closed\n    try {\n      var winBounds = win.getBounds();\n      if (isNormal(win)) {\n        state.x = winBounds.x;\n        state.y = winBounds.y;\n        state.width = winBounds.width;\n        state.height = winBounds.height;\n      }\n      state.isMaximized = win.isMaximized();\n      state.isFullScreen = win.isFullScreen();\n      state.displayBounds = screen.getDisplayMatching(winBounds).bounds;\n    } catch (err) {}\n  }\n\n  function saveState(win) {\n    // Update window state only if it was provided\n    if (win) {\n      updateState(win);\n    }\n\n    // Save state\n    try {\n      mkdirp.sync(path.dirname(fullStoreFileName));\n      jsonfile.writeFileSync(fullStoreFileName, state);\n    } catch (err) {\n      // Don't care\n    }\n  }\n\n  function stateChangeHandler() {\n    // Handles both 'resize' and 'move'\n    clearTimeout(stateChangeTimer);\n    stateChangeTimer = setTimeout(updateState, eventHandlingDelay);\n  }\n\n  function closeHandler() {\n    updateState();\n  }\n\n  function closedHandler() {\n    // Unregister listeners and save state\n    unmanage();\n    saveState();\n  }\n\n  function manage(win) {\n    if (config.maximize && state.isMaximized) {\n      win.maximize();\n    }\n    if (config.fullScreen && state.isFullScreen) {\n      win.setFullScreen(true);\n    }\n    win.on('resize', stateChangeHandler);\n    win.on('move', stateChangeHandler);\n    win.on('close', closeHandler);\n    win.on('closed', closedHandler);\n    winRef = win;\n  }\n\n  function unmanage() {\n    if (winRef) {\n      winRef.removeListener('resize', stateChangeHandler);\n      winRef.removeListener('move', stateChangeHandler);\n      clearTimeout(stateChangeTimer);\n      winRef.removeListener('close', closeHandler);\n      winRef.removeListener('closed', closedHandler);\n      winRef = null;\n    }\n  }\n\n  // Load previous state\n  try {\n    state = jsonfile.readFileSync(fullStoreFileName);\n  } catch (err) {\n    // Don't care\n  }\n\n  // Check state validity\n  validateState();\n\n  // Set state fallback values\n  state = Object.assign({\n    width: config.defaultWidth || 800,\n    height: config.defaultHeight || 600\n  }, state);\n\n  return {\n    get x() { return state.x; },\n    get y() { return state.y; },\n    get width() { return state.width; },\n    get height() { return state.height; },\n    get isMaximized() { return state.isMaximized; },\n    get isFullScreen() { return state.isFullScreen; },\n    saveState: saveState,\n    unmanage: unmanage,\n    manage: manage\n  };\n};\n","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  var content = fs.readFileSync(file, options)\n  content = stripBom(content)\n\n  try {\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = ''\n  try {\n    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\\n'\n  } catch (err) {\n    if (callback) return callback(err, null)\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = JSON.stringify(obj, options.replacer, spaces) + '\\n'\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  spaces: null,\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar queue = []\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    require('assert').equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, cb) {\n      return orig.call(fs, target, function (er, stats) {\n        if (!stats) return cb.apply(this, arguments)\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target) {\n      var stats = orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","module.exports = require(\"constants\");","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","module.exports = require(\"stream\");","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","module.exports = require(\"util\");","module.exports = require(\"assert\");","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n","import helpers from '../../helpers/helpers';\n\nconst { linkIsInternal } = helpers;\n\nfunction onNewWindowHelper(\n  urlToGo,\n  disposition,\n  targetUrl,\n  internalUrls,\n  preventDefault,\n  openExternal,\n  createAboutBlankWindow,\n  nativeTabsSupported,\n  createNewTab,\n) {\n  if (!linkIsInternal(targetUrl, urlToGo, internalUrls)) {\n    openExternal(urlToGo);\n    preventDefault();\n  } else if (urlToGo === 'about:blank') {\n    const newWindow = createAboutBlankWindow();\n    preventDefault(newWindow);\n  } else if (nativeTabsSupported()) {\n    if (disposition === 'background-tab') {\n      const newTab = createNewTab(urlToGo, false);\n      preventDefault(newTab);\n    } else if (disposition === 'foreground-tab') {\n      const newTab = createNewTab(urlToGo, true);\n      preventDefault(newTab);\n    }\n  }\n}\n\nexport default { onNewWindowHelper };\n","import wurl from 'wurl';\nimport os from 'os';\nimport fs from 'fs';\nimport path from 'path';\n\nconst INJECT_CSS_PATH = path.join(__dirname, '..', 'inject/inject.css');\nconst log = require('loglevel');\n\nfunction isOSX() {\n  return os.platform() === 'darwin';\n}\n\nfunction isLinux() {\n  return os.platform() === 'linux';\n}\n\nfunction isWindows() {\n  return os.platform() === 'win32';\n}\n\nfunction linkIsInternal(currentUrl, newUrl, internalUrlRegex) {\n  if (newUrl === 'about:blank') {\n    return true;\n  }\n\n  if (internalUrlRegex) {\n    const regex = RegExp(internalUrlRegex);\n    return regex.test(newUrl);\n  }\n\n  const currentDomain = wurl('domain', currentUrl);\n  const newDomain = wurl('domain', newUrl);\n  return currentDomain === newDomain;\n}\n\nfunction shouldInjectCss() {\n  try {\n    fs.accessSync(INJECT_CSS_PATH, fs.F_OK);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction getCssToInject() {\n  return fs.readFileSync(INJECT_CSS_PATH).toString();\n}\n\n/**\n * Helper method to print debug messages from the main process in the browser window\n * @param {BrowserWindow} browserWindow\n * @param message\n */\nfunction debugLog(browserWindow, message) {\n  // need the timeout as it takes time for the preload javascript to be loaded in the window\n  setTimeout(() => {\n    browserWindow.webContents.send('debug', message);\n  }, 3000);\n  log.info(message);\n}\n\nfunction getAppIcon() {\n  return path.join(__dirname, '../', `/icon.${isWindows() ? 'ico' : 'png'}`);\n}\n\nfunction nativeTabsSupported() {\n  return isOSX();\n}\n\nfunction getCounterValue(title) {\n  const itemCountRegex = /[([{]([\\d.,]*)\\+?[}\\])]/;\n  const match = itemCountRegex.exec(title);\n  return match ? match[1] : undefined;\n}\n\nexport default {\n  isOSX,\n  isLinux,\n  isWindows,\n  linkIsInternal,\n  getCssToInject,\n  debugLog,\n  shouldInjectCss,\n  getAppIcon,\n  nativeTabsSupported,\n  getCounterValue,\n};\n","module.exports = function (arg, url) {\r\n\r\n    function _t() {\r\n        return new RegExp(/(.*?)\\.?([^\\.]*?)\\.(gl|com|net|org|biz|ws|in|me|co\\.uk|co|org\\.uk|ltd\\.uk|plc\\.uk|me\\.uk|edu|mil|br\\.com|cn\\.com|eu\\.com|hu\\.com|no\\.com|qc\\.com|sa\\.com|se\\.com|se\\.net|us\\.com|uy\\.com|ac|co\\.ac|gv\\.ac|or\\.ac|ac\\.ac|af|am|as|at|ac\\.at|co\\.at|gv\\.at|or\\.at|asn\\.au|com\\.au|edu\\.au|org\\.au|net\\.au|id\\.au|be|ac\\.be|adm\\.br|adv\\.br|am\\.br|arq\\.br|art\\.br|bio\\.br|cng\\.br|cnt\\.br|com\\.br|ecn\\.br|eng\\.br|esp\\.br|etc\\.br|eti\\.br|fm\\.br|fot\\.br|fst\\.br|g12\\.br|gov\\.br|ind\\.br|inf\\.br|jor\\.br|lel\\.br|med\\.br|mil\\.br|net\\.br|nom\\.br|ntr\\.br|odo\\.br|org\\.br|ppg\\.br|pro\\.br|psc\\.br|psi\\.br|rec\\.br|slg\\.br|tmp\\.br|tur\\.br|tv\\.br|vet\\.br|zlg\\.br|br|ab\\.ca|bc\\.ca|mb\\.ca|nb\\.ca|nf\\.ca|ns\\.ca|nt\\.ca|on\\.ca|pe\\.ca|qc\\.ca|sk\\.ca|yk\\.ca|ca|cc|ac\\.cn|com\\.cn|edu\\.cn|gov\\.cn|org\\.cn|bj\\.cn|sh\\.cn|tj\\.cn|cq\\.cn|he\\.cn|nm\\.cn|ln\\.cn|jl\\.cn|hl\\.cn|js\\.cn|zj\\.cn|ah\\.cn|gd\\.cn|gx\\.cn|hi\\.cn|sc\\.cn|gz\\.cn|yn\\.cn|xz\\.cn|sn\\.cn|gs\\.cn|qh\\.cn|nx\\.cn|xj\\.cn|tw\\.cn|hk\\.cn|mo\\.cn|cn|cx|cz|de|dk|fo|com\\.ec|tm\\.fr|com\\.fr|asso\\.fr|presse\\.fr|fr|gf|gs|co\\.il|net\\.il|ac\\.il|k12\\.il|gov\\.il|muni\\.il|ac\\.in|co\\.in|org\\.in|ernet\\.in|gov\\.in|net\\.in|res\\.in|is|it|ac\\.jp|co\\.jp|go\\.jp|or\\.jp|ne\\.jp|ac\\.kr|co\\.kr|go\\.kr|ne\\.kr|nm\\.kr|or\\.kr|li|lt|lu|asso\\.mc|tm\\.mc|com\\.mm|org\\.mm|net\\.mm|edu\\.mm|gov\\.mm|ms|nl|no|nu|pl|ro|org\\.ro|store\\.ro|tm\\.ro|firm\\.ro|www\\.ro|arts\\.ro|rec\\.ro|info\\.ro|nom\\.ro|nt\\.ro|se|si|com\\.sg|org\\.sg|net\\.sg|gov\\.sg|sk|st|tf|ac\\.th|co\\.th|go\\.th|mi\\.th|net\\.th|or\\.th|tm|to|com\\.tr|edu\\.tr|gov\\.tr|k12\\.tr|net\\.tr|org\\.tr|com\\.tw|org\\.tw|net\\.tw|ac\\.uk|uk\\.com|uk\\.net|gb\\.com|gb\\.net|vg|sh|kz|ch|info|ua|gov|name|pro|ie|hk|com\\.hk|org\\.hk|net\\.hk|edu\\.hk|us|tk|cd|by|ad|lv|eu\\.lv|bz|es|jp|cl|ag|mobi|eu|co\\.nz|org\\.nz|net\\.nz|maori\\.nz|iwi\\.nz|io|la|md|sc|sg|vc|tw|travel|my|se|tv|pt|com\\.pt|edu\\.pt|asia|fi|com\\.ve|net\\.ve|fi|org\\.ve|web\\.ve|info\\.ve|co\\.ve|tel|im|gr|ru|net\\.ru|org\\.ru|hr|com\\.hr|ly|xyz)$/);\r\n    }\r\n\r\n    function _d(s) {\r\n      return decodeURIComponent(s.replace(/\\+/g, ' '));\r\n    }\r\n\r\n    function _i(arg, str) {\r\n        var sptr = arg.charAt(0),\r\n            split = str.split(sptr);\r\n\r\n        if (sptr === arg) { return split; }\r\n\r\n        arg = parseInt(arg.substring(1), 10);\r\n\r\n        return split[arg < 0 ? split.length + arg : arg - 1];\r\n    }\r\n\r\n    function _f(arg, str) {\r\n        var sptr = arg.charAt(0),\r\n            split = str.split('&'),\r\n            field = [],\r\n            params = {},\r\n            tmp = [],\r\n            arg2 = arg.substring(1);\r\n\r\n        for (var i = 0, ii = split.length; i < ii; i++) {\r\n            field = split[i].match(/(.*?)=(.*)/);\r\n\r\n            // TODO: regex should be able to handle this.\r\n            if ( ! field) {\r\n                field = [split[i], split[i], ''];\r\n            }\r\n\r\n            if (field[1].replace(/\\s/g, '') !== '') {\r\n                field[2] = _d(field[2] || '');\r\n\r\n                // If we have a match just return it right away.\r\n                if (arg2 === field[1]) { return field[2]; }\r\n\r\n                // Check for array pattern.\r\n                tmp = field[1].match(/(.*)\\[([0-9]+)\\]/);\r\n\r\n                if (tmp) {\r\n                    params[tmp[1]] = params[tmp[1]] || [];\r\n                \r\n                    params[tmp[1]][tmp[2]] = field[2];\r\n                }\r\n                else {\r\n                    params[field[1]] = field[2];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (sptr === arg) { return params; }\r\n\r\n        return params[arg2];\r\n    }\r\n\r\n    var _l = {}, tmp, tmp2;\r\n\r\n    if (arg === 'tld?') { return _t(); }\r\n\r\n    url = url || window.location.toString();\r\n\r\n    if ( ! arg) { return url; }\r\n\r\n    arg = arg.toString();\r\n\r\n    if (tmp = url.match(/^mailto:([^\\/].+)/)) {\r\n        _l.protocol = 'mailto';\r\n        _l.email = tmp[1];\r\n    }\r\n    else {\r\n\r\n        // Ignore Hashbangs.\r\n        if (tmp = url.match(/(.*?)\\/#\\!(.*)/)) {\r\n            url = tmp[1] + tmp[2];\r\n        }\r\n\r\n        // Hash.\r\n        if (tmp = url.match(/(.*?)#(.*)/)) {\r\n            _l.hash = tmp[2];\r\n            url = tmp[1];\r\n        }\r\n\r\n        // Return hash parts.\r\n        if (_l.hash && arg.match(/^#/)) { return _f(arg, _l.hash); }\r\n\r\n        // Query\r\n        if (tmp = url.match(/(.*?)\\?(.*)/)) {\r\n            _l.query = tmp[2];\r\n            url = tmp[1];\r\n        }\r\n\r\n        // Return query parts.\r\n        if (_l.query && arg.match(/^\\?/)) { return _f(arg, _l.query); }\r\n\r\n        // Protocol.\r\n        if (tmp = url.match(/(.*?)\\:?\\/\\/(.*)/)) {\r\n            _l.protocol = tmp[1].toLowerCase();\r\n            url = tmp[2];\r\n        }\r\n\r\n        // Path.\r\n        if (tmp = url.match(/(.*?)(\\/.*)/)) {\r\n            _l.path = tmp[2];\r\n            url = tmp[1];\r\n        }\r\n\r\n        // Clean up path.\r\n        _l.path = (_l.path || '').replace(/^([^\\/])/, '/$1');\r\n\r\n        // Return path parts.\r\n        if (arg.match(/^[\\-0-9]+$/)) { arg = arg.replace(/^([^\\/])/, '/$1'); }\r\n        if (arg.match(/^\\//)) { return _i(arg, _l.path.substring(1)); }\r\n\r\n        // File.\r\n        tmp = _i('/-1', _l.path.substring(1));\r\n        \r\n        if (tmp && (tmp = tmp.match(/(.*?)\\.([^.]+)$/))) {\r\n            _l.file = tmp[0];\r\n            _l.filename = tmp[1];\r\n            _l.fileext = tmp[2];\r\n        }\r\n\r\n        // Port.\r\n        if (tmp = url.match(/(.*)\\:([0-9]+)$/)) {\r\n            _l.port = tmp[2];\r\n            url = tmp[1];\r\n        }\r\n\r\n        // Auth.\r\n        if (tmp = url.match(/(.*?)@(.*)/)) {\r\n            _l.auth = tmp[1];\r\n            url = tmp[2];\r\n        }\r\n\r\n        // User and pass.\r\n        if (_l.auth) {\r\n            tmp = _l.auth.match(/(.*)\\:(.*)/);\r\n\r\n            _l.user = tmp ? tmp[1] : _l.auth;\r\n            _l.pass = tmp ? tmp[2] : undefined;\r\n        }\r\n\r\n        // Hostname.\r\n        _l.hostname = url.toLowerCase();\r\n\r\n        // Return hostname parts.\r\n        if (arg.charAt(0) === '.') { return _i(arg, _l.hostname); }\r\n\r\n        // Domain, tld and sub domain.\r\n        if (_t()) {\r\n            tmp = _l.hostname.match(_t());\r\n\r\n            if (tmp) {\r\n                _l.tld = tmp[3];\r\n                _l.domain = tmp[2] ? tmp[2] + '.' + tmp[3] : undefined;\r\n                _l.sub = tmp[1] || undefined;\r\n            }\r\n        }\r\n\r\n        // Set port and protocol defaults if not set.\r\n        _l.port = _l.port || (_l.protocol === 'https' ? '443' : '80');\r\n        _l.protocol = _l.protocol || (_l.port === '443' ? 'https' : 'http');\r\n    }\r\n\r\n    // Return arg.\r\n    if (arg in _l) { return _l[arg]; }\r\n\r\n    // Return everything.\r\n    if (arg === '{}') { return _l; }\r\n\r\n    // Default to undefined for no match.\r\n    return undefined;\r\n};","module.exports = require(\"os\");","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","import { Menu, shell, clipboard } from 'electron';\n\n/**\n * @param golemVersion\n * @param appQuit\n * @param zoomIn\n * @param zoomOut\n * @param zoomReset\n * @param zoomBuildTimeValue\n * @param goBack\n * @param goForward\n * @param getCurrentUrl\n * @param clearAppData\n * @param disableDevTools\n */\nfunction createMenu({\n  golemVersion,\n  appQuit,\n  zoomIn,\n  zoomOut,\n  zoomReset,\n  zoomBuildTimeValue,\n  goBack,\n  goForward,\n  getCurrentUrl,\n  clearAppData,\n  disableDevTools,\n}) {\n  if (Menu.getApplicationMenu()) {\n    return;\n  }\n  const zoomResetLabel =\n    zoomBuildTimeValue === 1.0\n      ? 'Reset Zoom'\n      : `Reset Zoom (to ${zoomBuildTimeValue * 100}%, set at build time)`;\n\n  const template = [\n    {\n      label: 'GOLEM',\n      role: 'window',\n      submenu: [\n        {\n          label: 'Reload',\n          accelerator: 'CmdOrCtrl+R',\n          click: (item, focusedWindow) => {\n            if (focusedWindow) {\n              focusedWindow.reload();\n            }\n          },\n        },\n        {\n          label: 'Minimize',\n          accelerator: 'CmdOrCtrl+M',\n          role: 'minimize',\n        },\n        {\n          label: 'Quit',\n          accelerator: 'CmdOrCtrl+W',\n          role: 'close',\n        },\n      ],\n    },\n    {\n      label: 'Edit',\n      submenu: [\n        {\n          label: 'Undo',\n          accelerator: 'CmdOrCtrl+Z',\n          role: 'undo',\n        },\n        {\n          label: 'Redo',\n          accelerator: 'Shift+CmdOrCtrl+Z',\n          role: 'redo',\n        },\n        {\n          type: 'separator',\n        },\n        {\n          label: 'Cut',\n          accelerator: 'CmdOrCtrl+X',\n          role: 'cut',\n        },\n        {\n          label: 'Copy',\n          accelerator: 'CmdOrCtrl+C',\n          role: 'copy',\n        },\n        {\n          label: 'Copy Current URL',\n          accelerator: 'CmdOrCtrl+L',\n          click: () => {\n            const currentURL = getCurrentUrl();\n            clipboard.writeText(currentURL);\n          },\n        },\n        {\n          label: 'Paste',\n          accelerator: 'CmdOrCtrl+V',\n          role: 'paste',\n        },\n        {\n          label: 'Paste and Match Style',\n          accelerator: 'CmdOrCtrl+Shift+V',\n          role: 'pasteandmatchstyle',\n        },\n        {\n          label: 'Select All',\n          accelerator: 'CmdOrCtrl+A',\n          role: 'selectall',\n        },\n      ],\n    },\n    {\n      label: 'View',\n      submenu: [\n        {\n          label: 'Back',\n          accelerator: 'CmdOrCtrl+[',\n          click: () => {\n            goBack();\n          },\n        },\n        {\n          label: 'Forward',\n          accelerator: 'CmdOrCtrl+]',\n          click: () => {\n            goForward();\n          },\n        },\n        {\n          type: 'separator',\n        },\n        {\n          label: 'Toggle Full Screen',\n          accelerator: (() => {\n            if (process.platform === 'darwin') {\n              return 'Ctrl+Command+F';\n            }\n            return 'F11';\n          })(),\n          click: (item, focusedWindow) => {\n            if (focusedWindow) {\n              focusedWindow.setFullScreen(!focusedWindow.isFullScreen());\n            }\n          },\n        },\n        {\n          label: 'Zoom In',\n          accelerator: (() => {\n            if (process.platform === 'darwin') {\n              return 'Command+=';\n            }\n            return 'Ctrl+=';\n          })(),\n          click: () => {\n            zoomIn();\n          },\n        },\n        {\n          label: 'Zoom Out',\n          accelerator: (() => {\n            if (process.platform === 'darwin') {\n              return 'Command+-';\n            }\n            return 'Ctrl+-';\n          })(),\n          click: () => {\n            zoomOut();\n          },\n        },\n        {\n          label: zoomResetLabel,\n          accelerator: (() => {\n            if (process.platform === 'darwin') {\n              return 'Command+0';\n            }\n            return 'Ctrl+0';\n          })(),\n          click: () => {\n            zoomReset();\n          },\n        },\n      ],\n    },\n    {\n      label: 'Privacy',\n      submenu: [\n        {\n          label: 'Flush App Data',\n          click: function click() {\n            clearAppData();\n          },\n        },\n      ],\n    },\n    {\n      label: 'About',\n      submenu: [\n        {\n          label: `GOLEM Engine v${golemVersion}`,\n          click: () => {\n            shell.openExternal('https://github.com/loouislow81/golem-sdk');\n          },\n        },\n        {\n          label: 'Report an Issue',\n          click: () => {\n            shell.openExternal(\n              'https://github.com/loouislow81/golem-sdk/issues',\n            );\n          },\n        },\n        {\n          type: 'separator',\n        },\n        {\n          label: 'Get GOLEM Desktop',\n          click: () => {\n            shell.openExternal('https://github.com/loouislow81/golem-appstore');\n          },\n        },\n        {\n          label: 'Get GOLEM CLI',\n          click: () => {\n            shell.openExternal('https://github.com/loouislow81/golem-cli');\n          },\n        },\n        {\n          type: 'separator',\n        },\n        {\n          label: 'Developer Tools',\n          accelerator: (() => {\n            if (process.platform === 'darwin') {\n              return 'Alt+Command+I';\n            }\n            return 'Ctrl+Shift+I';\n          })(),\n          click: (item, focusedWindow) => {\n            if (focusedWindow) {\n              focusedWindow.toggleDevTools();\n            }\n          },\n        },\n      ],\n    },\n  ];\n\n  if (disableDevTools) {\n    // remove last item (dev tools) from menu > view\n    const { submenu } = template[1];\n    submenu.splice(submenu.length - 1, 1);\n  }\n\n  if (process.platform === 'darwin') {\n    template.unshift({\n      label: 'Electron',\n      submenu: [\n        {\n          label: 'Services',\n          role: 'services',\n          submenu: [],\n        },\n        {\n          type: 'separator',\n        },\n        {\n          label: 'Hide App',\n          accelerator: 'Command+H',\n          role: 'hide',\n        },\n        {\n          label: 'Hide Others',\n          accelerator: 'Command+Shift+H',\n          role: 'hideothers',\n        },\n        {\n          label: 'Show All',\n          role: 'unhide',\n        },\n        {\n          type: 'separator',\n        },\n        {\n          label: 'Quit',\n          accelerator: 'Command+Q',\n          click: () => {\n            appQuit();\n          },\n        },\n      ],\n    });\n    template[3].submenu.push(\n      {\n        type: 'separator',\n      },\n      {\n        label: 'Bring All to Front',\n        role: 'front',\n      },\n    );\n  }\n\n  const menu = Menu.buildFromTemplate(template);\n  Menu.setApplicationMenu(menu);\n}\n\nexport default createMenu;\n","import { shell } from 'electron';\nimport contextMenu from 'electron-context-menu';\n\nfunction initContextMenu(createNewWindow, createNewTab) {\n  contextMenu({\n    prepend: (params) => {\n      const items = [];\n      if (params.linkURL) {\n        items.push({\n          label: 'Open Link in Default Browser',\n          click: () => {\n            shell.openExternal(params.linkURL);\n          },\n        });\n        items.push({\n          label: 'Open Link in New Window',\n          click: () => {\n            createNewWindow(params.linkURL);\n          },\n        });\n        if (createNewTab) {\n          items.push({\n            label: 'Open Link in New Tab',\n            click: () => {\n              createNewTab(params.linkURL, false);\n            },\n          });\n        }\n      }\n      return items;\n    },\n  });\n}\n\nexport default initContextMenu;\n","'use strict';\nconst electron = require('electron');\nconst {download} = require('electron-dl');\nconst isDev = require('electron-is-dev');\n\nconst webContents = win => win.webContents || win.getWebContents();\n\nfunction create(win, options) {\n\twebContents(win).on('context-menu', (event, props) => {\n\t\tif (typeof options.shouldShowMenu === 'function' && options.shouldShowMenu(event, props) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {editFlags} = props;\n\t\tconst hasText = props.selectionText.trim().length > 0;\n\t\tconst can = type => editFlags[`can${type}`] && hasText;\n\n\t\tlet menuTpl = [{\n\t\t\ttype: 'separator'\n\t\t}, {\n\t\t\tid: 'cut',\n\t\t\tlabel: 'Cut',\n\t\t\t// Needed because of macOS limitation:\n\t\t\t// https://github.com/electron/electron/issues/5860\n\t\t\trole: can('Cut') ? 'cut' : '',\n\t\t\tenabled: can('Cut'),\n\t\t\tvisible: props.isEditable\n\t\t}, {\n\t\t\tid: 'copy',\n\t\t\tlabel: 'Copy',\n\t\t\trole: can('Copy') ? 'copy' : '',\n\t\t\tenabled: can('Copy'),\n\t\t\tvisible: props.isEditable || hasText\n\t\t}, {\n\t\t\tid: 'paste',\n\t\t\tlabel: 'Paste',\n\t\t\trole: editFlags.canPaste ? 'paste' : '',\n\t\t\tenabled: editFlags.canPaste,\n\t\t\tvisible: props.isEditable\n\t\t}, {\n\t\t\ttype: 'separator'\n\t\t}];\n\n\t\tif (props.mediaType === 'image') {\n\t\t\tmenuTpl = [{\n\t\t\t\ttype: 'separator'\n\t\t\t}, {\n\t\t\t\tid: 'save',\n\t\t\t\tlabel: 'Save Image',\n\t\t\t\tclick(item, win) {\n\t\t\t\t\tdownload(win, props.srcURL);\n\t\t\t\t}\n\t\t\t}];\n\n\t\t\tif (options.showSaveImageAs) {\n\t\t\t\tmenuTpl.push({\n\t\t\t\t\tid: 'saveImageAs',\n\t\t\t\t\tlabel: 'Save Image As',\n\t\t\t\t\tclick(item, win) {\n\t\t\t\t\t\tdownload(win, props.srcURL, {saveAs: true});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tmenuTpl.push({\n\t\t\t\ttype: 'separator'\n\t\t\t});\n\t\t}\n\n\t\tif (props.linkURL && props.mediaType === 'none') {\n\t\t\tmenuTpl = [{\n\t\t\t\ttype: 'separator'\n\t\t\t}, {\n\t\t\t\tid: 'copyLink',\n\t\t\t\tlabel: 'Copy Link',\n\t\t\t\tclick() {\n\t\t\t\t\telectron.clipboard.write({\n\t\t\t\t\t\tbookmark: props.linkText,\n\t\t\t\t\t\ttext: props.linkURL\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\ttype: 'separator'\n\t\t\t}];\n\t\t}\n\n\t\tif (options.showCopyImageAddress && props.mediaType === 'image') {\n\t\t\tmenuTpl.push({\n\t\t\t\ttype: 'separator'\n\t\t\t}, {\n\t\t\t\tid: 'copyImageAddress',\n\t\t\t\tlabel: 'Copy Image Address',\n\t\t\t\tclick() {\n\t\t\t\t\telectron.clipboard.write({\n\t\t\t\t\t\tbookmark: props.srcURL,\n\t\t\t\t\t\ttext: props.srcURL\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\ttype: 'separator'\n\t\t\t});\n\t\t}\n\n\t\tif (options.prepend) {\n\t\t\tconst result = options.prepend(props, win);\n\n\t\t\tif (Array.isArray(result)) {\n\t\t\t\tmenuTpl.unshift(...result);\n\t\t\t}\n\t\t}\n\n\t\tif (options.append) {\n\t\t\tconst result = options.append(props, win);\n\n\t\t\tif (Array.isArray(result)) {\n\t\t\t\tmenuTpl.push(...result);\n\t\t\t}\n\t\t}\n\n\t\tif (options.showInspectElement || (options.showInspectElement !== false && isDev)) {\n\t\t\tmenuTpl.push({\n\t\t\t\ttype: 'separator'\n\t\t\t}, {\n\t\t\t\tid: 'inspect',\n\t\t\t\tlabel: 'Inspect Element',\n\t\t\t\tclick() {\n\t\t\t\t\twin.inspectElement(props.x, props.y);\n\n\t\t\t\t\tif (webContents(win).isDevToolsOpened()) {\n\t\t\t\t\t\twebContents(win).devToolsWebContents.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\ttype: 'separator'\n\t\t\t});\n\t\t}\n\n\t\t// Apply custom labels for default menu items\n\t\tif (options.labels) {\n\t\t\tfor (const menuItem of menuTpl) {\n\t\t\t\tif (options.labels[menuItem.id]) {\n\t\t\t\t\tmenuItem.label = options.labels[menuItem.id];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filter out leading/trailing separators\n\t\t// TODO: https://github.com/electron/electron/issues/5869\n\t\tmenuTpl = delUnusedElements(menuTpl);\n\n\t\tif (menuTpl.length > 0) {\n\t\t\tconst menu = (electron.remote ? electron.remote.Menu : electron.Menu).buildFromTemplate(menuTpl);\n\n\t\t\t/*\n\t\t\t * When electron.remote is not available this runs in the browser process.\n\t\t\t * We can safely use win in this case as it refers to the window the\n\t\t\t * context-menu should open in.\n\t\t\t * When this is being called from a webView, we can't use win as this\n\t\t\t * would refere to the webView which is not allowed to render a popup menu.\n\t\t\t */\n\t\t\tmenu.popup(electron.remote ? electron.remote.getCurrentWindow() : win);\n\t\t}\n\t});\n}\n\nfunction delUnusedElements(menuTpl) {\n\tlet notDeletedPrevEl;\n\treturn menuTpl.filter(el => el.visible !== false).filter((el, i, array) => {\n\t\tconst toDelete = el.type === 'separator' && (!notDeletedPrevEl || i === array.length - 1 || array[i + 1].type === 'separator');\n\t\tnotDeletedPrevEl = toDelete ? notDeletedPrevEl : el;\n\t\treturn !toDelete;\n\t});\n}\n\nmodule.exports = (options = {}) => {\n\tif (options.window) {\n\t\tconst win = options.window;\n\t\tconst wc = webContents(win);\n\n\t\t// When window is a webview that has not yet finished loading webContents is not available\n\t\tif (wc === undefined) {\n\t\t\twin.addEventListener('dom-ready', () => {\n\t\t\t\tcreate(win, options);\n\t\t\t}, {once: true});\n\t\t\treturn;\n\t\t}\n\n\t\treturn create(win, options);\n\t}\n\n\tfor (const win of (electron.BrowserWindow || electron.remote.BrowserWindow).getAllWindows()) {\n\t\tcreate(win, options);\n\t}\n\n\t(electron.app || electron.remote.app).on('browser-window-created', (event, win) => {\n\t\tcreate(win, options);\n\t});\n};\n","'use strict';\nconst electron = require('electron');\n\nconst app = electron.app || electron.remote.app;\n\nconst isEnvSet = 'ELECTRON_IS_DEV' in process.env;\nconst getFromEnv = parseInt(process.env.ELECTRON_IS_DEV, 10) === 1;\n\nmodule.exports = isEnvSet ? getFromEnv : !app.isPackaged;\n","import helpers from '../../helpers/helpers';\n\nconst { app, Tray, Menu, ipcMain, nativeImage } = require('electron');\n\nconst { getAppIcon, getCounterValue } = helpers;\n\n/**\n *\n * @param {{}} inpOptions AppArgs from golem.json\n * @param {electron.BrowserWindow} mainWindow MainWindow created from main.js\n * @returns {electron.Tray}\n */\nfunction createTrayIcon(inpOptions, mainWindow) {\n  const options = Object.assign({}, inpOptions);\n\n  if (options.tray) {\n    const iconPath = getAppIcon();\n    const nimage = nativeImage.createFromPath(iconPath);\n    const appIcon = new Tray(nimage);\n\n    const onClick = () => {\n      if (mainWindow.isVisible()) {\n        mainWindow.hide();\n      } else {\n        mainWindow.show();\n      }\n    };\n\n    const contextMenu = Menu.buildFromTemplate([\n      {\n        label: options.name,\n        click: onClick,\n      },\n      {\n        label: 'Quit',\n        click: app.exit,\n      },\n    ]);\n\n    appIcon.on('click', onClick);\n\n    mainWindow.on('show', () => {\n      appIcon.setHighlightMode('always');\n    });\n\n    mainWindow.on('hide', () => {\n      appIcon.setHighlightMode('never');\n    });\n\n    if (options.counter) {\n      mainWindow.on('page-title-updated', (e, title) => {\n        const counterValue = getCounterValue(title);\n        if (counterValue) {\n          appIcon.setToolTip(`(${counterValue})  ${options.name}`);\n        } else {\n          appIcon.setToolTip(options.name);\n        }\n      });\n    } else {\n      ipcMain.on('notification', () => {\n        if (mainWindow.isFocused()) {\n          return;\n        }\n        appIcon.setToolTip(`  ${options.name}`);\n      });\n\n      mainWindow.on('focus', () => {\n        appIcon.setToolTip(options.name);\n      });\n    }\n\n    appIcon.setToolTip(options.name);\n    appIcon.setContextMenu(contextMenu);\n\n    return appIcon;\n  }\n\n  return null;\n}\n\nexport default createTrayIcon;\n","import fs from 'fs';\nimport path from 'path';\nimport helpers from './helpers';\n\nconst { isOSX, isWindows, isLinux } = helpers;\nconst log = require('loglevel');\n/**\n * Synchronously find a file or directory\n * @param {RegExp} pattern regex\n * @param {string} base path\n * @param {boolean} [findDir] if true, search results will be limited to only directories\n * @returns {Array}\n */\nfunction findSync(pattern, basePath, findDir) {\n  const matches = [];\n\n  (function findSyncRecurse(base) {\n    let children;\n    try {\n      children = fs.readdirSync(base);\n    } catch (exception) {\n      if (exception.code === 'ENOENT') {\n        return;\n      }\n      throw exception;\n    }\n\n    children.forEach((child) => {\n      const childPath = path.join(base, child);\n      const childIsDirectory = fs.lstatSync(childPath).isDirectory();\n      const patternMatches = pattern.test(childPath);\n\n      if (!patternMatches) {\n        if (!childIsDirectory) {\n          return;\n        }\n        findSyncRecurse(childPath);\n        return;\n      }\n\n      if (!findDir) {\n        matches.push(childPath);\n        return;\n      }\n\n      if (childIsDirectory) {\n        matches.push(childPath);\n      }\n    });\n  })(basePath);\n  return matches;\n}\n\nfunction linuxMatch() {\n  return findSync(/libpepflashplayer\\.so/, '/opt/google/chrome')[0];\n}\n\nfunction windowsMatch() {\n  return findSync(\n    /pepflashplayer\\.dll/,\n    'C:\\\\Program Files (x86)\\\\Google\\\\Chrome',\n  )[0];\n}\n\nfunction darwinMatch() {\n  return findSync(\n    /PepperFlashPlayer.plugin/,\n    '/Applications/Google Chrome.app/',\n    true,\n  )[0];\n}\n\nfunction inferFlash() {\n  if (isOSX()) {\n    return darwinMatch();\n  }\n\n  if (isWindows()) {\n    return windowsMatch();\n  }\n\n  if (isLinux()) {\n    return linuxMatch();\n  }\n\n  log.warn('Unable to determine OS to infer flash player');\n  return null;\n}\nexport default inferFlash;\n","module.exports = require('dat-node')\n","var assert = require('assert')\nvar fs = require('fs')\nvar path = require('path')\nvar hyperdrive = require('hyperdrive')\nvar resolveDatLink = require('dat-link-resolve')\nvar debug = require('debug')('dat-node')\nvar datStore = require('./lib/storage')\nvar Dat = require('./dat')\n\nmodule.exports = createDat\n\n/**\n * Create a Dat instance, archive storage, and ready the archive.\n * @param {string|object} dirOrStorage - Directory or hyperdrive storage object.\n * @param {object} [opts] - Dat-node options and any hyperdrive init options.\n * @param {String|Buffer} [opts.key] - Hyperdrive key\n * @param {Boolean} [opts.createIfMissing = true] - Create storage if it does not exit.\n * @param {Boolean} [opts.errorIfExists = false] - Error if storage exists.\n * @param {Boolean} [opts.temp = false] - Use random-access-memory for temporary storage\n * @param {function(err, dat)} cb - callback that returns `Dat` instance\n * @see defaultStorage for storage information\n */\nfunction createDat (dirOrStorage, opts, cb) {\n  if (!cb) {\n    cb = opts\n    opts = {}\n  }\n  assert.ok(dirOrStorage, 'dat-node: directory or storage required')\n  assert.strictEqual(typeof opts, 'object', 'dat-node: opts should be type object')\n  assert.strictEqual(typeof cb, 'function', 'dat-node: callback required')\n\n  var archive\n  var key = opts.key\n  var dir = (typeof dirOrStorage === 'string') ? dirOrStorage : null\n  var storage = datStore(dirOrStorage, opts)\n  var createIfMissing = !(opts.createIfMissing === false)\n  var errorIfExists = opts.errorIfExists || false\n  var hasDat = false\n  opts = Object.assign({\n    // TODO: make sure opts.dir is a directory, not file\n    dir: dir,\n    latest: true\n  }, opts)\n\n  if (!opts.dir) return create() // TODO: check other storage\n  checkIfExists()\n\n  /**\n   * Check if archive storage folder exists.\n   * @private\n   */\n  function checkIfExists () {\n    // Create after we check for pre-sleep .dat stuff\n    var createAfterValid = (createIfMissing && !errorIfExists)\n\n    var missingError = new Error('Dat storage does not exist.')\n    missingError.name = 'MissingError'\n    var existsError = new Error('Dat storage already exists.')\n    existsError.name = 'ExistsError'\n    var oldError = new Error('Dat folder contains incompatible metadata. Please remove your metadata (rm -rf .dat).')\n    oldError.name = 'IncompatibleError'\n\n    fs.readdir(path.join(opts.dir, '.dat'), function (err, files) {\n      // TODO: omg please make this less confusing.\n      var noDat = !!(err || !files.length)\n      hasDat = !noDat\n      var validSleep = (files && files.length && files.indexOf('metadata.key') > -1)\n      var badDat = !(noDat || validSleep)\n\n      if ((noDat || validSleep) && createAfterValid) return create()\n      else if (badDat) return cb(oldError)\n\n      if (err && !createIfMissing) return cb(missingError)\n      else if (!err && errorIfExists) return cb(existsError)\n\n      return create()\n    })\n  }\n\n  /**\n   * Create the archive and call `archive.ready()` before callback.\n   * Set `archive.resumed` if archive has a content feed.\n   * @private\n   */\n  function create () {\n    if (dir && !opts.temp && !key && (opts.indexing !== false)) {\n      // Only set opts.indexing if storage is dat-storage\n      // TODO: this should be an import option instead, https://github.com/mafintosh/hyperdrive/issues/160\n      opts.indexing = true\n    }\n    if (!key) return createArchive()\n\n    resolveDatLink(key, function (err, resolvedKey) {\n      if (err) return cb(err)\n      key = resolvedKey\n      createArchive()\n    })\n\n    function createArchive () {\n      archive = hyperdrive(storage, key, opts)\n      archive.on('error', cb)\n      archive.ready(function () {\n        debug('archive ready. version:', archive.version)\n        if (hasDat || (archive.metadata.has(0) && archive.version)) {\n          archive.resumed = true\n        } else {\n          archive.resumed = false\n        }\n        archive.removeListener('error', cb)\n\n        cb(null, new Dat(archive, opts))\n      })\n    }\n  }\n}\n","var hypercore = require('hypercore')\nvar mutexify = require('mutexify')\nvar raf = require('random-access-file')\nvar thunky = require('thunky')\nvar tree = require('append-tree')\nvar collect = require('stream-collector')\nvar sodium = require('sodium-universal')\nvar inherits = require('inherits')\nvar events = require('events')\nvar duplexify = require('duplexify')\nvar from = require('from2')\nvar each = require('stream-each')\nvar uint64be = require('uint64be')\nvar unixify = require('unixify')\nvar path = require('path')\nvar messages = require('./lib/messages')\nvar stat = require('./lib/stat')\nvar cursor = require('./lib/cursor')\n\nvar DEFAULT_FMODE = (4 | 2 | 0) << 6 | ((4 | 0 | 0) << 3) | (4 | 0 | 0) // rw-r--r--\nvar DEFAULT_DMODE = (4 | 2 | 1) << 6 | ((4 | 0 | 1) << 3) | (4 | 0 | 1) // rwxr-xr-x\n\nmodule.exports = Hyperdrive\n\nfunction Hyperdrive (storage, key, opts) {\n  if (!(this instanceof Hyperdrive)) return new Hyperdrive(storage, key, opts)\n  events.EventEmitter.call(this)\n\n  if (isObject(key)) {\n    opts = key\n    key = null\n  }\n\n  if (!opts) opts = {}\n\n  this.key = null\n  this.discoveryKey = null\n  this.live = true\n  this.latest = !!opts.latest\n\n  this._storages = defaultStorage(this, storage, opts)\n\n  this.metadata = opts.metadata || hypercore(this._storages.metadata, key, {\n    secretKey: opts.secretKey,\n    sparse: opts.sparseMetadata,\n    createIfMissing: opts.createIfMissing,\n    storageCacheSize: opts.metadataStorageCacheSize\n  })\n  this.content = opts.content || null\n  this.maxRequests = opts.maxRequests || 16\n  this.readable = true\n\n  this.storage = storage\n  this.tree = tree(this.metadata, {\n    offset: 1,\n    valueEncoding: messages.Stat,\n    cache: opts.treeCacheSize !== 0,\n    cacheSize: opts.treeCacheSize\n  })\n  if (typeof opts.version === 'number') this.tree = this.tree.checkout(opts.version)\n  this.sparse = !!opts.sparse\n  this.sparseMetadata = !!opts.sparseMetadata\n  this.indexing = !!opts.indexing\n  this.contentStorageCacheSize = opts.contentStorageCacheSize\n\n  this._latestSynced = 0\n  this._latestVersion = 0\n  this._latestStorage = this.latest ? this._storages.metadata('latest') : null\n  this._checkout = opts._checkout\n  this._lock = mutexify()\n\n  this._openFiles = []\n  this._emittedContent = false\n  this._closed = false\n\n  var self = this\n\n  this.metadata.on('append', update)\n  this.metadata.on('error', onerror)\n  this.ready = thunky(open)\n  this.ready(onready)\n\n  function onready (err) {\n    if (err) return onerror(err)\n    self.emit('ready')\n    self._oncontent()\n    if (self.latest && !self.metadata.writable) {\n      self._trackLatest(function (err) {\n        if (self._closed) return\n        onerror(err)\n      })\n    }\n  }\n\n  function onerror (err) {\n    if (err) self.emit('error', err)\n  }\n\n  function update () {\n    self.emit('update')\n  }\n\n  function open (cb) {\n    self._open(cb)\n  }\n}\n\ninherits(Hyperdrive, events.EventEmitter)\n\nObject.defineProperty(Hyperdrive.prototype, 'version', {\n  enumerable: true,\n  get: function () {\n    return this._checkout ? this.tree.version : (this.metadata.length ? this.metadata.length - 1 : 0)\n  }\n})\n\nObject.defineProperty(Hyperdrive.prototype, 'writable', {\n  enumerable: true,\n  get: function () {\n    return this.metadata.writable\n  }\n})\n\nHyperdrive.prototype._oncontent = function () {\n  if (!this.content || this._emittedContent) return\n  this._emittedContent = true\n  this.emit('content')\n}\n\nHyperdrive.prototype._trackLatest = function (cb) {\n  var self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    self._latestStorage.read(0, 8, function (_, data) {\n      self._latestVersion = data ? uint64be.decode(data) : 0\n      loop()\n    })\n  })\n\n  function loop (err) {\n    if (err) return cb(err)\n\n    if (stableVersion()) return fetch()\n\n    // TODO: lock downloading while doing this\n    self._clearDangling(self._latestVersion, self.version, onclear)\n  }\n\n  function fetch () {\n    if (self.sparse) {\n      if (stableVersion()) return self.metadata.update(loop)\n      return loop(null)\n    }\n\n    self.emit('syncing')\n    self._fetchVersion(self._latestSynced, function (err, fullySynced) {\n      if (err) return cb(err)\n\n      if (fullySynced) {\n        self._latestSynced = self._latestVersion\n        self.emit('sync')\n        if (!self._checkout) self.metadata.update(loop) // TODO: only if live\n        return\n      }\n\n      loop(null)\n    })\n  }\n\n  function onclear (err, version) {\n    if (err) return cb(err)\n    self._latestVersion = version\n    self._latestStorage.write(0, uint64be.encode(self._latestVersion), loop)\n  }\n\n  function stableVersion () {\n    var latest = self.version\n    return latest < 0 || self._latestVersion === latest\n  }\n}\n\nHyperdrive.prototype._fetchVersion = function (prev, cb) {\n  var self = this\n  var version = self.version\n  var updated = false\n  var done = false\n  var error = null\n  var stream = null\n  var queued = 0\n  var maxQueued = 64\n\n  var waitingData = null\n  var waitingCallback = null\n\n  this.metadata.update(function () {\n    updated = true\n    queued = 0\n    if (stream) stream.destroy()\n    kick()\n  })\n\n  this._ensureContent(function (err) {\n    if (err) return cb(err)\n    if (updated) return cb(null, false)\n\n    // var snapshot = self.checkout(version)\n    stream = self.tree.checkout(prev).diff(version, {puts: true, dels: false})\n    each(stream, ondata, ondone)\n  })\n\n  function ondata (data, next) {\n    if (updated || error) return callAndKick(next, new Error('Out of date'))\n\n    if (queued >= maxQueued) {\n      waitingData = data\n      waitingCallback = next\n      return\n    }\n\n    var start = data.value.offset\n    var end = start + data.value.blocks\n\n    if (start === end) return callAndKick(next, null)\n\n    queued++\n    self.content.download({start: start, end: end}, function (err) {\n      if (updated && !waitingCallback) return kick()\n      if (!updated) queued--\n\n      if (waitingCallback) {\n        data = waitingData\n        waitingData = null\n        next = waitingCallback\n        waitingCallback = null\n        return ondata(data, next)\n      }\n\n      if (err) {\n        stream.destroy(err)\n        error = err\n      }\n\n      kick()\n    })\n\n    process.nextTick(next)\n  }\n\n  function callAndKick (next, err) {\n    next(err)\n    kick()\n  }\n\n  function kick () {\n    if (!done || queued) return\n    queued = -1 // so we don't enter this twice\n\n    if (updated) return cb(null, false)\n    if (error) return cb(error)\n\n    cb(null, version === self.version)\n  }\n\n  function ondone (err) {\n    if (err) error = err\n    done = true\n    kick()\n  }\n}\n\nHyperdrive.prototype._clearDangling = function (a, b, cb) {\n  var current = this.tree.checkout(a, {cached: true})\n  var latest = this.tree.checkout(b)\n  var stream = current.diff(latest, {dels: true, puts: false})\n  var self = this\n\n  this._ensureContent(oncontent)\n\n  function done (err) {\n    if (err) return cb(err)\n    cb(null, b)\n  }\n\n  function oncontent (err) {\n    if (err) return cb(err)\n    each(stream, ondata, done)\n  }\n\n  function ondata (data, next) {\n    var st = data.value\n    self.content.cancel(st.offset, st.offset + st.blocks)\n    self.content.clear(st.offset, st.offset + st.blocks, {byteOffset: st.byteOffset, byteLength: st.size}, next)\n  }\n}\n\nHyperdrive.prototype.replicate = function (opts) {\n  if (!opts) opts = {}\n\n  opts.expectedFeeds = 2\n\n  var self = this\n  var stream = this.metadata.replicate(opts)\n\n  this._ensureContent(function (err) {\n    if (err) return stream.destroy(err)\n    if (stream.destroyed) return\n    self.content.replicate({\n      live: opts.live,\n      download: opts.download,\n      upload: opts.upload,\n      stream: stream\n    })\n  })\n\n  return stream\n}\n\nHyperdrive.prototype.checkout = function (version, opts) {\n  if (!opts) opts = {}\n  opts._checkout = this._checkout || this\n  opts.metadata = this.metadata\n  opts.version = version\n  return Hyperdrive(null, null, opts)\n}\n\nHyperdrive.prototype.createDiffStream = function (version, opts) {\n  if (!version) version = 0\n  if (typeof version === 'number') version = this.checkout(version)\n  return this.tree.diff(version.tree, opts)\n}\n\nHyperdrive.prototype.download = function (dir, cb) {\n  if (typeof dir === 'function') return this.download('/', dir)\n\n  var downloadCount = 1\n  var self = this\n\n  download(dir || '/')\n\n  function download (entry) {\n    self.stat(entry, function (err, stat) {\n      if (err) {\n        if (cb) cb(err)\n        return\n      }\n      if (stat.isDirectory()) return downloadDir(entry, stat)\n      if (stat.isFile()) return downloadFile(entry, stat)\n    })\n  }\n\n  function downloadDir (dirname, stat) {\n    self.readdir(dirname, function (err, entries) {\n      if (err) {\n        if (cb) cb(err)\n        return\n      }\n      downloadCount -= 1\n      downloadCount += entries.length\n      entries.forEach(function (entry) {\n        download(path.join(dirname, entry))\n      })\n      if (downloadCount <= 0 && cb) cb()\n    })\n  }\n\n  function downloadFile (entry, stat) {\n    var start = stat.offset\n    var end = stat.offset + stat.blocks\n    if (start === 0 && end === 0) return\n    self.content.download({start, end}, function () {\n      downloadCount -= 1\n      if (downloadCount <= 0 && cb) cb()\n    })\n  }\n}\n\nHyperdrive.prototype.history = function (opts) {\n  return this.tree.history(opts)\n}\n\nHyperdrive.prototype.createCursor = function (name, opts) {\n  return cursor(this, name, opts)\n}\n\n// open -> fd\nHyperdrive.prototype.open = function (name, flags, mode, opts, cb) {\n  if (typeof mode === 'object' && mode) return this.open(name, flags, 0, mode, opts)\n  if (typeof mode === 'function') return this.open(name, flags, 0, mode)\n  if (typeof opts === 'function') return this.open(name, flags, mode, null, opts)\n\n  // TODO: use flags, only readable cursors are supported atm\n  var cursor = this.createCursor(name, opts)\n  var self = this\n\n  cursor.open(function (err) {\n    if (err) return cb(err)\n\n    var fd = self._openFiles.indexOf(null)\n    if (fd === -1) fd = self._openFiles.push(null) - 1\n\n    self._openFiles[fd] = cursor\n    cb(null, fd + 20) // offset all fds with 20, unsure what the actual good offset is\n  })\n}\n\nHyperdrive.prototype.read = function (fd, buf, offset, len, pos, cb) {\n  var cursor = this._openFiles[fd - 20]\n  if (!cursor) return cb(new Error('Bad file descriptor'))\n\n  if (pos !== null) cursor.seek(pos)\n\n  cursor.next(function (err, next) {\n    if (err) return cb(err)\n\n    if (!next) return cb(null, 0, buf)\n\n    // if we read too much\n    if (next.length > len) {\n      next = next.slice(0, len)\n      cursor.seek(pos + len)\n    }\n\n    next.copy(buf, offset, 0, len)\n    cb(null, next.length, buf)\n  })\n}\n\n// TODO: move to ./lib\nHyperdrive.prototype.createReadStream = function (name, opts) {\n  if (!opts) opts = {}\n\n  name = unixify(name)\n\n  var self = this\n  var downloaded = false\n  var first = true\n  var start = 0\n  var end = 0\n  var offset = 0\n  var length = typeof opts.end === 'number' ? 1 + opts.end - (opts.start || 0) : typeof opts.length === 'number' ? opts.length : -1\n  var range = null\n  var ended = false\n  var stream = from(read)\n  var cached = opts && !!opts.cached\n\n  stream.on('close', cleanup)\n  stream.on('end', cleanup)\n\n  return stream\n\n  function cleanup () {\n    if (range) self.content.undownload(range, noop)\n    range = null\n    ended = true\n  }\n\n  function read (size, cb) {\n    if (first) return open(size, cb)\n    if (start === end || length === 0) return cb(null, null)\n\n    self.content.get(start++, {wait: !downloaded && !cached}, function (err, data) {\n      if (err) return cb(err)\n      if (offset) data = data.slice(offset)\n      offset = 0\n      if (length > -1) {\n        if (length < data.length) data = data.slice(0, length)\n        length -= data.length\n      }\n      cb(null, data)\n    })\n  }\n\n  function open (size, cb) {\n    first = false\n    self._ensureContent(function (err) {\n      if (err) return cb(err)\n\n      // if running latest === true and a delete happens while getting the tree data, the tree.get\n      // should finish before the delete so there shouldn't be an rc. we should test this though.\n      self.tree.get(name, ontree)\n\n      function ontree (err, stat) {\n        if (err) return cb(err)\n        if (ended || stream.destroyed) return\n\n        start = stat.offset\n        end = stat.offset + stat.blocks\n\n        var byteOffset = stat.byteOffset\n        var missing = 1\n\n        if (opts.start) self.content.seek(byteOffset + opts.start, {start: start, end: end}, onstart)\n        else onstart(null, start, 0)\n\n        function onend (err, index) {\n          if (err || !range) return\n          if (ended || stream.destroyed) return\n\n          missing++\n          self.content.undownload(range)\n          range = self.content.download({start: start, end: index, linear: true}, ondownload)\n        }\n\n        function onstart (err, index, off) {\n          if (err) return cb(err)\n          if (ended || stream.destroyed) return\n\n          offset = off\n          start = index\n          range = self.content.download({start: start, end: end, linear: true}, ondownload)\n\n          if (length > -1 && length < stat.size) {\n            self.content.seek(byteOffset + length, {start: start, end: end}, onend)\n          }\n\n          read(size, cb)\n        }\n\n        function ondownload (err) {\n          if (--missing) return\n          if (err && !ended && !downloaded) stream.destroy(err)\n          else downloaded = true\n        }\n      }\n    })\n  }\n}\n\nHyperdrive.prototype.readFile = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.readFile(name, null, opts)\n  if (typeof opts === 'string') opts = {encoding: opts}\n  if (!opts) opts = {}\n\n  name = unixify(name)\n\n  collect(this.createReadStream(name, opts), function (err, bufs) {\n    if (err) return cb(err)\n    var buf = bufs.length === 1 ? bufs[0] : Buffer.concat(bufs)\n    cb(null, opts.encoding && opts.encoding !== 'binary' ? buf.toString(opts.encoding) : buf)\n  })\n}\n\nHyperdrive.prototype.createWriteStream = function (name, opts) {\n  if (!opts) opts = {}\n\n  name = unixify(name)\n\n  var self = this\n  var proxy = duplexify()\n\n  // TODO: support piping through a \"split\" stream like rabin\n\n  proxy.setReadable(false)\n  this._ensureContent(function (err) {\n    if (err) return proxy.destroy(err)\n    if (self._checkout) return proxy.destroy(new Error('Cannot write to a checkout'))\n    if (proxy.destroyed) return\n\n    self._lock(function (release) {\n      if (!self.latest || proxy.destroyed) return append(null)\n\n      self.tree.get(name, function (err, st) {\n        if (err && err.notFound) return append(null)\n        if (err) return append(err)\n        if (!st.size) return append(null)\n        self.content.clear(st.offset, st.offset + st.blocks, append)\n      })\n\n      function append (err) {\n        if (err) proxy.destroy(err)\n        if (proxy.destroyed) return release()\n\n        // No one should mutate the content other than us\n        var byteOffset = self.content.byteLength\n        var offset = self.content.length\n\n        self.emit('appending', name, opts)\n\n        // TODO: revert the content feed if this fails!!!! (add an option to the write stream for this (atomic: true))\n        var stream = self.content.createWriteStream()\n\n        proxy.on('close', done)\n        proxy.on('finish', done)\n\n        proxy.setWritable(stream)\n        proxy.on('prefinish', function () {\n          var st = {\n            mode: (opts.mode || DEFAULT_FMODE) | stat.IFREG,\n            uid: opts.uid || 0,\n            gid: opts.gid || 0,\n            size: self.content.byteLength - byteOffset,\n            blocks: self.content.length - offset,\n            offset: offset,\n            byteOffset: byteOffset,\n            mtime: getTime(opts.mtime),\n            ctime: getTime(opts.ctime)\n          }\n\n          proxy.cork()\n          self.tree.put(name, st, function (err) {\n            if (err) return proxy.destroy(err)\n            self.emit('append', name, opts)\n            proxy.uncork()\n          })\n        })\n      }\n\n      function done () {\n        proxy.removeListener('close', done)\n        proxy.removeListener('finish', done)\n        release()\n      }\n    })\n  })\n\n  return proxy\n}\n\nHyperdrive.prototype.writeFile = function (name, buf, opts, cb) {\n  if (typeof opts === 'function') return this.writeFile(name, buf, null, opts)\n  if (typeof opts === 'string') opts = {encoding: opts}\n  if (!opts) opts = {}\n  if (typeof buf === 'string') buf = new Buffer(buf, opts.encoding || 'utf-8')\n  if (!cb) cb = noop\n\n  name = unixify(name)\n\n  var bufs = split(buf) // split the input incase it is a big buffer.\n  var stream = this.createWriteStream(name, opts)\n  stream.on('error', cb)\n  stream.on('finish', cb)\n  for (var i = 0; i < bufs.length; i++) stream.write(bufs[i])\n  stream.end()\n}\n\nHyperdrive.prototype.mkdir = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.mkdir(name, null, opts)\n  if (typeof opts === 'number') opts = {mode: opts}\n  if (!opts) opts = {}\n  if (!cb) cb = noop\n\n  name = unixify(name)\n\n  var self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (self._checkout) return cb(new Error('Cannot write to a checkout'))\n\n    self._lock(function (release) {\n      var st = {\n        mode: (opts.mode || DEFAULT_DMODE) | stat.IFDIR,\n        uid: opts.uid,\n        gid: opts.gid,\n        mtime: getTime(opts.mtime),\n        ctime: getTime(opts.ctime),\n        offset: self.content.length,\n        byteOffset: self.content.byteLength\n      }\n\n      self.tree.put(name, st, function (err) {\n        release(cb, err)\n      })\n    })\n  })\n}\n\nHyperdrive.prototype._statDirectory = function (name, opts, cb) {\n  this.tree.list(name, opts, function (err, list) {\n    if (name !== '/' && (err || !list.length)) return cb(err || new Error(name + ' could not be found'))\n    var st = stat()\n    st.mode = stat.IFDIR | DEFAULT_DMODE\n    cb(null, st)\n  })\n}\n\nHyperdrive.prototype.access = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.access(name, null, opts)\n  if (!opts) opts = {}\n  name = unixify(name)\n  this.stat(name, opts, function (err) {\n    cb(err)\n  })\n}\n\nHyperdrive.prototype.exists = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.exists(name, null, opts)\n  if (!opts) opts = {}\n  this.access(name, opts, function (err) {\n    cb(!err)\n  })\n}\n\nHyperdrive.prototype.lstat = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.lstat(name, null, opts)\n  if (!opts) opts = {}\n  var self = this\n\n  name = unixify(name)\n\n  this.tree.get(name, opts, function (err, st) {\n    if (err) return self._statDirectory(name, opts, cb)\n    cb(null, stat(st))\n  })\n}\n\nHyperdrive.prototype.stat = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.stat(name, null, opts)\n  if (!opts) opts = {}\n  this.lstat(name, opts, cb)\n}\n\nHyperdrive.prototype.readdir = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.readdir(name, null, opts)\n\n  name = unixify(name)\n\n  if (name === '/') return this._readdirRoot(opts, cb) // TODO: should be an option in append-tree prob\n  this.tree.list(name, opts, cb)\n}\n\nHyperdrive.prototype._readdirRoot = function (opts, cb) {\n  this.tree.list('/', opts, function (_, list) {\n    if (list) return cb(null, list)\n    cb(null, [])\n  })\n}\n\nHyperdrive.prototype.unlink = function (name, cb) {\n  name = unixify(name)\n  this._del(name, cb || noop)\n}\n\nHyperdrive.prototype.rmdir = function (name, cb) {\n  if (!cb) cb = noop\n\n  name = unixify(name)\n\n  var self = this\n\n  this.readdir(name, function (err, list) {\n    if (err) return cb(err)\n    if (list.length) return cb(new Error('Directory is not empty'))\n    self._del(name, cb)\n  })\n}\n\nHyperdrive.prototype._del = function (name, cb) {\n  var self = this\n\n  this._ensureContent(function (err) {\n    if (err) return cb(err)\n\n    self._lock(function (release) {\n      if (!self.latest) return del(null)\n      self.tree.get(name, function (err, value) {\n        if (err) return done(err)\n        self.content.clear(value.offset, value.offset + value.blocks, del)\n      })\n\n      function del (err) {\n        if (err) return done(err)\n        self.tree.del(name, done)\n      }\n\n      function done (err) {\n        release(cb, err)\n      }\n    })\n  })\n}\n\nHyperdrive.prototype._closeFile = function (fd, cb) {\n  var cursor = this._openFiles[fd - 20]\n  if (!cursor) return cb(new Error('Bad file descriptor'))\n  this._openFiles[fd - 20] = null\n  cursor.close(cb)\n}\n\nHyperdrive.prototype.close = function (fd, cb) {\n  if (typeof fd === 'number') return this._closeFile(fd, cb || noop)\n  else cb = fd\n  if (!cb) cb = noop\n\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._closed = true\n    self.metadata.close(function (err) {\n      if (!self.content) return cb(err)\n      self.content.close(cb)\n    })\n  })\n}\n\nHyperdrive.prototype._ensureContent = function (cb) {\n  var self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (!self.content) return self._loadIndex(cb)\n    cb(null)\n  })\n}\n\nHyperdrive.prototype._loadIndex = function (cb) {\n  var self = this\n\n  if (this._checkout) this._checkout._loadIndex(done)\n  else this.metadata.get(0, {valueEncoding: messages.Index}, done)\n\n  function done (err, index) {\n    if (err) return cb(err)\n    if (self.content) return self.content.ready(cb)\n\n    var keyPair = self.metadata.writable && contentKeyPair(self.metadata.secretKey)\n    var opts = contentOptions(self, keyPair && keyPair.secretKey)\n    self.content = self._checkout ? self._checkout.content : hypercore(self._storages.content, index.content, opts)\n    self.content.on('error', function (err) {\n      self.emit('error', err)\n    })\n    self.content.ready(function (err) {\n      if (err) return cb(err)\n      self._oncontent()\n      cb()\n    })\n  }\n}\n\nHyperdrive.prototype._open = function (cb) {\n  var self = this\n\n  this.tree.ready(function (err) {\n    if (err) return cb(err)\n    self.metadata.ready(function (err) {\n      if (err) return cb(err)\n      if (self.content) return cb(null)\n\n      self.key = self.metadata.key\n      self.discoveryKey = self.metadata.discoveryKey\n\n      if (!self.metadata.writable || self._checkout) onnotwriteable()\n      else onwritable()\n    })\n  })\n\n  function onnotwriteable () {\n    if (self.metadata.has(0)) return self._loadIndex(cb)\n    self._loadIndex(noop)\n    cb()\n  }\n\n  function onwritable () {\n    var wroteIndex = self.metadata.has(0)\n    if (wroteIndex) return self._loadIndex(cb)\n\n    if (!self.content) {\n      var keyPair = contentKeyPair(self.metadata.secretKey)\n      var opts = contentOptions(self, keyPair.secretKey)\n      self.content = hypercore(self._storages.content, keyPair.publicKey, opts)\n      self.content.on('error', function (err) {\n        self.emit('error', err)\n      })\n    }\n\n    self.content.ready(function () {\n      if (self.metadata.has(0)) return cb(new Error('Index already written'))\n      self.metadata.append(messages.Index.encode({type: 'hyperdrive', content: self.content.key}), cb)\n    })\n  }\n}\n\nfunction contentOptions (self, secretKey) {\n  return {\n    sparse: self.sparse || self.latest,\n    maxRequests: self.maxRequests,\n    secretKey: secretKey,\n    storeSecretKey: false,\n    indexing: self.metadata.writable && self.indexing,\n    storageCacheSize: self.contentStorageCacheSize\n  }\n}\n\nfunction isObject (val) {\n  return !!val && typeof val !== 'string' && !Buffer.isBuffer(val)\n}\n\nfunction wrap (self, storage) {\n  return {\n    metadata: function (name, opts) {\n      return storage.metadata(name, opts, self)\n    },\n    content: function (name, opts) {\n      return storage.content(name, opts, self)\n    }\n  }\n}\n\nfunction defaultStorage (self, storage, opts) {\n  var folder = ''\n\n  if (typeof storage === 'object' && storage) return wrap(self, storage)\n\n  if (typeof storage === 'string') {\n    folder = storage\n    storage = raf\n  }\n\n  return {\n    metadata: function (name) {\n      return storage(path.join(folder, 'metadata', name))\n    },\n    content: function (name) {\n      return storage(path.join(folder, 'content', name))\n    }\n  }\n}\n\nfunction noop () {}\n\nfunction split (buf) {\n  var list = []\n  for (var i = 0; i < buf.length; i += 65536) {\n    list.push(buf.slice(i, i + 65536))\n  }\n  return list\n}\n\nfunction getTime (date) {\n  if (typeof date === 'number') return date\n  if (!date) return Date.now()\n  return date.getTime()\n}\n\nfunction contentKeyPair (secretKey) {\n  var seed = new Buffer(sodium.crypto_sign_SEEDBYTES)\n  var context = new Buffer('hyperdri') // 8 byte context\n  var keyPair = {\n    publicKey: new Buffer(sodium.crypto_sign_PUBLICKEYBYTES),\n    secretKey: new Buffer(sodium.crypto_sign_SECRETKEYBYTES)\n  }\n\n  sodium.crypto_kdf_derive_from_key(seed, 1, context, secretKey)\n  sodium.crypto_sign_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed)\n  if (seed.fill) seed.fill(0)\n\n  return keyPair\n}\n","var equals = require('buffer-equals')\nvar low = require('last-one-wins')\nvar remove = require('unordered-array-remove')\nvar set = require('unordered-set')\nvar merkle = require('merkle-tree-stream/generator')\nvar flat = require('flat-tree')\nvar bulk = require('bulk-write-stream')\nvar from = require('from2')\nvar codecs = require('codecs')\nvar thunky = require('thunky')\nvar batcher = require('atomic-batcher')\nvar inherits = require('inherits')\nvar events = require('events')\nvar raf = require('random-access-file')\nvar bitfield = require('./lib/bitfield')\nvar sparseBitfield = require('sparse-bitfield')\nvar treeIndex = require('./lib/tree-index')\nvar storage = require('./lib/storage')\nvar crypto = require('hypercore-crypto')\nvar nextTick = require('process-nextick-args')\nvar bufferFrom = require('buffer-from')\nvar bufferAlloc = require('buffer-alloc-unsafe')\nvar inspect = require('inspect-custom-symbol')\nvar pretty = require('pretty-hash')\nvar replicate = null\n\nmodule.exports = Feed\n\nfunction Feed (createStorage, key, opts) {\n  if (!(this instanceof Feed)) return new Feed(createStorage, key, opts)\n  events.EventEmitter.call(this)\n\n  if (typeof createStorage === 'string') createStorage = defaultStorage(createStorage)\n  if (typeof createStorage !== 'function') throw new Error('Storage should be a function or string')\n\n  if (typeof key === 'string') key = bufferFrom(key, 'hex')\n\n  if (!Buffer.isBuffer(key) && !opts) {\n    opts = key\n    key = null\n  }\n\n  if (!opts) opts = {}\n\n  var self = this\n\n  var secretKey = opts.secretKey || null\n  if (typeof secretKey === 'string') secretKey = bufferFrom(secretKey, 'hex')\n\n  this.id = opts.id || crypto.randomBytes(32)\n  this.live = opts.live !== false\n  this.sparse = !!opts.sparse\n  this.length = 0\n  this.byteLength = 0\n  this.maxRequests = opts.maxRequests || 16\n  this.key = key || opts.key || null\n  this.discoveryKey = this.key && crypto.discoveryKey(this.key)\n  this.secretKey = secretKey\n  this.bitfield = null\n  this.tree = null\n  this.writable = !!opts.writable\n  this.readable = true\n  this.opened = false\n  this.closed = false\n  this.allowPush = !!opts.allowPush\n  this.peers = []\n\n  // hooks\n  this._onwrite = opts.onwrite || null\n\n  this._ready = thunky(open) // TODO: if open fails, do not reopen next time\n  this._indexing = !!opts.indexing\n  this._createIfMissing = opts.createIfMissing !== false\n  this._overwrite = !!opts.overwrite\n  this._storeSecretKey = opts.storeSecretKey !== false\n  this._merkle = null\n  this._storage = storage(createStorage, opts.storageCacheSize)\n  this._batch = batcher(this._onwrite ? workHook : work)\n\n  this._seq = 0\n  this._waiting = []\n  this._selections = []\n  this._reserved = sparseBitfield()\n  this._synced = null\n\n  this._codec = toCodec(opts.valueEncoding)\n  this._sync = low(sync)\n  if (!this.sparse) this.download({start: 0, end: -1})\n\n  // open it right away. TODO: do not reopen (i.e, set a flag not to retry)\n  this._ready(onerror)\n\n  function onerror (err) {\n    if (err) self.emit('error', err)\n  }\n\n  function workHook (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb)\n    self._appendHook(values, cb)\n  }\n\n  function work (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb)\n    self._append(values, cb)\n  }\n\n  function sync (_, cb) {\n    self._syncBitfield(cb)\n  }\n\n  function open (cb) {\n    self._open(cb)\n  }\n}\n\ninherits(Feed, events.EventEmitter)\n\nFeed.discoveryKey = crypto.discoveryKey\n\nFeed.prototype[inspect] = function (depth, opts) {\n  var indent = ''\n  if (typeof opts.indentationLvl === 'number') {\n    while (indent.length < opts.indentationLvl) indent += ' '\n  }\n  return 'Hypercore(\\n' +\n    indent + '  key: ' + opts.stylize((this.key && pretty(this.key)), 'string') + '\\n' +\n    indent + '  discoveryKey: ' + opts.stylize((this.discoveryKey && pretty(this.discoveryKey)), 'string') + '\\n' +\n    indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\\n' +\n    indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\\n' +\n    indent + '  length: ' + opts.stylize(this.length, 'number') + '\\n' +\n    indent + '  byteLength: ' + opts.stylize(this.byteLength, 'number') + '\\n' +\n    indent + '  peers: ' + opts.stylize(this.peers.length, 'number') + '\\n' +\n    indent + ')'\n}\n\n// TODO: instead of using a getter, update on remote-update/add/remove\nObject.defineProperty(Feed.prototype, 'remoteLength', {\n  enumerable: true,\n  get: function () {\n    var len = 0\n    for (var i = 0; i < this.peers.length; i++) {\n      var remoteLength = this.peers[i].remoteLength\n      if (remoteLength > len) len = remoteLength\n    }\n    return len\n  }\n})\n\nFeed.prototype.replicate = function (opts) {\n  // Lazy load replication deps\n  if (!replicate) replicate = require('./lib/replicate')\n\n  if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {\n    // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection\n    this.download({start: 0, end: -1})\n  }\n\n  return replicate(this, opts || {})\n}\n\nFeed.prototype.ready = function (onready) {\n  this._ready(function (err) {\n    if (!err) onready()\n  })\n}\n\nFeed.prototype.update = function (len, cb) {\n  if (typeof len === 'function') return this.update(-1, len)\n  if (typeof len !== 'number') len = -1\n  if (!cb) cb = noop\n\n  var self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (len === -1) len = self.length + 1\n    if (self.length >= len) return cb(null)\n\n    if (self.writable) cb = self._writeStateReloader(cb)\n\n    self._waiting.push({\n      hash: true,\n      bytes: 0,\n      index: len - 1,\n      update: true,\n      callback: cb\n    })\n\n    self._updatePeers()\n  })\n}\n\n// will reload the writable state. used by .update on a writable peer\nFeed.prototype._writeStateReloader = function (cb) {\n  var self = this\n  return function (err) {\n    if (err) return cb(err)\n    self._reloadMerkleState(cb)\n  }\n}\n\nFeed.prototype._reloadMerkleState = function (cb) {\n  var self = this\n\n  this._roots(self.length, function (err, roots) {\n    if (err) return cb(err)\n    self._merkle = merkle(crypto, roots)\n    cb(null)\n  })\n}\n\nFeed.prototype._reloadMerkleStateBeforeAppend = function (work, values, cb) {\n  this._reloadMerkleState(function (err) {\n    if (err) return cb(err)\n    work(values, cb)\n  })\n}\n\nFeed.prototype._open = function (cb) {\n  var self = this\n  var generatedKey = false\n\n  // TODO: clean up the duplicate code below ...\n\n  this._storage.openKey(function (_, key) {\n    if (key && !self._overwrite && !self.key) self.key = key\n\n    if (!self.key && self.live) {\n      var keyPair = crypto.keyPair()\n      self.secretKey = keyPair.secretKey\n      self.key = keyPair.publicKey\n      generatedKey = true\n    }\n\n    self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n    self._storage.open({key: self.key, discoveryKey: self.discoveryKey}, onopen)\n  })\n\n  function onopen (err, state) {\n    if (err) return cb(err)\n\n    // if no key but we have data do a bitfield reset since we cannot verify the data.\n    if (!state.key && state.bitfield.length) {\n      self._overwrite = true\n    }\n\n    if (self._overwrite) {\n      state.bitfield = []\n      state.key = state.secretKey = null\n    }\n\n    self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield)\n    self.tree = treeIndex(self.bitfield.tree)\n    self.length = self.tree.blocks()\n    self._seq = self.length\n\n    if (state.key && self.key && !equals(state.key, self.key)) {\n      return cb(new Error('Another hypercore is stored here'))\n    }\n\n    if (state.key) self.key = state.key\n    if (state.secretKey) self.secretKey = state.secretKey\n\n    // verify key and secretKey go together\n    if (self.key && self.secretKey) {\n      var challenge = bufferAlloc(0)\n      if (!crypto.verify(challenge, crypto.sign(challenge, self.secretKey), self.key)) {\n        return cb(new Error('Key and secret do not match'))\n      }\n    }\n\n    if (!self.length) return onsignature(null, null)\n    self._storage.getSignature(self.length - 1, onsignature)\n\n    function onsignature (_, sig) {\n      if (self.length) self.live = !!sig\n\n      if ((generatedKey || !self.key) && !self._createIfMissing) {\n        return cb(new Error('No hypercore is stored here'))\n      }\n\n      if (!self.key && self.live) {\n        var keyPair = crypto.keyPair()\n        self.secretKey = keyPair.secretKey\n        self.key = keyPair.publicKey\n      }\n\n      var writable = !!self.secretKey || self.key === null\n\n      if (!writable && self.writable) return cb(new Error('Feed is not writable'))\n      self.writable = writable\n      self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n\n      if (self._storeSecretKey && !self.secretKey) {\n        self._storeSecretKey = false\n      }\n\n      var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key)\n      var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey))\n\n      var missing = 1 +\n        (shouldWriteKey ? 1 : 0) +\n        (shouldWriteSecretKey ? 1 : 0) +\n        (self._overwrite ? 1 : 0)\n      var error = null\n\n      if (shouldWriteKey) self._storage.key.write(0, self.key, done)\n      if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done)\n\n      if (self._overwrite) { // TODO: support storage.resize for this instead\n        self._storage.putBitfield(0, state.bitfield, done)\n      }\n\n      done(null)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) return cb(error)\n        self._roots(self.length, onroots)\n      }\n\n      function onroots (err, roots) {\n        if (err) return cb(err)\n\n        self._merkle = merkle(crypto, roots)\n        self.byteLength = roots.reduce(addSize, 0)\n        self.opened = true\n        self.emit('ready')\n\n        cb(null)\n      }\n    }\n  }\n}\n\nFeed.prototype.download = function (range, cb) {\n  if (typeof range === 'function') return this.download(null, range)\n  if (typeof range === 'number') range = {start: range, end: range + 1}\n  if (!range) range = {}\n  if (!cb) cb = noop\n  if (!this.readable) return cb(new Error('Feed is closed'))\n\n  // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so\n  // this._updatePeers does this for us when there is a peer though, so not critical\n\n  var sel = {\n    _index: this._selections.length,\n    hash: !!range.hash,\n    iterator: null,\n    start: range.start || 0,\n    end: range.end || -1,\n    want: 0,\n    linear: !!range.linear,\n    callback: cb\n  }\n\n  sel.want = toWantRange(sel.start)\n\n  this._selections.push(sel)\n  this._updatePeers()\n\n  return sel\n}\n\nFeed.prototype.undownload = function (range) {\n  if (typeof range === 'number') range = {start: range, end: range + 1}\n  if (!range) range = {}\n\n  if (range.callback && range._index > -1) {\n    set.remove(this._selections, range)\n    nextTick(range.callback, new Error('Download was cancelled'))\n    return\n  }\n\n  var start = range.start || 0\n  var end = range.end || -1\n  var hash = !!range.hash\n  var linear = !!range.linear\n\n  for (var i = 0; i < this._selections.length; i++) {\n    var s = this._selections[i]\n\n    if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {\n      set.remove(this._selections, s)\n      nextTick(s.callback, new Error('Download was cancelled'))\n      return\n    }\n  }\n}\n\nFeed.prototype.digest = function (index) {\n  return this.tree.digest(2 * index)\n}\n\nFeed.prototype.proof = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.proof(index, null, opts)\n  if (!this.opened) return this._readyAndProof(index, opts, cb)\n  if (!opts) opts = {}\n\n  var proof = this.tree.proof(2 * index, opts)\n  if (!proof) return cb(new Error('No proof available for this index'))\n\n  var needsSig = this.live && !!proof.verifiedBy\n  var pending = proof.nodes.length + (needsSig ? 1 : 0)\n  var error = null\n  var signature = null\n  var nodes = new Array(proof.nodes.length)\n\n  if (!pending) return cb(null, {nodes: nodes, signature: null})\n\n  for (var i = 0; i < proof.nodes.length; i++) {\n    this._storage.getNode(proof.nodes[i], onnode)\n  }\n  if (needsSig) {\n    this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)\n  }\n\n  function onsignature (err, sig) {\n    if (sig) signature = sig\n    onnode(err, null)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n\n    if (node) {\n      nodes[proof.nodes.indexOf(node.index)] = node\n    }\n\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, {nodes: nodes, signature: signature})\n  }\n}\n\nFeed.prototype._readyAndProof = function (index, opts, cb) {\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    self.proof(index, opts, cb)\n  })\n}\n\nFeed.prototype.put = function (index, data, proof, cb) {\n  if (!this.opened) return this._readyAndPut(index, data, proof, cb)\n  this._putBuffer(index, this._codec.encode(data), proof, null, cb)\n}\n\nFeed.prototype.cancel = function (start, end) {  // TODO: use same argument scheme as download\n  if (!end) end = start + 1\n\n  // cancel these right away as .download does not wait for ready\n  for (var i = this._selections.length - 1; i >= 0; i--) {\n    var sel = this._selections[i]\n    if (start <= sel.start && sel.end <= end) {\n      this.undownload(sel)\n    }\n  }\n\n  // defer the last part until after ready as .get does that as well\n  if (this.opened) this._cancel(start, end)\n  else this._readyAndCancel(start, end)\n}\n\nFeed.prototype._cancel = function (start, end) {\n  var i = 0\n\n  for (i = start; i < end; i++) {\n    this._reserved.set(i, false) // TODO: send cancel message if set returns true\n  }\n\n  for (i = this._waiting.length - 1; i >= 0; i--) {\n    var w = this._waiting[i]\n    if ((start <= w.start && w.end <= end) || (start <= w.index && w.index < end)) {\n      remove(this._waiting, i)\n      if (w.callback) nextTick(w.callback, new Error('Request cancelled'))\n    }\n  }\n}\n\nFeed.prototype.clear = function (start, end, opts, cb) { // TODO: use same argument scheme as download\n  if (typeof end === 'function') return this.clear(start, start + 1, null, end)\n  if (typeof opts === 'function') return this.clear(start, end, null, opts)\n  if (!opts) opts = {}\n  if (!end) end = start + 1\n  if (!cb) cb = noop\n\n  // TODO: this needs some work. fx we can only calc byte offset for blocks we know about\n  // so internally we should make sure to only do that. We should use the merkle tree for this\n\n  var self = this\n  var byteOffset = start === 0 ? 0 : (typeof opts.byteOffset === 'number' ? opts.byteOffset : -1)\n  var byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1\n\n  this._ready(function (err) {\n    if (err) return cb(err)\n\n    var modified = false\n\n    // TODO: use a buffer.fill thing here to speed this up!\n\n    for (var i = start; i < end; i++) {\n      if (self.bitfield.set(i, false)) modified = true\n    }\n\n    if (!modified) return nextTick(cb)\n\n    // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing\n\n    self._unannounce({start: start, length: end - start})\n    if (opts.delete === false || self._indexing) return sync()\n    if (byteOffset > -1) return onstartbytes(null, byteOffset)\n    self._storage.dataOffset(start, [], onstartbytes)\n\n    function sync () {\n      self.emit('clear', start, end)\n      self._sync(null, cb)\n    }\n\n    function onstartbytes (err, offset) {\n      if (err) return cb(err)\n      byteOffset = offset\n      if (byteLength > -1) return onendbytes(null, byteLength + byteOffset)\n      if (end === self.length) return onendbytes(null, self.byteLength)\n      self._storage.dataOffset(end, [], onendbytes)\n    }\n\n    function onendbytes (err, end) {\n      if (err) return cb(err)\n      if (!self._storage.data.del) return sync() // Not all data storage impls del\n      self._storage.data.del(byteOffset, end - byteOffset, sync)\n    }\n  })\n}\n\nFeed.prototype.signature = function (index, cb) {\n  if (typeof index === 'function') return this.signature(this.length - 1, index)\n\n  if (index < 0 || index >= this.length) return cb(new Error('No signature available for this index'))\n\n  this._storage.nextSignature(index, cb)\n}\n\nFeed.prototype.verify = function (index, signature, cb) {\n  var self = this\n\n  this.rootHashes(index, function (err, roots) {\n    if (err) return cb(err)\n\n    var checksum = crypto.tree(roots)\n\n    if (!crypto.verify(checksum, signature, self.key)) {\n      cb(new Error('Signature verification failed'))\n    } else {\n      cb(null, true)\n    }\n  })\n}\n\nFeed.prototype.rootHashes = function (index, cb) {\n  this._getRootsToVerify(index * 2 + 2, {}, [], cb)\n}\n\nFeed.prototype.seek = function (bytes, opts, cb) {\n  if (typeof opts === 'function') return this.seek(bytes, null, opts)\n  if (!opts) opts = {}\n  if (!this.opened) return this._readyAndSeek(bytes, opts, cb)\n\n  var self = this\n\n  this._seek(bytes, function (err, index, offset) {\n    if (!err && isBlock(index)) return done(index / 2, offset)\n    if (opts.wait === false) return cb(err || new Error('Unable to seek to this offset'))\n\n    var start = opts.start || 0\n    var end = opts.end || -1\n\n    if (!err) {\n      var left = flat.leftSpan(index) / 2\n      var right = flat.rightSpan(index) / 2 + 1\n\n      if (left > start) start = left\n      if (right < end || end === -1) end = right\n    }\n\n    if (end > -1 && end <= start) return cb(new Error('Unable to seek to this offset'))\n\n    self._waiting.push({\n      hash: opts.hash !== false,\n      bytes: bytes,\n      index: -1,\n      start: start,\n      end: end,\n      want: toWantRange(start),\n      callback: cb || noop\n    })\n\n    self._updatePeers()\n  })\n\n  function done (index, offset) {\n    for (var i = 0; i < self.peers.length; i++) {\n      self.peers[i].haveBytes(bytes)\n    }\n    cb(null, index, offset)\n  }\n}\n\nFeed.prototype._seek = function (offset, cb) {\n  if (offset === 0) return cb(null, 0, 0)\n\n  var self = this\n  var roots = flat.fullRoots(this.length * 2)\n  var nearestRoot = 0\n\n  loop(null, null)\n\n  function onroot (top) {\n    if (isBlock(top)) return cb(null, top, offset)\n\n    var left = flat.leftChild(top)\n    while (!self.tree.get(left)) {\n      if (isBlock(left)) return cb(null, nearestRoot, offset)\n      left = flat.leftChild(left)\n    }\n\n    self._storage.getNode(left, onleftchild)\n  }\n\n  function onleftchild (err, node) {\n    if (err) return cb(err)\n\n    if (node.size > offset) {\n      nearestRoot = node.index\n      onroot(node.index)\n    } else {\n      offset -= node.size\n      onroot(flat.sibling(node.index))\n    }\n  }\n\n  function loop (err, node) {\n    if (err) return cb(err)\n\n    if (node) {\n      if (node.size > offset) {\n        nearestRoot = node.index\n        return onroot(node.index)\n      }\n      offset -= node.size\n    }\n\n    if (!roots.length) return cb(new Error('Out of bounds'))\n    self._storage.getNode(roots.shift(), loop)\n  }\n}\n\nFeed.prototype._readyAndSeek = function (bytes, opts, cb) {\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    self.seek(bytes, opts, cb)\n  })\n}\n\nFeed.prototype._getBuffer = function (index, cb) {\n  this._storage.getData(index, cb)\n}\n\nFeed.prototype._putBuffer = function (index, data, proof, from, cb) {\n  // TODO: this nodes in proof are not instances of our Node prototype\n  // but just similar. Check if this has any v8 perf implications.\n\n  // TODO: if the proof contains a valid signature BUT fails, emit a critical error\n  // --> feed should be considered dead\n\n  var self = this\n  var trusted = -1\n  var missing = []\n  var next = 2 * index\n  var i = data ? 0 : 1\n\n  while (true) {\n    if (this.tree.get(next)) {\n      trusted = next\n      break\n    }\n\n    var sib = flat.sibling(next)\n    next = flat.parent(next)\n\n    if (i < proof.nodes.length && proof.nodes[i].index === sib) {\n      i++\n      continue\n    }\n\n    if (!this.tree.get(sib)) break\n    missing.push(sib)\n  }\n\n  if (trusted === -1 && this.tree.get(next)) trusted = next\n\n  var error = null\n  var trustedNode = null\n  var missingNodes = new Array(missing.length)\n  var pending = missing.length + (trusted > -1 ? 1 : 0)\n\n  for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing)\n  if (trusted > -1) this._storage.getNode(trusted, ontrusted)\n  if (!missing.length && trusted === -1) onmissingloaded(null)\n\n  function ontrusted (err, node) {\n    if (err) error = err\n    if (node) trustedNode = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissing (err, node) {\n    if (err) error = err\n    if (node) missingNodes[missing.indexOf(node.index)] = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissingloaded (err) {\n    if (err) return cb(err)\n    self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb)\n  }\n}\n\nFeed.prototype._readyAndPut = function (index, data, proof, cb) {\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    self.put(index, data, proof, cb)\n  })\n}\n\nFeed.prototype._write = function (index, data, nodes, sig, from, cb) {\n  if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb)\n  this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb))\n}\n\nfunction writeHookDone (self, index, data, nodes, sig, from, cb) {\n  return function (err) {\n    if (err) return cb(err)\n    self._writeAfterHook(index, data, nodes, sig, from, cb)\n  }\n}\n\nFeed.prototype._writeAfterHook = function (index, data, nodes, sig, from, cb) {\n  var self = this\n  var pending = nodes.length + 1 + (sig ? 1 : 0)\n  var error = null\n\n  for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone)\n  if (data) this._storage.putData(index, data, nodes, ondone)\n  else ondone()\n  if (sig) this._storage.putSignature(sig.index, sig.signature, ondone)\n\n  function ondone (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n    self._writeDone(index, data, nodes, from, cb)\n  }\n}\n\nFeed.prototype._writeDone = function (index, data, nodes, from, cb) {\n  for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)\n  this.tree.set(2 * index)\n\n  if (data) {\n    if (this.bitfield.set(index, true)) this.emit('download', index, data, from)\n    if (this.peers.length) this._announce({start: index}, from)\n\n    if (!this.writable) {\n      if (!this._synced) this._synced = this.bitfield.iterator(0, this.length)\n      if (this._synced.next() === -1) {\n        this._synced.range(0, this.length)\n        this._synced.seek(0)\n        if (this._synced.next() === -1) {\n          this.emit('sync')\n        }\n      }\n    }\n  }\n\n  this._sync(null, cb)\n}\n\nFeed.prototype._verifyAndWrite = function (index, data, proof, localNodes, trustedNode, from, cb) {\n  var visited = []\n  var remoteNodes = proof.nodes\n  var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift()\n\n  // check if we already have the hash for this node\n  if (verifyNode(trustedNode, top)) {\n    this._write(index, data, visited, null, from, cb)\n    return\n  }\n\n  // keep hashing with siblings until we reach or trusted node\n  while (true) {\n    var node = null\n    var next = flat.sibling(top.index)\n\n    if (remoteNodes.length && remoteNodes[0].index === next) {\n      node = remoteNodes.shift()\n      visited.push(node)\n    } else if (localNodes.length && localNodes[0].index === next) {\n      node = localNodes.shift()\n    } else {\n      // we cannot create another parent, i.e. these nodes must be roots in the tree\n      this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb)\n      return\n    }\n\n    visited.push(top)\n    top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size)\n\n    // the tree checks out, write the data and the visited nodes\n    if (verifyNode(trustedNode, top)) {\n      this._write(index, data, visited, null, from, cb)\n      return\n    }\n  }\n}\n\nFeed.prototype._verifyRootsAndWrite = function (index, data, top, proof, nodes, from, cb) {\n  var remoteNodes = proof.nodes\n  var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index\n  var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2\n  var self = this\n\n  this._getRootsToVerify(verifiedBy, top, remoteNodes, function (err, roots, extraNodes) {\n    if (err) return cb(err)\n\n    var checksum = crypto.tree(roots)\n    var signature = null\n\n    if (self.length && self.live && !proof.signature) {\n      return cb(new Error('Remote did not include a signature'))\n    }\n\n    if (proof.signature) { // check signaturex\n      if (!crypto.verify(checksum, proof.signature, self.key)) {\n        return cb(new Error('Remote signature could not be verified'))\n      }\n\n      signature = {index: verifiedBy / 2 - 1, signature: proof.signature}\n    } else { // check tree root\n      if (!equals(checksum, self.key)) {\n        return cb(new Error('Remote checksum failed'))\n      }\n    }\n\n    self.live = !!signature\n\n    var length = verifiedBy / 2\n    if (length > self.length) {\n      // TODO: only emit this after the info has been flushed to storage\n      if (self.writable) self._merkle = null // We need to reload merkle state now\n      self.length = length\n      self._seq = length\n      self.byteLength = roots.reduce(addSize, 0)\n      if (self._synced) self._synced.seek(0, self.length)\n      self.emit('append')\n    }\n\n    self._write(index, data, nodes.concat(extraNodes), signature, from, cb)\n  })\n}\n\nFeed.prototype._getRootsToVerify = function (verifiedBy, top, remoteNodes, cb) {\n  var indexes = flat.fullRoots(verifiedBy)\n  var roots = new Array(indexes.length)\n  var nodes = []\n  var error = null\n  var pending = roots.length\n\n  for (var i = 0; i < indexes.length; i++) {\n    if (indexes[i] === top.index) {\n      nodes.push(top)\n      onnode(null, top)\n    } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {\n      nodes.push(remoteNodes[0])\n      onnode(null, remoteNodes.shift())\n    } else if (this.tree.get(indexes[i])) {\n      this._storage.getNode(indexes[i], onnode)\n    } else {\n      onnode(new Error('Missing tree roots needed for verify'))\n    }\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) roots[indexes.indexOf(node.index)] = node\n    if (!--pending) done(error)\n  }\n\n  function done (err) {\n    if (err) return cb(err)\n\n    cb(null, roots, nodes)\n  }\n}\n\nFeed.prototype._announce = function (message, from) {\n  for (var i = 0; i < this.peers.length; i++) {\n    var peer = this.peers[i]\n    if (peer !== from) peer.have(message)\n  }\n}\n\nFeed.prototype._unannounce = function (message) {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message)\n}\n\nFeed.prototype.downloaded = function (start, end) {\n  return this.bitfield.total(start, end)\n}\n\nFeed.prototype.has = function (start, end) {\n  if (end === undefined) return this.bitfield.get(start)\n  var total = end - start\n  return total === this.bitfield.total(start, end)\n}\n\nFeed.prototype.head = function (opts, cb) {\n  if (typeof opts === 'function') return this.head({}, opts)\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    if (self.length === 0) cb(new Error('feed is empty'))\n    else self.get(self.length - 1, cb)\n  })\n}\n\nFeed.prototype.get = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.get(index, null, opts)\n  if (!this.opened) return this._readyAndGet(index, opts, cb)\n  if (!this.readable) return cb(new Error('Feed is closed'))\n\n  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  if (!this.bitfield.get(index)) {\n    if (opts && opts.wait === false) return cb(new Error('Block not downloaded'))\n\n    this._waiting.push({bytes: 0, hash: false, index: index, options: opts, callback: cb})\n    this._updatePeers()\n    return\n  }\n\n  if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb)\n  else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb)\n\n  this._getBuffer(index, cb)\n}\n\nFeed.prototype._readyAndGet = function (index, opts, cb) {\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    self.get(index, opts, cb)\n  })\n}\n\nFeed.prototype.getBatch = function (start, end, opts, cb) {\n  if (typeof opts === 'function') return this.getBatch(start, end, null, opts)\n  if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb)\n\n  var self = this\n  var wait = !opts || opts.wait !== false\n\n  if (this.has(start, end)) return this._getBatch(start, end, opts, cb)\n  if (!wait) return cb(new Error('Block not downloaded'))\n\n  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  this.download({start: start, end: end}, function (err) {\n    if (err) return cb(err)\n    self._getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._getBatch = function (start, end, opts, cb) {\n  var enc = opts && opts.valueEncoding\n  var codec = enc ? toCodec(enc) : this._codec\n\n  this._storage.getDataBatch(start, end - start, onbatch)\n\n  function onbatch (err, buffers) {\n    if (err) return cb(err)\n\n    var batch = new Array(buffers.length)\n\n    for (var i = 0; i < buffers.length; i++) {\n      try {\n        batch[i] = codec ? codec.decode(buffers[i]) : buffers[i]\n      } catch (err) {\n        return cb(err)\n      }\n    }\n\n    cb(null, batch)\n  }\n}\n\nFeed.prototype._readyAndGetBatch = function (start, end, opts, cb) {\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    self.getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._updatePeers = function () {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].update()\n}\n\nFeed.prototype.createWriteStream = function () {\n  var self = this\n  return bulk.obj(write)\n\n  function write (batch, cb) {\n    self.append(batch, cb)\n  }\n}\n\nFeed.prototype.createReadStream = function (opts) {\n  if (!opts) opts = {}\n\n  var self = this\n  var start = opts.start || 0\n  var end = typeof opts.end === 'number' ? opts.end : -1\n  var live = !!opts.live\n  var snapshot = opts.snapshot !== false\n  var first = true\n  var range = this.download({start: start, end: end, linear: true})\n\n  return from.obj(read).on('end', cleanup).on('close', cleanup)\n\n  function read (size, cb) {\n    if (!self.opened) return open(size, cb)\n    if (!self.readable) return cb(new Error('Feed is closed'))\n\n    if (first) {\n      if (end === -1) {\n        if (live) end = Infinity\n        else if (snapshot) end = self.length\n        if (start > end) return cb(null, null)\n      }\n      if (opts.tail) start = self.length\n      first = false\n    }\n\n    if (start === end || (end === -1 && start === self.length)) return cb(null, null)\n\n    range.start++\n    if (range.iterator) range.iterator.start++\n\n    self.get(start++, opts, cb)\n  }\n\n  function cleanup () {\n    if (!range) return\n    self.undownload(range)\n    range = null\n  }\n\n  function open (size, cb) {\n    self._ready(function (err) {\n      if (err) return cb(err)\n      read(size, cb)\n    })\n  }\n}\n\n// TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)\nFeed.prototype.finalize = function (cb) {\n  if (!this.key) {\n    this.key = crypto.tree(this._merkle.roots)\n    this.discoveryKey = crypto.discoveryKey(this.key)\n  }\n  this._storage.key.write(0, this.key, cb)\n}\n\nFeed.prototype.append = function (batch, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var list = Array.isArray(batch) ? batch : [batch]\n  this._batch(list, onappend)\n\n  function onappend (err) {\n    if (err) return cb(err)\n    var seq = self._seq\n    self._seq += list.length\n    cb(null, seq)\n  }\n}\n\nFeed.prototype.flush = function (cb) {\n  this.append([], cb)\n}\n\nFeed.prototype.close = function (cb) {\n  var self = this\n\n  this._ready(function () {\n    self.writable = false\n    self.readable = false\n    self._storage.close(function (err) {\n      if (!self.closed && !err) self._onclose()\n      if (cb) cb(err)\n    })\n  })\n}\n\nFeed.prototype._onclose = function () {\n  this.closed = true\n\n  while (this._waiting.length) {\n    this._waiting.pop().callback(new Error('Feed is closed'))\n  }\n  while (this._selections.length) {\n    this._selections.pop().callback(new Error('Feed is closed'))\n  }\n\n  this.emit('close')\n}\n\nFeed.prototype._appendHook = function (batch, cb) {\n  var self = this\n  var missing = batch.length\n  var error = null\n\n  if (!missing) return this._append(batch, cb)\n  for (var i = 0; i < batch.length; i++) {\n    this._onwrite(i + this.length, batch[i], null, done)\n  }\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    if (error) return cb(error)\n    self._append(batch, cb)\n  }\n}\n\nFeed.prototype._append = function (batch, cb) {\n  if (!this.opened) return this._readyAndAppend(batch, cb)\n  if (!this.writable) return cb(new Error('This feed is not writable. Did you create it?'))\n\n  var self = this\n  var pending = this.live && batch.length ? 1 + batch.length : batch.length\n  var offset = 0\n  var error = null\n\n  if (!pending) return cb()\n\n  for (var i = 0; i < batch.length; i++) {\n    var data = this._codec.encode(batch[i])\n    var nodes = this._merkle.next(data)\n\n    if (this._indexing) done(null)\n    else this._storage.data.write(this.byteLength + offset, data, done)\n\n    if (this.live && i === batch.length - 1) {\n      var sig = crypto.sign(crypto.tree(this._merkle.roots), this.secretKey)\n      this._storage.putSignature(this.length + i, sig, done)\n    }\n\n    pending += nodes.length\n    offset += data.length\n\n    for (var j = 0; j < nodes.length; j++) {\n      var node = nodes[j]\n      this._storage.putNode(node.index, node, done)\n    }\n  }\n\n  function done (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n\n    var start = self.length\n\n    // TODO: only emit append and update length / byteLength after the info has been flushed to storage\n    self.byteLength += offset\n    for (var i = 0; i < batch.length; i++) {\n      self.bitfield.set(self.length, true)\n      self.tree.set(2 * self.length++)\n    }\n    self.emit('append')\n\n    var message = self.length - start > 1 ? {start: start, length: self.length - start} : {start: start}\n    if (self.peers.length) self._announce(message)\n\n    self._sync(null, cb)\n  }\n}\n\nFeed.prototype._readyAndAppend = function (batch, cb) {\n  var self = this\n  this._ready(function (err) {\n    if (err) return cb(err)\n    self._append(batch, cb)\n  })\n}\n\nFeed.prototype._readyAndCancel = function (start, end) {\n  var self = this\n  this.ready(function () {\n    self._cancel(start, end)\n  })\n}\n\nFeed.prototype._pollWaiting = function () {\n  var len = this._waiting.length\n  for (var i = 0; i < len; i++) {\n    var next = this._waiting[i]\n    if (!next.bytes && !this.bitfield.get(next.index)) continue\n\n    remove(this._waiting, i--)\n    len--\n\n    if (next.bytes) this.seek(next.bytes, next, next.callback)\n    else if (next.update) this.update(next.index + 1, next.callback)\n    else this.get(next.index, next.options, next.callback)\n  }\n}\n\nFeed.prototype._syncBitfield = function (cb) {\n  var missing = this.bitfield.pages.updates.length\n  var next = null\n  var error = null\n\n  // All data / nodes have been written now. We still need to update the bitfields though\n\n  // TODO 1: if the program fails during this write the bitfield might not have been fully written\n  // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists\n  // on disk. So if a get fails, it should try and recover once.\n\n  // TODO 2: if .writable append bitfield updates into a single buffer for extra perf\n  // Added benefit is that if the program exits while flushing the bitfield the feed will only get\n  // truncated and not have missing chunks which is what you expect.\n\n  if (!missing) {\n    this._pollWaiting()\n    return cb(null)\n  }\n\n  while ((next = this.bitfield.pages.lastUpdate()) !== null) {\n    this._storage.putBitfield(next.offset, next.buffer, ondone)\n  }\n\n  this._pollWaiting()\n\n  function ondone (err) {\n    if (err) error = err\n    if (--missing) return\n    cb(error)\n  }\n}\n\nFeed.prototype._roots = function (index, cb) {\n  var roots = flat.fullRoots(2 * index)\n  var result = new Array(roots.length)\n  var pending = roots.length\n  var error = null\n\n  if (!pending) return cb(null, result)\n\n  for (var i = 0; i < roots.length; i++) {\n    this._storage.getNode(roots[i], onnode)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) result[roots.indexOf(node.index)] = node\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, result)\n  }\n}\n\nFeed.prototype.audit = function (cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var report = {\n    valid: 0,\n    invalid: 0\n  }\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var block = 0\n    var max = self.length\n\n    next()\n\n    function onnode (err, node) {\n      if (err) return ondata(null, null)\n      self._storage.getData(block, ondata)\n\n      function ondata (_, data) {\n        var verified = data && crypto.data(data).equals(node.hash)\n        if (verified) report.valid++\n        else report.invalid++\n        self.bitfield.set(block, verified)\n        block++\n        next()\n      }\n    }\n\n    function next () {\n      while (block < max && !self.bitfield.get(block)) block++\n      if (block >= max) return done()\n      self._storage.getNode(2 * block, onnode)\n    }\n\n    function done () {\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        cb(null, report)\n      })\n    }\n  })\n}\n\nfunction noop () {}\n\nfunction verifyNode (trusted, node) {\n  return trusted && trusted.index === node.index && equals(trusted.hash, node.hash)\n}\n\nfunction addSize (size, node) {\n  return size + node.size\n}\n\nfunction isBlock (index) {\n  return (index & 1) === 0\n}\n\nfunction defaultStorage (dir) {\n  return function (name) {\n    return raf(name, {directory: dir})\n  }\n}\n\nfunction toCodec (enc) {\n  // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \\o/\n  return codecs(enc === 'json' ? 'ndjson' : enc)\n}\n\nfunction wrapCodec (enc, cb) {\n  return function (err, buf) {\n    if (err) return cb(err)\n    try {\n      buf = enc.decode(buf)\n    } catch (err) {\n      return cb(err)\n    }\n    cb(null, buf)\n  }\n}\n\nfunction timeoutCallback (cb, timeout) {\n  var failed = false\n  var id = setTimeout(ontimeout, timeout)\n  return done\n\n  function ontimeout () {\n    failed = true\n    // TODO: make libs/errors for all this stuff\n    var err = new Error('ETIMEDOUT')\n    err.code = 'ETIMEDOUT'\n    cb(err)\n  }\n\n  function done (err, val) {\n    if (failed) return\n    clearTimeout(id)\n    cb(err, val)\n  }\n}\n\n// buffer-equals, but handle 'null' buffer parameters.\nfunction safeBufferEquals (a, b) {\n  if (!a) return !b\n  if (!b) return !a\n  return equals(a, b)\n}\n\nfunction toWantRange (i) {\n  return Math.floor(i / 1024 / 1024) * 1024 * 1024\n}\n","'use strict';\nmodule.exports = function (a, b) {\n\tif (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t\tthrow new TypeError('Arguments must be Buffers');\n\t}\n\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (typeof a.equals === 'function') {\n\t\treturn a.equals(b);\n\t}\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (var i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n","module.exports = function (work) {\n  var pending = null\n  var callback = null\n  var callbacks = null\n  var next = null\n\n  return function (val, cb) {\n    next = val\n    update(cb || noop)\n  }\n\n  function update (cb) {\n    if (callback) {\n      if (!pending) pending = []\n      pending.push(cb)\n      return\n    }\n\n    var val = next\n    next = null\n    callback = cb\n    work(val, done)\n  }\n\n  function done (err) {\n    var cb = callback\n    var cbs = callbacks\n    callbacks = null\n    callback = null\n\n    if (pending) {\n      callbacks = pending\n      pending = null\n      update(noop)\n    }\n\n    if (cbs) {\n      for (var i = 0; i < cbs.length; i++) cbs[i](err)\n    }\n    cb(err)\n  }\n}\n\nfunction noop (_) {}\n","module.exports = remove\n\nfunction remove (arr, i) {\n  if (i >= arr.length || i < 0) return\n  var last = arr.pop()\n  if (i < arr.length) {\n    var tmp = arr[i]\n    arr[i] = last\n    return tmp\n  }\n  return last\n}\n","exports.add = add\nexports.has = has\nexports.remove = remove\nexports.swap = swap\n\nfunction add (list, item) {\n  if (has(list, item)) return item\n  item._index = list.length\n  list.push(item)\n  return item\n}\n\nfunction has (list, item) {\n  return item._index < list.length && list[item._index] === item\n}\n\nfunction remove (list, item) {\n  if (!has(list, item)) return null\n\n  var last = list.pop()\n  if (last !== item) {\n    list[item._index] = last\n    last._index = item._index\n  }\n\n  return item\n}\n\nfunction swap (list, a, b) {\n  if (!has(list, a) || !has(list, b)) return\n  var tmp = a._index\n  a._index = b._index\n  list[a._index] = a\n  b._index = tmp\n  list[b._index] = b\n}\n","// a more low level interface to the merkle tree stream.\n// useful for certain applications the require non-streamy access to the algos.\n// versioned by the same semver as the stream interface.\n\nvar flat = require('flat-tree')\n\nmodule.exports = MerkleGenerator\n\nfunction MerkleGenerator (opts, roots) {\n  if (!(this instanceof MerkleGenerator)) return new MerkleGenerator(opts, roots)\n  if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required')\n\n  this.roots = roots || opts.roots || []\n  this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0\n\n  for (var i = 0; i < this.roots.length; i++) {\n    var r = this.roots[i]\n    if (r && !r.parent) r.parent = flat.parent(r.index)\n  }\n\n  this._leaf = opts.leaf\n  this._parent = opts.parent\n}\n\nMerkleGenerator.prototype.next = function (data, nodes) {\n  if (!Buffer.isBuffer(data)) data = new Buffer(data)\n  if (!nodes) nodes = []\n\n  var index = 2 * this.blocks++\n\n  var leaf = {\n    index: index,\n    parent: flat.parent(index),\n    hash: null,\n    size: data.length,\n    data: data\n  }\n\n  leaf.hash = this._leaf(leaf, this.roots)\n  this.roots.push(leaf)\n  nodes.push(leaf)\n\n  while (this.roots.length > 1) {\n    var left = this.roots[this.roots.length - 2]\n    var right = this.roots[this.roots.length - 1]\n\n    if (left.parent !== right.parent) break\n\n    this.roots.pop()\n    this.roots[this.roots.length - 1] = leaf = {\n      index: left.parent,\n      parent: flat.parent(left.parent),\n      hash: this._parent(left, right),\n      size: left.size + right.size,\n      data: null\n    }\n    nodes.push(leaf)\n  }\n\n  return nodes\n}\n","exports.fullRoots = function (index, result) {\n  if (index & 1) throw new Error('You can only look up roots for depth(0) blocks')\n  if (!result) result = []\n\n  index /= 2\n\n  var offset = 0\n  var factor = 1\n\n  while (true) {\n    if (!index) return result\n    while (factor * 2 <= index) factor *= 2\n    result.push(offset + factor - 1)\n    offset = offset + 2 * factor\n    index -= factor\n    factor = 1\n  }\n}\n\nexports.depth = function (index) {\n  var depth = 0\n\n  index += 1\n  while (!(index & 1)) {\n    depth++\n    index = rightShift(index)\n  }\n\n  return depth\n}\n\nexports.sibling = function (index, depth) {\n  if (!depth) depth = exports.depth(index)\n  var offset = exports.offset(index, depth)\n\n  return exports.index(depth, offset & 1 ? offset - 1 : offset + 1)\n}\n\nexports.parent = function (index, depth) {\n  if (!depth) depth = exports.depth(index)\n  var offset = exports.offset(index, depth)\n\n  return exports.index(depth + 1, rightShift(offset))\n}\n\nexports.leftChild = function (index, depth) {\n  if (!(index & 1)) return -1\n  if (!depth) depth = exports.depth(index)\n  return exports.index(depth - 1, exports.offset(index, depth) * 2)\n}\n\nexports.rightChild = function (index, depth) {\n  if (!(index & 1)) return -1\n  if (!depth) depth = exports.depth(index)\n  return exports.index(depth - 1, 1 + (exports.offset(index, depth) * 2))\n}\n\nexports.children = function (index, depth) {\n  if (!(index & 1)) return null\n\n  if (!depth) depth = exports.depth(index)\n  var offset = exports.offset(index, depth) * 2\n\n  return [\n    exports.index(depth - 1, offset),\n    exports.index(depth - 1, offset + 1)\n  ]\n}\n\nexports.leftSpan = function (index, depth) {\n  if (!(index & 1)) return index\n  if (!depth) depth = exports.depth(index)\n  return exports.offset(index, depth) * twoPow(depth + 1)\n}\n\nexports.rightSpan = function (index, depth) {\n  if (!(index & 1)) return index\n  if (!depth) depth = exports.depth(index)\n  return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2\n}\n\nexports.count = function (index, depth) {\n  if (!(index & 1)) return 1\n  if (!depth) depth = exports.depth(index)\n  return twoPow(depth + 1) - 1\n}\n\nexports.spans = function (index, depth) {\n  if (!(index & 1)) return [index, index]\n  if (!depth) depth = exports.depth(index)\n\n  var offset = exports.offset(index, depth)\n  var width = twoPow(depth + 1)\n\n  return [offset * width, (offset + 1) * width - 2]\n}\n\nexports.index = function (depth, offset) {\n  return (1 + 2 * offset) * twoPow(depth) - 1\n}\n\nexports.offset = function (index, depth) {\n  if (!(index & 1)) return index / 2\n  if (!depth) depth = exports.depth(index)\n\n  return ((index + 1) / twoPow(depth) - 1) / 2\n}\n\nexports.iterator = function (index) {\n  var ite = new Iterator()\n  ite.seek(index || 0)\n  return ite\n}\n\nfunction twoPow (n) {\n  return n < 31 ? 1 << n : ((1 << 30) * (1 << (n - 30)))\n}\n\nfunction rightShift (n) {\n  return (n - (n & 1)) / 2\n}\n\nfunction Iterator (index) {\n  this.index = 0\n  this.offset = 0\n  this.factor = 0\n}\n\nIterator.prototype.seek = function (index) {\n  this.index = index\n  if (this.index & 1) {\n    this.offset = exports.offset(index)\n    this.factor = twoPow(exports.depth(index) + 1)\n  } else {\n    this.offset = index / 2\n    this.factor = 2\n  }\n}\n\nIterator.prototype.isLeft = function () {\n  return !(this.offset & 1)\n}\n\nIterator.prototype.isRight = function () {\n  return !this.isLeft()\n}\n\nIterator.prototype.prev = function () {\n  if (!this.offset) return this.index\n  this.offset--\n  this.index -= this.factor\n  return this.index\n}\n\nIterator.prototype.next = function () {\n  this.offset++\n  this.index += this.factor\n  return this.index\n}\n\nIterator.prototype.sibling = function () {\n  return this.isLeft() ? this.next() : this.prev()\n}\n\nIterator.prototype.parent = function () {\n  if (this.offset & 1) {\n    this.index -= this.factor / 2\n    this.offset = (this.offset - 1) / 2\n  } else {\n    this.index += this.factor / 2\n    this.offset /= 2\n  }\n  this.factor *= 2\n  return this.index\n}\n\nIterator.prototype.leftSpan = function () {\n  this.index = this.index - this.factor / 2 + 1\n  this.offset = this.index / 2\n  this.factor = 2\n  return this.index\n}\n\nIterator.prototype.rightSpan = function () {\n  this.index = this.index + this.factor / 2 - 1\n  this.offset = this.index / 2\n  this.factor = 2\n  return this.index\n}\n\nIterator.prototype.leftChild = function () {\n  if (this.factor === 2) return this.index\n  this.factor /= 2\n  this.index -= this.factor / 2\n  this.offset *= 2\n  return this.index\n}\n\nIterator.prototype.rightChild = function () {\n  if (this.factor === 2) return this.index\n  this.factor /= 2\n  this.index += this.factor / 2\n  this.offset = 2 * this.offset + 1\n  return this.index\n}\n","var stream = require('readable-stream')\nvar inherits = require('inherits')\nvar bufferFrom = require('buffer-from')\n\nvar SIGNAL_FLUSH = bufferFrom([0])\n\nvar Bulk = function (opts, worker, flush) {\n  if (!(this instanceof Bulk)) return new Bulk(opts, worker, flush)\n\n  if (typeof opts === 'function') {\n    flush = worker\n    worker = opts\n    opts = {}\n  }\n\n  stream.Writable.call(this, opts)\n  this._worker = worker\n  this._flush = flush\n  this.destroyed = false\n}\n\ninherits(Bulk, stream.Writable)\n\nBulk.obj = function (opts, worker, flush) {\n  if (typeof opts === 'function') return Bulk.obj(null, opts, worker)\n  if (!opts) opts = {}\n  opts.objectMode = true\n  return new Bulk(opts, worker, flush)\n}\n\nBulk.prototype.end = function (data, enc, cb) {\n  if (!this._flush) return stream.Writable.prototype.end.apply(this, arguments)\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  if (data) this.write(data)\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nBulk.prototype.destroy = function (err) {\n  if (this.destroyed) return\n  this.destroyed = true\n  if (err) this.emit('error')\n  this.emit('close')\n}\n\nBulk.prototype._write = function (data, enc, cb) {\n  if (data === SIGNAL_FLUSH) this._flush(cb)\n  else this._worker([data], cb)\n}\n\nBulk.prototype._writev = function (batch, cb) {\n  var len = batch.length\n  if (batch[batch.length - 1].chunk === SIGNAL_FLUSH) {\n    cb = this._flusher(cb)\n    if (!--len) return cb()\n  }\n  var arr = new Array(len)\n  for (var i = 0; i < len; i++) arr[i] = batch[i].chunk\n  this._worker(arr, cb)\n}\n\nBulk.prototype._flusher = function (cb) {\n  var self = this\n  return function (err) {\n    if (err) return cb(err)\n    self._flush(cb)\n  }\n}\n\nmodule.exports = Bulk\n","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","module.exports = require(\"events\");","module.exports = require('stream');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = require(\"buffer\");","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","try {\n  var util = require('util');\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = require('util').deprecate;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","var Readable = require('readable-stream').Readable\nvar inherits = require('inherits')\n\nmodule.exports = from2\n\nfrom2.ctor = ctor\nfrom2.obj = obj\n\nvar Proto = ctor()\n\nfunction toFunction(list) {\n  list = list.slice()\n  return function (_, cb) {\n    var err = null\n    var item = list.length ? list.shift() : null\n    if (item instanceof Error) {\n      err = item\n      item = null\n    }\n\n    cb(err, item)\n  }\n}\n\nfunction from2(opts, read) {\n  if (typeof opts !== 'object' || Array.isArray(opts)) {\n    read = opts\n    opts = {}\n  }\n\n  var rs = new Proto(opts)\n  rs._from = Array.isArray(read) ? toFunction(read) : (read || noop)\n  return rs\n}\n\nfunction ctor(opts, read) {\n  if (typeof opts === 'function') {\n    read = opts\n    opts = {}\n  }\n\n  opts = defaults(opts)\n\n  inherits(Class, Readable)\n  function Class(override) {\n    if (!(this instanceof Class)) return new Class(override)\n    this._reading = false\n    this._callback = check\n    this.destroyed = false\n    Readable.call(this, override || opts)\n\n    var self = this\n    var hwm = this._readableState.highWaterMark\n\n    function check(err, data) {\n      if (self.destroyed) return\n      if (err) return self.destroy(err)\n      if (data === null) return self.push(null)\n      self._reading = false\n      if (self.push(data)) self._read(hwm)\n    }\n  }\n\n  Class.prototype._from = read || noop\n  Class.prototype._read = function(size) {\n    if (this._reading || this.destroyed) return\n    this._reading = true\n    this._from(size, this._callback)\n  }\n\n  Class.prototype.destroy = function(err) {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    var self = this\n    process.nextTick(function() {\n      if (err) self.emit('error', err)\n      self.emit('close')\n    })\n  }\n\n  return Class\n}\n\nfunction obj(opts, read) {\n  if (typeof opts === 'function' || Array.isArray(opts)) {\n    read = opts\n    opts = {}\n  }\n\n  opts = defaults(opts)\n  opts.objectMode = true\n  opts.highWaterMark = 16\n\n  return from2(opts, read)\n}\n\nfunction noop () {}\n\nfunction defaults(opts) {\n  opts = opts || {}\n  return opts\n}\n","module.exports = codecs\n\nvar fromBuffer = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from\n  : Buffer\n\ncodecs.ascii = createString('ascii')\ncodecs.utf8 = createString('utf-8')\ncodecs.hex = createString('hex')\ncodecs.base64 = createString('base64')\ncodecs.ucs2 = createString('ucs2')\ncodecs.utf16le = createString('utf16le')\ncodecs.ndjson = createJSON(true)\ncodecs.json = createJSON(false)\ncodecs.binary = {\n  encode: function encodeBinary (obj) {\n    return typeof obj === 'string' ? fromBuffer(obj, 'utf-8') : obj\n  },\n  decode: function decodeBinary (buf) {\n    return buf\n  }\n}\n\nfunction codecs (fmt) {\n  if (typeof fmt === 'object' && fmt && fmt.encode && fmt.decode) return fmt\n\n  switch (fmt) {\n    case 'ndjson': return codecs.ndjson\n    case 'json': return codecs.json\n    case 'ascii': return codecs.ascii\n    case 'utf-8':\n    case 'utf8': return codecs.utf8\n    case 'hex': return codecs.hex\n    case 'base64': return codecs.base64\n    case 'ucs-2':\n    case 'ucs2': return codecs.ucs2\n    case 'utf16-le':\n    case 'utf16le': return codecs.utf16le\n  }\n\n  return codecs.binary\n}\n\nfunction createJSON (newline) {\n  return {\n    encode: newline ? encodeNDJSON : encodeJSON,\n    decode: function decodeJSON (buf) {\n      return JSON.parse(buf.toString())\n    }\n  }\n\n  function encodeJSON (val) {\n    return new Buffer(JSON.stringify(val))\n  }\n\n  function encodeNDJSON (val) {\n    return new Buffer(JSON.stringify(val) + '\\n')\n  }\n}\n\nfunction createString (type) {\n  return {\n    encode: function encodeString (val) {\n      if (typeof val !== 'string') val = val.toString()\n      return fromBuffer(val, type)\n    },\n    decode: function decodeString (buf) {\n      return buf.toString(type)\n    }\n  }\n}\n","'use strict'\n\nvar nextTick = nextTickArgs\nprocess.nextTick(upgrade, 42) // pass 42 and see if upgrade is called with it\n\nmodule.exports = thunky\n\nfunction thunky (fn) {\n  var state = run\n  return thunk\n\n  function thunk (callback) {\n    state(callback || noop)\n  }\n\n  function run (callback) {\n    var stack = [callback]\n    state = wait\n    fn(done)\n\n    function wait (callback) {\n      stack.push(callback)\n    }\n\n    function done (err) {\n      var args = arguments\n      state = isError(err) ? run : finished\n      while (stack.length) finished(stack.shift())\n\n      function finished (callback) {\n        nextTick(apply, callback, args)\n      }\n    }\n  }\n}\n\nfunction isError (err) { // inlined from util so this works in the browser\n  return Object.prototype.toString.call(err) === '[object Error]'\n}\n\nfunction noop () {}\n\nfunction apply (callback, args) {\n  callback.apply(null, args)\n}\n\nfunction upgrade (val) {\n  if (val === 42) nextTick = process.nextTick\n}\n\nfunction nextTickArgs (fn, a, b) {\n  process.nextTick(function () {\n    fn(a, b)\n  })\n}\n","module.exports = batcher\n\nfunction batcher (run) {\n  var running = false\n  var pendingBatch = null\n  var pendingCallbacks = null\n  var callbacks = null\n\n  return append\n\n  function done (err) {\n    if (callbacks) callAll(callbacks, err)\n\n    running = false\n    callbacks = pendingCallbacks\n    var nextBatch = pendingBatch\n\n    pendingBatch = null\n    pendingCallbacks = null\n\n    if (!nextBatch || !nextBatch.length) {\n      if (!callbacks || !callbacks.length) {\n        callbacks = null\n        return\n      }\n      if (!nextBatch) nextBatch = []\n    }\n\n    running = true\n    run(nextBatch, done)\n  }\n\n  function append (val, cb) {\n    if (running) {\n      if (!pendingBatch) {\n        pendingBatch = []\n        pendingCallbacks = []\n      }\n      pushAll(pendingBatch, val)\n      if (cb) pendingCallbacks.push(cb)\n    } else {\n      if (cb) callbacks = [cb]\n      running = true\n      run(Array.isArray(val) ? val : [val], done)\n    }\n  }\n}\n\nfunction pushAll (list, val) {\n  if (Array.isArray(val)) pushArray(list, val)\n  else list.push(val)\n}\n\nfunction pushArray (list, val) {\n  for (var i = 0; i < val.length; i++) list.push(val[i])\n}\n\nfunction callAll (list, err) {\n  for (var i = 0; i < list.length; i++) list[i](err)\n}\n","var inherits = require('util').inherits\nvar RandomAccess = require('random-access-storage')\nvar fs = require('fs')\nvar mkdirp = require('mkdirp')\nvar path = require('path')\nvar constants = fs.constants || require('constants')\n\nvar READONLY = constants.O_RDONLY\nvar READWRITE = constants.O_RDWR | constants.O_CREAT\n\nmodule.exports = RandomAccessFile\n\nfunction RandomAccessFile (filename, opts) {\n  if (!(this instanceof RandomAccessFile)) return new RandomAccessFile(filename, opts)\n  RandomAccess.call(this)\n\n  if (!opts) opts = {}\n  if (opts.directory) filename = path.join(opts.directory, filename)\n\n  this.directory = opts.directory || null\n  this.filename = filename\n  this.fd = 0\n\n  // makes random-access-storage open in writable mode first\n  if (opts.writable || opts.truncate) this.preferReadonly = false\n\n  this._size = opts.size || opts.length || 0\n  this._truncate = !!opts.truncate || this._size > 0\n  this._rmdir = !!opts.rmdir\n}\n\ninherits(RandomAccessFile, RandomAccess)\n\nRandomAccessFile.prototype._open = function (req) {\n  var self = this\n\n  mkdirp(path.dirname(this.filename), ondir)\n\n  function ondir (err) {\n    if (err) return req.callback(err)\n    open(self, READWRITE, req)\n  }\n}\n\nRandomAccessFile.prototype._openReadonly = function (req) {\n  open(this, READONLY, req)\n}\n\nRandomAccessFile.prototype._write = function (req) {\n  var data = req.data\n  var fd = this.fd\n\n  fs.write(fd, data, 0, req.size, req.offset, onwrite)\n\n  function onwrite (err, wrote) {\n    if (err) return req.callback(err)\n\n    req.size -= wrote\n    req.offset += wrote\n\n    if (!req.size) return req.callback(null)\n    fs.write(fd, data, data.length - req.size, req.size, req.offset, onwrite)\n  }\n}\n\nRandomAccessFile.prototype._read = function (req) {\n  var data = req.data || Buffer.allocUnsafe(req.size)\n  var fd = this.fd\n\n  if (!req.size) return process.nextTick(readEmpty, req)\n  fs.read(fd, data, 0, req.size, req.offset, onread)\n\n  function onread (err, read) {\n    if (err) return req.callback(err)\n    if (!read) return req.callback(new Error('Could not satisfy length'))\n\n    req.size -= read\n    req.offset += read\n\n    if (!req.size) return req.callback(null, data)\n    fs.read(fd, data, data.length - req.size, req.size, req.offset, onread)\n  }\n}\n\nRandomAccessFile.prototype._del = function (req) {\n  var fd = this.fd\n\n  fs.fstat(fd, onstat)\n\n  function onstat (err, st) {\n    if (err) return req.callback(err)\n    if (req.offset + req.size < st.size) return req.callback(null)\n    fs.ftruncate(fd, req.offset, ontruncate)\n  }\n\n  function ontruncate (err) {\n    req.callback(err)\n  }\n}\n\nRandomAccessFile.prototype._stat = function (req) {\n  fs.fstat(this.fd, onstat)\n\n  function onstat (err, st) {\n    req.callback(err, st)\n  }\n}\n\nRandomAccessFile.prototype._close = function (req) {\n  var self = this\n\n  fs.close(this.fd, onclose)\n\n  function onclose (err) {\n    if (err) return req.callback(err)\n    self.fd = 0\n    req.callback(null)\n  }\n}\n\nRandomAccessFile.prototype._destroy = function (req) {\n  var self = this\n\n  var root = this.directory && path.resolve(path.join(this.directory, '.'))\n  var dir = path.resolve(path.dirname(this.filename))\n\n  fs.unlink(this.filename, onunlink)\n\n  function onunlink (err) {\n    if (!self._rmdir || !root || dir === root) return req.callback(err)\n    fs.rmdir(dir, onrmdir)\n  }\n\n  function onrmdir (err) {\n    dir = path.join(dir, '..')\n    if (err || dir === root) return req.callback(null)\n    fs.rmdir(dir, onrmdir)\n  }\n}\n\nfunction open (self, mode, req) {\n  fs.open(self.filename, mode, onopen)\n\n  function onopen (err, fd) {\n    if (err) return req.callback(err)\n\n    var old = self.fd\n    self.fd = fd\n    if (!old) return oncloseoldfd(null)\n\n    // if we are moving from readonly -> readwrite, close the old fd\n    fs.close(old, oncloseoldfd)\n  }\n\n  function oncloseoldfd (err) {\n    if (err) return onerrorafteropen(err)\n    if (!self._truncate || mode === READONLY) return req.callback(null)\n    fs.ftruncate(self.fd, self._size, ontruncate)\n  }\n\n  function ontruncate (err) {\n    if (err) return onerrorafteropen(err)\n    req.callback(null)\n  }\n\n  function onerrorafteropen (err) {\n    fs.close(self.fd, function () {\n      self.fd = 0\n      req.callback(err)\n    })\n  }\n}\n\nfunction readEmpty (req) {\n  req.callback(null, Buffer.alloc(0))\n}\n","var events = require('events')\nvar inherits = require('inherits')\n\nvar NOT_READABLE = defaultImpl(new Error('Not readable'))\nvar NOT_WRITABLE = defaultImpl(new Error('Not writable'))\nvar NOT_DELETABLE = defaultImpl(new Error('Not deletable'))\nvar NOT_STATABLE = defaultImpl(new Error('Not statable'))\nvar NO_OPEN_READABLE = defaultImpl(new Error('No readonly open'))\n\nmodule.exports = RandomAccess\n\nfunction RandomAccess (opts) {\n  if (!(this instanceof RandomAccess)) return new RandomAccess(opts)\n  events.EventEmitter.call(this)\n\n  this._queued = []\n  this._pending = 0\n  this._needsOpen = true\n\n  this.opened = false\n  this.closed = false\n  this.destroyed = false\n\n  if (opts) {\n    if (opts.openReadonly) this._openReadonly = opts.openReadonly\n    if (opts.open) this._open = opts.open\n    if (opts.read) this._read = opts.read\n    if (opts.write) this._write = opts.write\n    if (opts.del) this._del = opts.del\n    if (opts.stat) this._stat = opts.stat\n    if (opts.close) this._close = opts.close\n    if (opts.destroy) this._destroy = opts.destroy\n  }\n\n  this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE\n  this.readable = this._read !== NOT_READABLE\n  this.writable = this._write !== NOT_WRITABLE\n  this.deletable = this._del !== NOT_DELETABLE\n  this.statable = this._stat !== NOT_STATABLE\n}\n\ninherits(RandomAccess, events.EventEmitter)\n\nRandomAccess.prototype.open = function (cb) {\n  if (!cb) cb = noop\n  if (this.opened && !this._needsOpen) return process.nextTick(cb, null)\n  queueAndRun(this, new Request(this, 0, 0, 0, null, cb))\n}\n\nRandomAccess.prototype._open = defaultImpl(null)\nRandomAccess.prototype._openReadonly = NO_OPEN_READABLE\n\nRandomAccess.prototype.read = function (offset, size, cb) {\n  this.run(new Request(this, 1, offset, size, null, cb))\n}\n\nRandomAccess.prototype._read = NOT_READABLE\n\nRandomAccess.prototype.write = function (offset, data, cb) {\n  if (!cb) cb = noop\n  openWritable(this)\n  this.run(new Request(this, 2, offset, data.length, data, cb))\n}\n\nRandomAccess.prototype._write = NOT_WRITABLE\n\nRandomAccess.prototype.del = function (offset, size, cb) {\n  if (!cb) cb = noop\n  openWritable(this)\n  this.run(new Request(this, 3, offset, size, null, cb))\n}\n\nRandomAccess.prototype._del = NOT_DELETABLE\n\nRandomAccess.prototype.stat = function (cb) {\n  this.run(new Request(this, 4, 0, 0, null, cb))\n}\n\nRandomAccess.prototype._stat = NOT_STATABLE\n\nRandomAccess.prototype.close = function (cb) {\n  if (!cb) cb = noop\n  if (this.closed) return process.nextTick(cb, null)\n  queueAndRun(this, new Request(this, 5, 0, 0, null, cb))\n}\n\nRandomAccess.prototype._close = defaultImpl(null)\n\nRandomAccess.prototype.destroy = function (cb) {\n  if (!cb) cb = noop\n  if (!this.closed) this.close(noop)\n  queueAndRun(this, new Request(this, 6, 0, 0, null, cb))\n}\n\nRandomAccess.prototype._destroy = defaultImpl(null)\n\nRandomAccess.prototype.run = function (req) {\n  if (this._needsOpen) this.open(noop)\n  if (this._queued.length) this._queued.push(req)\n  else req._run()\n}\n\nfunction noop () {}\n\nfunction Request (self, type, offset, size, data, cb) {\n  this.type = type\n  this.offset = offset\n  this.data = data\n  this.size = size\n  this.storage = self\n\n  this._sync = false\n  this._callback = cb\n  this._openError = null\n}\n\nRequest.prototype._maybeOpenError = function (err) {\n  if (this.type !== 0) return\n  var queued = this.storage._queued\n  for (var i = 0; i < queued.length; i++) queued[i]._openError = err\n}\n\nRequest.prototype._unqueue = function (err) {\n  var ra = this.storage\n  var queued = ra._queued\n\n  if (!err) {\n    switch (this.type) {\n      case 0:\n        if (!ra.opened) {\n          ra.opened = true\n          ra.emit('open')\n        }\n        break\n\n      case 5:\n        if (!ra.closed) {\n          ra.closed = true\n          ra.emit('close')\n        }\n        break\n\n      case 6:\n        if (!ra.destroyed) {\n          ra.destroyed = true\n          ra.emit('destroy')\n        }\n        break\n    }\n  } else {\n    this._maybeOpenError(err)\n  }\n\n  if (queued.length && queued[0] === this) queued.shift()\n  if (!--ra._pending && queued.length) queued[0]._run()\n}\n\nRequest.prototype.callback = function (err, val) {\n  if (this._sync) return nextTick(this, err, val)\n  this._unqueue(err)\n  this._callback(err, val)\n}\n\nRequest.prototype._openAndNotClosed = function () {\n  var ra = this.storage\n  if (ra.opened && !ra.closed) return true\n  if (!ra.opened) nextTick(this, this._openError || new Error('Not opened'))\n  else if (ra.closed) nextTick(this, new Error('Closed'))\n  return false\n}\n\nRequest.prototype._open = function () {\n  var ra = this.storage\n\n  if (ra.opened && !ra._needsOpen) return nextTick(this, null)\n  if (ra.closed) return nextTick(this, new Error('Closed'))\n\n  ra._needsOpen = false\n  if (ra.preferReadonly) ra._openReadonly(this)\n  else ra._open(this)\n}\n\nRequest.prototype._run = function () {\n  var ra = this.storage\n  ra._pending++\n\n  this._sync = true\n\n  switch (this.type) {\n    case 0:\n      this._open()\n      break\n\n    case 1:\n      if (this._openAndNotClosed()) ra._read(this)\n      break\n\n    case 2:\n      if (this._openAndNotClosed()) ra._write(this)\n      break\n\n    case 3:\n      if (this._openAndNotClosed()) ra._del(this)\n      break\n\n    case 4:\n      if (this._openAndNotClosed()) ra._stat(this)\n      break\n\n    case 5:\n      if (ra.closed || !ra.opened) nextTick(this, null)\n      else ra._close(this)\n      break\n\n    case 6:\n      if (ra.destroyed) nextTick(this, null)\n      else ra._destroy(this)\n      break\n  }\n\n  this._sync = false\n}\n\nfunction queueAndRun (self, req) {\n  self._queued.push(req)\n  if (!self._pending) req._run()\n}\n\nfunction openWritable (self) {\n  if (self.preferReadonly) {\n    self._needsOpen = true\n    self.preferReadonly = false\n  }\n}\n\nfunction defaultImpl (err) {\n  return overridable\n\n  function overridable (req) {\n    nextTick(req, err)\n  }\n}\n\nfunction nextTick (req, err, val) {\n  process.nextTick(nextTickCallback, req, err, val)\n}\n\nfunction nextTickCallback (req, err, val) {\n  req.callback(err, val)\n}\n","var flat = require('flat-tree')\nvar rle = require('bitfield-rle')\nvar pager = require('memory-pager')\nvar bitfield = require('sparse-bitfield')\nvar allocUnsafe = require('buffer-alloc-unsafe')\n\nvar INDEX_UPDATE_MASK = [63, 207, 243, 252]\nvar INDEX_ITERATE_MASK = [0, 192, 240, 252]\nvar DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255]\nvar DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254]\nvar MAP_PARENT_RIGHT = new Array(256)\nvar MAP_PARENT_LEFT = new Array(256)\nvar NEXT_DATA_0_BIT = new Array(256)\nvar NEXT_INDEX_0_BIT = new Array(256)\nvar TOTAL_1_BITS = new Array(256)\n\nfor (var i = 0; i < 256; i++) {\n  var a = (i & (15 << 4)) >> 4\n  var b = i & 15\n  var nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]\n  MAP_PARENT_RIGHT[i] = ((a === 15 ? 3 : a === 0 ? 0 : 1) << 2) | (b === 15 ? 3 : b === 0 ? 0 : 1)\n  MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4\n  NEXT_DATA_0_BIT[i] = i === 255 ? -1 : (8 - Math.ceil(Math.log(256 - i) / Math.log(2)))\n  NEXT_INDEX_0_BIT[i] = i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2)\n  TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 0x0F]\n}\n\nmodule.exports = Bitfield\n\nfunction Bitfield (pageSize, pages) {\n  if (!(this instanceof Bitfield)) return new Bitfield(pageSize, pages)\n  if (!pageSize) pageSize = 2048 + 1024 + 512\n\n  var deduplicate = allocUnsafe(pageSize)\n  deduplicate.fill(255)\n\n  this.indexSize = pageSize - 2048 - 1024\n  this.pages = pager(pageSize, { deduplicate })\n\n  if (pages) {\n    for (var i = 0; i < pages.length; i++) {\n      this.pages.set(i, pages[i])\n    }\n  }\n\n  this.data = bitfield({\n    pageSize: 1024,\n    pageOffset: 0,\n    pages: this.pages,\n    trackUpdates: true\n  })\n\n  this.tree = bitfield({\n    pageSize: 2048,\n    pageOffset: 1024,\n    pages: this.pages,\n    trackUpdates: true\n  })\n\n  this.index = bitfield({\n    pageSize: this.indexSize,\n    pageOffset: 1024 + 2048,\n    pages: this.pages,\n    trackUpdates: true\n  })\n\n  this.length = this.data.length\n  this._iterator = flat.iterator(0)\n}\n\nBitfield.prototype.set = function (i, value) {\n  var o = i & 7\n  i = (i - o) / 8\n  var v = value ? this.data.getByte(i) | (128 >> o) : this.data.getByte(i) & DATA_UPDATE_MASK[o]\n\n  if (!this.data.setByte(i, v)) return false\n  this.length = this.data.length\n  this._setIndex(i, v)\n  return true\n}\n\nBitfield.prototype.get = function (i) {\n  return this.data.get(i)\n}\n\nBitfield.prototype.total = function (start, end) {\n  if (!start || start < 0) start = 0\n  if (!end) end = this.data.length\n  if (end < start) return 0\n  if (end > this.data.length) {\n    this._expand(end)\n  }\n  var o = start & 7\n  var e = end & 7\n  var pos = (start - o) / 8\n  var last = (end - e) / 8\n  var leftMask = (255 - (o ? DATA_ITERATE_MASK[o - 1] : 0))\n  var rightMask = (e ? DATA_ITERATE_MASK[e - 1] : 0)\n  var byte = this.data.getByte(pos)\n  if (pos === last) {\n    return TOTAL_1_BITS[byte & leftMask & rightMask]\n  }\n  var total = TOTAL_1_BITS[byte & leftMask]\n  for (var i = pos + 1; i < last; i++) {\n    total += TOTAL_1_BITS[this.data.getByte(i)]\n  }\n  total += TOTAL_1_BITS[this.data.getByte(last) & rightMask]\n  return total\n}\n\n// TODO: use the index to speed this up *a lot*\nBitfield.prototype.compress = function (start, length) {\n  if (!start && !length) return rle.encode(this.data.toBuffer())\n\n  var buf = Buffer.alloc(length)\n  var p = start / this.data.pageSize / 8\n  var end = p + length / this.data.pageSize / 8\n  var offset = p * this.data.pageSize\n\n  for (; p < end; p++) {\n    var page = this.data.pages.pages[p]\n    if (!page || !page.buffer) continue\n    page.buffer.copy(buf, p * this.data.pageSize - offset, this.data.pageOffset, this.data.pageOffset + this.data.pageSize)\n  }\n\n  return rle.encode(buf)\n}\n\nBitfield.prototype._setIndex = function (i, value) {\n  //                    (a + b | c + d | e + f | g + h)\n  // -> (a | b | c | d)                                (e | f | g | h)\n  //\n\n  var o = i & 3\n  i = (i - o) / 4\n\n  var bitfield = this.index\n  var ite = this._iterator\n  var start = 2 * i\n  var byte = (bitfield.getByte(start) & INDEX_UPDATE_MASK[o]) | (getIndexValue(value) >> (2 * o))\n  var len = bitfield.length\n  var maxLength = this.pages.length * this.indexSize\n\n  ite.seek(start)\n\n  while (ite.index < maxLength && bitfield.setByte(ite.index, byte)) {\n    if (ite.isLeft()) {\n      byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]\n    } else {\n      byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]\n    }\n    ite.parent()\n  }\n\n  if (len !== bitfield.length) this._expand(len)\n\n  return ite.index !== start\n}\n\nBitfield.prototype._expand = function (len) {\n  var roots = flat.fullRoots(2 * len)\n  var bitfield = this.index\n  var ite = this._iterator\n  var byte = 0\n\n  for (var i = 0; i < roots.length; i++) {\n    ite.seek(roots[i])\n    byte = bitfield.getByte(ite.index)\n\n    do {\n      if (ite.isLeft()) {\n        byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]\n      } else {\n        byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]\n      }\n    } while (setByteNoAlloc(bitfield, ite.parent(), byte))\n  }\n}\n\nfunction setByteNoAlloc (bitfield, i, b) {\n  if (8 * i >= bitfield.length) return false\n  return bitfield.setByte(i, b)\n}\n\nBitfield.prototype.iterator = function (start, end) {\n  var ite = new Iterator(this)\n\n  ite.range(start || 0, end || this.length)\n  ite.seek(0)\n\n  return ite\n}\n\nfunction Iterator (bitfield) {\n  this.start = 0\n  this.end = 0\n\n  this._indexEnd = 0\n  this._pos = 0\n  this._byte = 0\n  this._bitfield = bitfield\n}\n\nIterator.prototype.range = function (start, end) {\n  this.start = start\n  this.end = end\n  this._indexEnd = 2 * Math.ceil(end / 32)\n\n  if (this.end > this._bitfield.length) {\n    this._bitfield._expand(this.end)\n  }\n\n  return this\n}\n\nIterator.prototype.seek = function (offset) {\n  offset += this.start\n  if (offset < this.start) offset = this.start\n\n  if (offset >= this.end) {\n    this._pos = -1\n    return this\n  }\n\n  var o = offset & 7\n\n  this._pos = (offset - o) / 8\n  this._byte = this._bitfield.data.getByte(this._pos) | (o ? DATA_ITERATE_MASK[o - 1] : 0)\n\n  return this\n}\n\nIterator.prototype.random = function () {\n  var i = this.seek(Math.floor(Math.random() * (this.end - this.start))).next()\n  return i === -1 ? this.seek(0).next() : i\n}\n\nIterator.prototype.next = function () {\n  if (this._pos === -1) return -1\n\n  var dataBitfield = this._bitfield.data\n  var free = NEXT_DATA_0_BIT[this._byte]\n\n  while (free === -1) {\n    this._byte = dataBitfield.getByte(++this._pos)\n    free = NEXT_DATA_0_BIT[this._byte]\n\n    if (free === -1) {\n      this._pos = this._skipAhead(this._pos)\n      if (this._pos === -1) return -1\n\n      this._byte = dataBitfield.getByte(this._pos)\n      free = NEXT_DATA_0_BIT[this._byte]\n    }\n  }\n\n  this._byte |= DATA_ITERATE_MASK[free]\n\n  var n = 8 * this._pos + free\n  return n < this.end ? n : -1\n}\n\nIterator.prototype.peek = function () {\n  if (this._pos === -1) return -1\n\n  var free = NEXT_DATA_0_BIT[this._byte]\n  var n = 8 * this._pos + free\n  return n < this.end ? n : -1\n}\n\nIterator.prototype._skipAhead = function (start) {\n  var indexBitfield = this._bitfield.index\n  var treeEnd = this._indexEnd\n  var ite = this._bitfield._iterator\n  var o = start & 3\n\n  ite.seek(2 * ((start - o) / 4))\n\n  var treeByte = indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o]\n\n  while (NEXT_INDEX_0_BIT[treeByte] === -1) {\n    if (ite.isLeft()) {\n      ite.next()\n    } else {\n      ite.next()\n      ite.parent()\n    }\n\n    if (rightSpan(ite) >= treeEnd) {\n      while (rightSpan(ite) >= treeEnd && isParent(ite)) ite.leftChild()\n      if (rightSpan(ite) >= treeEnd) return -1\n    }\n\n    treeByte = indexBitfield.getByte(ite.index)\n  }\n\n  while (ite.factor > 2) {\n    if (NEXT_INDEX_0_BIT[treeByte] < 2) ite.leftChild()\n    else ite.rightChild()\n\n    treeByte = indexBitfield.getByte(ite.index)\n  }\n\n  var free = NEXT_INDEX_0_BIT[treeByte]\n  if (free === -1) free = 4\n\n  var next = ite.index * 2 + free\n\n  return next <= start ? start + 1 : next\n}\n\nfunction rightSpan (ite) {\n  return ite.index + ite.factor / 2 - 1\n}\n\nfunction isParent (ite) {\n  return ite.index & 1\n}\n\nfunction getIndexValue (n) {\n  switch (n) {\n    case 255: return 192\n    case 0: return 0\n    default: return 64\n  }\n}\n","var varint = require('varint')\nvar alloc = require('buffer-alloc-unsafe')\n\nmodule.exports = align(1)\n\nfunction align (n) {\n  var exports = {}\n\n  exports.align = align\n\n  exports.encode = encode\n  exports.encode.bytes = 0\n  exports.encodingLength = encodingLength\n\n  exports.decode = decode\n  exports.decode.bytes = 0\n  exports.decodingLength = decodingLength\n\n  return exports\n\n  function State (input, output, offset) {\n    this.inputOffset = 0\n    this.inputLength = input.length\n    this.input = input\n    this.outputOffset = offset\n    this.output = output\n  }\n\n  function encode (bitfield, buffer, offset) {\n    if (!offset) offset = 0\n    if (!buffer) buffer = alloc(encodingLength(bitfield))\n    var state = new State(bitfield, buffer, offset)\n    rle(state)\n    encode.bytes = state.outputOffset - offset\n    return buffer\n  }\n\n  function encodingLength (bitfield) {\n    var state = new State(bitfield, null, 0)\n    rle(state)\n    return state.outputOffset\n  }\n\n  function decode (buffer, offset) {\n    if (!offset) offset = 0\n\n    var bitfield = alloc(decodingLength(buffer, offset))\n    var ptr = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      var repeat = next & 1\n      var len = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      offset += varint.decode.bytes\n\n      if (repeat) {\n        bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)\n      } else {\n        buffer.copy(bitfield, ptr, offset, offset + len)\n        offset += len\n      }\n\n      ptr += len\n    }\n\n    bitfield.fill(0, ptr)\n    decode.bytes = buffer.length - offset\n\n    return bitfield\n  }\n\n  function decodingLength (buffer, offset) {\n    if (!offset) offset = 0\n\n    var len = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      offset += varint.decode.bytes\n\n      var repeat = next & 1\n      var slice = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      len += slice\n      if (!repeat) offset += slice\n    }\n\n    if (offset > buffer.length) throw new Error('Invalid RLE bitfield')\n\n    if (len & (n - 1)) return len + (n - (len & (n - 1)))\n\n    return len\n  }\n\n  function rle (state) {\n    var len = 0\n    var bits = 0\n    var input = state.input\n\n    while (state.inputLength > 0 && !input[state.inputLength - 1]) state.inputLength--\n\n    for (var i = 0; i < state.inputLength; i++) {\n      if (input[i] === bits) {\n        len++\n        continue\n      }\n\n      if (len) encodeUpdate(state, i, len, bits)\n\n      if (input[i] === 0 || input[i] === 255) {\n        bits = input[i]\n        len = 1\n      } else {\n        len = 0\n      }\n    }\n\n    if (len) encodeUpdate(state, state.inputLength, len, bits)\n    encodeFinal(state)\n  }\n\n  function encodeHead (state, end) {\n    var headLength = end - state.inputOffset\n    varint.encode(2 * headLength, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.input.copy(state.output, state.outputOffset, state.inputOffset, end)\n    state.outputOffset += headLength\n  }\n\n  function encodeFinal (state) {\n    var headLength = state.inputLength - state.inputOffset\n    if (!headLength) return\n\n    if (!state.output) {\n      state.outputOffset += (headLength + varint.encodingLength(2 * headLength))\n    } else {\n      encodeHead(state, state.inputLength)\n    }\n\n    state.inputOffset = state.inputLength\n  }\n\n  function encodeUpdate (state, i, len, bit) {\n    var headLength = i - len - state.inputOffset\n    var headCost = (headLength ? varint.encodingLength(2 * headLength) + headLength : 0)\n    var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1\n    var encCost = headCost + varint.encodingLength(enc)\n    var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset\n\n    if (encCost >= baseCost) return\n\n    if (!state.output) {\n      state.outputOffset += encCost\n      state.inputOffset = i\n      return\n    }\n\n    if (headLength) encodeHead(state, i - len)\n\n    varint.encode(enc, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.inputOffset = i\n  }\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if(counter >= l) {\n      read.bytes = 0\n      read.bytesRead = 0 // DEPRECATED\n      return undefined\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","function allocUnsafe (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  }\n\n  if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n\n  if (Buffer.allocUnsafe) {\n    return Buffer.allocUnsafe(size)\n  } else {\n    return new Buffer(size)\n  }\n}\n\nmodule.exports = allocUnsafe\n","module.exports = Pager\n\nfunction Pager (pageSize, opts) {\n  if (!(this instanceof Pager)) return new Pager(pageSize, opts)\n\n  this.length = 0\n  this.updates = []\n  this.path = new Uint16Array(4)\n  this.pages = new Array(32768)\n  this.maxPages = this.pages.length\n  this.level = 0\n  this.pageSize = pageSize || 1024\n  this.deduplicate = opts ? opts.deduplicate : null\n  this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null\n}\n\nPager.prototype.updated = function (page) {\n  while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {\n    page.deduplicate++\n    if (page.deduplicate === this.deduplicate.length) {\n      page.deduplicate = 0\n      if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate\n      break\n    }\n  }\n  if (page.updated || !this.updates) return\n  page.updated = true\n  this.updates.push(page)\n}\n\nPager.prototype.lastUpdate = function () {\n  if (!this.updates || !this.updates.length) return null\n  var page = this.updates.pop()\n  page.updated = false\n  return page\n}\n\nPager.prototype._array = function (i, noAllocate) {\n  if (i >= this.maxPages) {\n    if (noAllocate) return\n    grow(this, i)\n  }\n\n  factor(i, this.path)\n\n  var arr = this.pages\n\n  for (var j = this.level; j > 0; j--) {\n    var p = this.path[j]\n    var next = arr[p]\n\n    if (!next) {\n      if (noAllocate) return\n      next = arr[p] = new Array(32768)\n    }\n\n    arr = next\n  }\n\n  return arr\n}\n\nPager.prototype.get = function (i, noAllocate) {\n  var arr = this._array(i, noAllocate)\n  var first = this.path[0]\n  var page = arr && arr[first]\n\n  if (!page && !noAllocate) {\n    page = arr[first] = new Page(i, alloc(this.pageSize))\n    if (i >= this.length) this.length = i + 1\n  }\n\n  if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {\n    page.buffer = copy(page.buffer)\n    page.deduplicate = 0\n  }\n\n  return page\n}\n\nPager.prototype.set = function (i, buf) {\n  var arr = this._array(i, false)\n  var first = this.path[0]\n\n  if (i >= this.length) this.length = i + 1\n\n  if (!buf || (this.zeros && buf.equals && buf.equals(this.zeros))) {\n    arr[first] = undefined\n    return\n  }\n\n  if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {\n    buf = this.deduplicate\n  }\n\n  var page = arr[first]\n  var b = truncate(buf, this.pageSize)\n\n  if (page) page.buffer = b\n  else arr[first] = new Page(i, b)\n}\n\nPager.prototype.toBuffer = function () {\n  var list = new Array(this.length)\n  var empty = alloc(this.pageSize)\n  var ptr = 0\n\n  while (ptr < list.length) {\n    var arr = this._array(ptr, true)\n    for (var i = 0; i < 32768 && ptr < list.length; i++) {\n      list[ptr++] = (arr && arr[i]) ? arr[i].buffer : empty\n    }\n  }\n\n  return Buffer.concat(list)\n}\n\nfunction grow (pager, index) {\n  while (pager.maxPages < index) {\n    var old = pager.pages\n    pager.pages = new Array(32768)\n    pager.pages[0] = old\n    pager.level++\n    pager.maxPages *= 32768\n  }\n}\n\nfunction truncate (buf, len) {\n  if (buf.length === len) return buf\n  if (buf.length > len) return buf.slice(0, len)\n  var cpy = alloc(len)\n  buf.copy(cpy)\n  return cpy\n}\n\nfunction alloc (size) {\n  if (Buffer.alloc) return Buffer.alloc(size)\n  var buf = new Buffer(size)\n  buf.fill(0)\n  return buf\n}\n\nfunction copy (buf) {\n  var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length)\n  buf.copy(cpy)\n  return cpy\n}\n\nfunction Page (i, buf) {\n  this.offset = i * buf.length\n  this.buffer = buf\n  this.updated = false\n  this.deduplicate = 0\n}\n\nfunction factor (n, out) {\n  n = (n - (out[0] = (n & 32767))) / 32768\n  n = (n - (out[1] = (n & 32767))) / 32768\n  out[3] = ((n - (out[2] = (n & 32767))) / 32768) & 32767\n}\n","var pager = require('memory-pager')\n\nmodule.exports = Bitfield\n\nfunction Bitfield (opts) {\n  if (!(this instanceof Bitfield)) return new Bitfield(opts)\n  if (!opts) opts = {}\n  if (Buffer.isBuffer(opts)) opts = {buffer: opts}\n\n  this.pageOffset = opts.pageOffset || 0\n  this.pageSize = opts.pageSize || 1024\n  this.pages = opts.pages || pager(this.pageSize)\n\n  this.byteLength = this.pages.length * this.pageSize\n  this.length = 8 * this.byteLength\n\n  if (!powerOfTwo(this.pageSize)) throw new Error('The page size should be a power of two')\n\n  this._trackUpdates = !!opts.trackUpdates\n  this._pageMask = this.pageSize - 1\n\n  if (opts.buffer) {\n    for (var i = 0; i < opts.buffer.length; i += this.pageSize) {\n      this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize))\n    }\n    this.byteLength = opts.buffer.length\n    this.length = 8 * this.byteLength\n  }\n}\n\nBitfield.prototype.get = function (i) {\n  var o = i & 7\n  var j = (i - o) / 8\n\n  return !!(this.getByte(j) & (128 >> o))\n}\n\nBitfield.prototype.getByte = function (i) {\n  var o = i & this._pageMask\n  var j = (i - o) / this.pageSize\n  var page = this.pages.get(j, true)\n\n  return page ? page.buffer[o + this.pageOffset] : 0\n}\n\nBitfield.prototype.set = function (i, v) {\n  var o = i & 7\n  var j = (i - o) / 8\n  var b = this.getByte(j)\n\n  return this.setByte(j, v ? b | (128 >> o) : b & (255 ^ (128 >> o)))\n}\n\nBitfield.prototype.toBuffer = function () {\n  var all = alloc(this.pages.length * this.pageSize)\n\n  for (var i = 0; i < this.pages.length; i++) {\n    var next = this.pages.get(i, true)\n    var allOffset = i * this.pageSize\n    if (next) next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize)\n  }\n\n  return all\n}\n\nBitfield.prototype.setByte = function (i, b) {\n  var o = i & this._pageMask\n  var j = (i - o) / this.pageSize\n  var page = this.pages.get(j, false)\n\n  o += this.pageOffset\n\n  if (page.buffer[o] === b) return false\n  page.buffer[o] = b\n\n  if (i >= this.byteLength) {\n    this.byteLength = i + 1\n    this.length = this.byteLength * 8\n  }\n\n  if (this._trackUpdates) this.pages.updated(page)\n\n  return true\n}\n\nfunction alloc (n) {\n  if (Buffer.alloc) return Buffer.alloc(n)\n  var b = new Buffer(n)\n  b.fill(0)\n  return b\n}\n\nfunction powerOfTwo (x) {\n  return !(x & (x - 1))\n}\n","var flat = require('flat-tree')\nvar bitfield = require('sparse-bitfield')\n\nmodule.exports = TreeIndex\n\nfunction TreeIndex (bits) {\n  if (!(this instanceof TreeIndex)) return new TreeIndex(bits)\n  this.bitfield = bits || bitfield()\n}\n\nTreeIndex.prototype.proof = function (index, opts) {\n  if (!opts) opts = {}\n\n  var nodes = []\n  var remoteTree = opts.tree || new TreeIndex()\n  var digest = opts.digest || 0\n\n  if (!this.get(index)) return null\n  if (opts.hash) nodes.push(index) // always return hash - no matter what the digest says\n  if (digest === 1) return {nodes: nodes, verifiedBy: 0}\n\n  var roots = null\n  var sibling = index\n  var next = index\n  var hasRoot = digest & 1\n  digest = rightShift(digest)\n\n  while (digest) {\n    if (digest === 1 && hasRoot) {\n      if (this.get(next)) remoteTree.set(next)\n\n      // having a root implies having prev roots as well\n      // TODO: this can be optimized away be only sending \"newer\" roots,\n      // when sending roots\n      if (flat.sibling(next) < next) next = flat.sibling(next)\n      roots = flat.fullRoots(flat.rightSpan(next) + 2)\n      for (var i = 0; i < roots.length; i++) {\n        if (this.get(roots[i])) remoteTree.set(roots[i])\n      }\n      break\n    }\n\n    sibling = flat.sibling(next)\n    if (digest & 1) {\n      if (this.get(sibling)) remoteTree.set(sibling)\n    }\n    next = flat.parent(next)\n    digest = rightShift(digest)\n  }\n\n  next = index\n\n  while (!remoteTree.get(next)) {\n    sibling = flat.sibling(next)\n    if (!this.get(sibling)) {\n      // next is a local root\n      var verifiedBy = this.verifiedBy(next)\n      addFullRoots(verifiedBy, nodes, next, remoteTree)\n      return {nodes: nodes, verifiedBy: verifiedBy}\n    } else {\n      if (!remoteTree.get(sibling)) nodes.push(sibling)\n    }\n\n    next = flat.parent(next)\n  }\n\n  return {nodes: nodes, verifiedBy: 0}\n}\n\nTreeIndex.prototype.digest = function (index) {\n  if (this.get(index)) return 1\n\n  var digest = 0\n  var next = flat.sibling(index)\n  var max = Math.max(next + 2, this.bitfield.length) // TODO: make this less ... hacky\n\n  var bit = 2\n  var depth = flat.depth(index)\n  var parent = flat.parent(next, depth++)\n\n  while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {\n    if (this.get(next)) {\n      digest += bit // + cause in this case it's the same as | but works for large nums\n    }\n    if (this.get(parent)) {\n      digest += 2 * bit\n      if (!(digest & 1)) digest += 1\n      if (digest + 1 === 4 * bit) return 1\n      return digest\n    }\n    next = flat.sibling(parent)\n    parent = flat.parent(next, depth++)\n    bit *= 2\n  }\n\n  return digest\n}\n\nTreeIndex.prototype.blocks = function () {\n  var top = 0\n  var next = 0\n  var max = this.bitfield.length\n\n  while (flat.rightSpan(next) < max) {\n    next = flat.parent(next)\n    if (this.get(next)) top = next\n  }\n\n  return (this.get(top) ? this.verifiedBy(top) : 0) / 2\n}\n\nTreeIndex.prototype.roots = function () {\n  return flat.fullRoots(2 * this.blocks())\n}\n\nTreeIndex.prototype.verifiedBy = function (index, nodes) {\n  var hasIndex = this.get(index)\n  if (!hasIndex) return 0\n\n  // find root of current tree\n\n  var depth = flat.depth(index)\n  var top = index\n  var parent = flat.parent(top, depth++)\n  while (this.get(parent) && this.get(flat.sibling(top))) {\n    top = parent\n    parent = flat.parent(top, depth++)\n  }\n\n  // expand right down\n\n  depth--\n  while (depth) {\n    top = flat.leftChild(flat.index(depth, flat.offset(top, depth) + 1), depth)\n    depth--\n\n    while (!this.get(top) && depth) top = flat.leftChild(top, depth--)\n    if (nodes && this.get(top)) nodes.push(top)\n  }\n\n  return this.get(top) ? top + 2 : top\n}\n\nTreeIndex.prototype.get = function (index) {\n  return this.bitfield.get(index)\n}\n\nTreeIndex.prototype.set = function (index) {\n  if (!this.bitfield.set(index, true)) return false\n  while (this.bitfield.get(flat.sibling(index))) {\n    index = flat.parent(index)\n    if (!this.bitfield.set(index, true)) break\n  }\n  return true\n}\n\nfunction rightShift (n) {\n  return (n - (n & 1)) / 2\n}\n\nfunction addFullRoots (verifiedBy, nodes, root, remoteTree) {\n  var roots = flat.fullRoots(verifiedBy)\n  for (var i = 0; i < roots.length; i++) {\n    if (roots[i] !== root && !remoteTree.get(roots[i])) nodes.push(roots[i])\n  }\n}\n","var uint64be = require('uint64be')\nvar flat = require('flat-tree')\nvar alru = require('array-lru')\nvar bufferAlloc = require('buffer-alloc-unsafe')\n\nmodule.exports = Storage\n\nvar noarr = []\n\nfunction Storage (create, cacheSize) {\n  if (!(this instanceof Storage)) return new Storage(create, cacheSize)\n  cacheSize = typeof cacheSize === 'undefined' ? 65536 : cacheSize\n\n  this.cache = cacheSize > 0 ? alru(cacheSize, {indexedValues: true}) : null\n  this.key = null\n  this.secretKey = null\n  this.tree = null\n  this.data = null\n  this.bitfield = null\n  this.signatures = null\n  this.create = create\n}\n\nStorage.prototype.putData = function (index, data, nodes, cb) {\n  if (!cb) cb = noop\n  var self = this\n  if (!data.length) return cb(null)\n  this.dataOffset(index, nodes, function (err, offset, size) {\n    if (err) return cb(err)\n    if (size !== data.length) return cb(new Error('Unexpected data size'))\n    self.data.write(offset, data, cb)\n  })\n}\n\nStorage.prototype.getData = function (index, cb) {\n  var self = this\n  this.dataOffset(index, noarr, function (err, offset, size) {\n    if (err) return cb(err)\n    self.data.read(offset, size, cb)\n  })\n}\n\nStorage.prototype.nextSignature = function (index, cb) {\n  var self = this\n\n  this._getSignature(index, function (err, signature) {\n    if (err) return cb(err)\n    if (isBlank(signature)) return self.nextSignature(index + 1, cb)\n    cb(null, { index: index, signature: signature })\n  })\n}\n\nStorage.prototype.getSignature = function (index, cb) {\n  this._getSignature(index, function (err, signature) {\n    if (err) return cb(err)\n    if (isBlank(signature)) return cb(new Error('No signature found'))\n    cb(null, signature)\n  })\n}\n\nStorage.prototype._getSignature = function (index, cb) {\n  this.signatures.read(32 + 64 * index, 64, cb)\n}\n\nStorage.prototype.putSignature = function (index, signature, cb) {\n  this.signatures.write(32 + 64 * index, signature, cb)\n}\n\nStorage.prototype.dataOffset = function (index, cachedNodes, cb) {\n  var roots = flat.fullRoots(2 * index)\n  var self = this\n  var offset = 0\n  var pending = roots.length\n  var error = null\n  var blk = 2 * index\n\n  if (!pending) {\n    pending = 1\n    onnode(null, null)\n    return\n  }\n\n  for (var i = 0; i < roots.length; i++) {\n    var node = findNode(cachedNodes, roots[i])\n    if (node) onnode(null, node)\n    else this.getNode(roots[i], onnode)\n  }\n\n  function onlast (err, node) {\n    if (err) return cb(err)\n    cb(null, offset, node.size)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) offset += node.size\n    if (--pending) return\n\n    if (error) return cb(error)\n\n    var last = findNode(cachedNodes, blk)\n    if (last) onlast(null, last)\n    else self.getNode(blk, onlast)\n  }\n}\n\nStorage.prototype.getDataBatch = function (start, n, cb) {\n  var result = new Array(n)\n  var sizes = new Array(n)\n  var self = this\n\n  this.dataOffset(start, noarr, function (err, offset, size) {\n    if (err) return cb(err)\n\n    start++\n    n--\n\n    if (n <= 0) return ontree(null, null)\n    self.tree.read(32 + 80 * start, 80 * n - 40, ontree)\n\n    function ontree (err, buf) {\n      if (err) return cb(err)\n\n      var total = sizes[0] = size\n\n      if (buf) {\n        for (var i = 1; i < sizes.length; i++) {\n          sizes[i] = uint64be.decode(buf, 32 + (i - 1) * 80)\n          total += sizes[i]\n        }\n      }\n\n      self.data.read(offset, total, ondata)\n    }\n\n    function ondata (err, buf) {\n      if (err) return cb(err)\n      var total = 0\n      for (var i = 0; i < result.length; i++) {\n        result[i] = buf.slice(total, total += sizes[i])\n      }\n\n      cb(null, result)\n    }\n  })\n}\n\nStorage.prototype.getNode = function (index, cb) {\n  if (this.cache) {\n    var cached = this.cache.get(index)\n    if (cached) return cb(null, cached)\n  }\n\n  var self = this\n\n  this.tree.read(32 + 40 * index, 40, function (err, buf) {\n    if (err) return cb(err)\n\n    var hash = buf.slice(0, 32)\n    var size = uint64be.decode(buf, 32)\n\n    if (!size && isBlank(hash)) return cb(new Error('No node found'))\n\n    var val = new Node(index, hash, size, null)\n    if (self.cache) self.cache.set(index, val)\n    cb(null, val)\n  })\n}\n\nStorage.prototype.putNode = function (index, node, cb) {\n  if (!cb) cb = noop\n\n  // TODO: re-enable put cache. currently this causes a memleak\n  // because node.hash is a slice of the big data buffer on replicate\n  // if (this.cache) this.cache.set(index, node)\n\n  var buf = bufferAlloc(40)\n\n  node.hash.copy(buf, 0)\n  uint64be.encode(node.size, buf, 32)\n  this.tree.write(32 + 40 * index, buf, cb)\n}\n\nStorage.prototype.putBitfield = function (offset, data, cb) {\n  this.bitfield.write(32 + offset, data, cb)\n}\n\nStorage.prototype.close = function (cb) {\n  if (!cb) cb = noop\n  var missing = 6\n  var error = null\n\n  close(this.bitfield, done)\n  close(this.tree, done)\n  close(this.data, done)\n  close(this.key, done)\n  close(this.secretKey, done)\n  close(this.signatures, done)\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    cb(error)\n  }\n}\n\nStorage.prototype.openKey = function (opts, cb) {\n  if (typeof opts === 'function') return this.openKey({}, opts)\n  if (!this.key) this.key = this.create('key', opts)\n  this.key.read(0, 32, cb)\n}\n\nStorage.prototype.open = function (opts, cb) {\n  if (typeof opts === 'function') return this.open({}, opts)\n\n  var self = this\n  var error = null\n  var missing = 5\n\n  if (!this.key) this.key = this.create('key', opts)\n  if (!this.secretKey) this.secretKey = this.create('secret_key', opts)\n  if (!this.tree) this.tree = this.create('tree', opts)\n  if (!this.data) this.data = this.create('data', opts)\n  if (!this.bitfield) this.bitfield = this.create('bitfield', opts)\n  if (!this.signatures) this.signatures = this.create('signatures', opts)\n\n  var result = {\n    bitfield: [],\n    bitfieldPageSize: 3584, // we upgraded the page size to fix a bug\n    secretKey: null,\n    key: null\n  }\n\n  this.bitfield.read(0, 32, function (_, h) {\n    if (h) result.bitfieldPageSize = h.readUInt16BE(5)\n    self.bitfield.write(0, header(0, result.bitfieldPageSize, null), function (err) {\n      if (err) return cb(err)\n      readAll(self.bitfield, 32, result.bitfieldPageSize, function (err, pages) {\n        if (pages) result.bitfield = pages\n        done(err)\n      })\n    })\n  })\n\n  this.signatures.write(0, header(1, 64, 'Ed25519'), done)\n  this.tree.write(0, header(2, 40, 'BLAKE2b'), done)\n\n  // TODO: Improve the error handling here.\n  // I.e. if secretKey length === 64 and it fails, error\n\n  this.secretKey.read(0, 64, function (_, data) {\n    if (data) result.secretKey = data\n    done(null)\n  })\n\n  this.key.read(0, 32, function (_, data) {\n    if (data) result.key = data\n    done(null)\n  })\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    if (error) cb(error)\n    else cb(null, result)\n  }\n}\n\nStorage.Node = Node\n\nfunction noop () {}\n\nfunction header (type, size, name) {\n  var buf = bufferAlloc(32)\n  buf.fill(0)\n\n  // magic number\n  buf[0] = 5\n  buf[1] = 2\n  buf[2] = 87\n  buf[3] = type\n\n  // version\n  buf[4] = 0\n\n  // block size\n  buf.writeUInt16BE(size, 5)\n\n  if (name) {\n    // algo name\n    buf[7] = name.length\n    buf.write(name, 8)\n  }\n\n  return buf\n}\n\nfunction Node (index, hash, size) {\n  this.index = index\n  this.hash = hash\n  this.size = size\n}\n\nfunction findNode (nodes, index) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].index === index) return nodes[i]\n  }\n  return null\n}\n\nfunction isBlank (buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i]) return false\n  }\n  return true\n}\n\nfunction close (st, cb) {\n  if (st.close) st.close(cb)\n  else cb()\n}\n\nfunction statAndReadAll (st, offset, pageSize, cb) {\n  st.stat(function (err, stat) {\n    if (err) return cb(null, [])\n\n    var result = []\n\n    loop(null, null)\n\n    function loop (err, batch) {\n      if (err) return cb(err)\n\n      if (batch) {\n        offset += batch.length\n        for (var i = 0; i < batch.length; i += pageSize) {\n          result.push(batch.slice(i, i + pageSize))\n        }\n      }\n\n      var next = Math.min(stat.size - offset, 32 * pageSize)\n      if (!next) return cb(null, result)\n\n      st.read(offset, next, loop)\n    }\n  })\n}\n\nfunction readAll (st, offset, pageSize, cb) {\n  if (st.statable === true) return statAndReadAll(st, offset, pageSize, cb)\n\n  var bufs = []\n\n  st.read(offset, pageSize, loop)\n\n  function loop (err, buf) {\n    if (err) return cb(null, bufs)\n    bufs.push(buf)\n    st.read(offset + bufs.length * pageSize, pageSize, loop)\n  }\n}\n","var bufferAlloc = require('buffer-alloc')\n\nvar UINT_32_MAX = Math.pow(2, 32)\n\nexports.encodingLength = function () {\n  return 8\n}\n\nexports.encode = function (num, buf, offset) {\n  if (!buf) buf = bufferAlloc(8)\n  if (!offset) offset = 0\n\n  var top = Math.floor(num / UINT_32_MAX)\n  var rem = num - top * UINT_32_MAX\n\n  buf.writeUInt32BE(top, offset)\n  buf.writeUInt32BE(rem, offset + 4)\n  return buf\n}\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  var top = buf.readUInt32BE(offset)\n  var rem = buf.readUInt32BE(offset + 4)\n\n  return top * UINT_32_MAX + rem\n}\n\nexports.encode.bytes = 8\nexports.decode.bytes = 8\n","var bufferFill = require('buffer-fill')\nvar allocUnsafe = require('buffer-alloc-unsafe')\n\nmodule.exports = function alloc (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  }\n\n  if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n\n  if (Buffer.alloc) {\n    return Buffer.alloc(size, fill, encoding)\n  }\n\n  var buffer = allocUnsafe(size)\n\n  if (size === 0) {\n    return buffer\n  }\n\n  if (fill === undefined) {\n    return bufferFill(buffer, 0)\n  }\n\n  if (typeof encoding !== 'string') {\n    encoding = undefined\n  }\n\n  return bufferFill(buffer, fill, encoding)\n}\n","/* Node.js 6.4.0 and up has full support */\nvar hasFullSupport = (function () {\n  try {\n    if (!Buffer.isEncoding('latin1')) {\n      return false\n    }\n\n    var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4)\n\n    buf.fill('ab', 'ucs2')\n\n    return (buf.toString('hex') === '61006200')\n  } catch (_) {\n    return false\n  }\n}())\n\nfunction isSingleByte (val) {\n  return (val.length === 1 && val.charCodeAt(0) < 256)\n}\n\nfunction fillWithNumber (buffer, val, start, end) {\n  if (start < 0 || end > buffer.length) {\n    throw new RangeError('Out of range index')\n  }\n\n  start = start >>> 0\n  end = end === undefined ? buffer.length : end >>> 0\n\n  if (end > start) {\n    buffer.fill(val, start, end)\n  }\n\n  return buffer\n}\n\nfunction fillWithBuffer (buffer, val, start, end) {\n  if (start < 0 || end > buffer.length) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return buffer\n  }\n\n  start = start >>> 0\n  end = end === undefined ? buffer.length : end >>> 0\n\n  var pos = start\n  var len = val.length\n  while (pos <= (end - len)) {\n    val.copy(buffer, pos)\n    pos += len\n  }\n\n  if (pos !== end) {\n    val.copy(buffer, pos, 0, end - pos)\n  }\n\n  return buffer\n}\n\nfunction fill (buffer, val, start, end, encoding) {\n  if (hasFullSupport) {\n    return buffer.fill(val, start, end, encoding)\n  }\n\n  if (typeof val === 'number') {\n    return fillWithNumber(buffer, val, start, end)\n  }\n\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = buffer.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = buffer.length\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n\n    if (encoding === 'latin1') {\n      encoding = 'binary'\n    }\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n\n    if (val === '') {\n      return fillWithNumber(buffer, 0, start, end)\n    }\n\n    if (isSingleByte(val)) {\n      return fillWithNumber(buffer, val.charCodeAt(0), start, end)\n    }\n\n    val = new Buffer(val, encoding)\n  }\n\n  if (Buffer.isBuffer(val)) {\n    return fillWithBuffer(buffer, val, start, end)\n  }\n\n  // Other values (e.g. undefined, boolean, object) results in zero-fill\n  return fillWithNumber(buffer, 0, start, end)\n}\n\nmodule.exports = fill\n","var hash = require('./crc16')\n\nmodule.exports = LRU\n\nfunction LRU (max, opts) {\n  if (!(this instanceof LRU)) return new LRU(max, opts)\n  if (!opts) opts = {}\n\n  // how many collisions before evicting (factor of two for fast modulo)\n  this.collisions = factorOfTwo(opts.collisions || opts.bucketSize || 4)\n  // buckets should be a factor of two for fast modulo as well\n  this.buckets = factorOf(max, this.collisions) / this.collisions\n\n  // we use 16bit hashing to bucket index must be <0xffff\n  while (this.buckets > 65536) {\n    this.buckets >>= 1\n    this.collisions <<= 1\n  }\n\n  this.size = this.buckets * this.collisions\n  this.wrap = !opts.indexedValues\n  this.cache = new Array(this.size)\n  this.hash = this.buckets === 65536 ? hash : maskedHash(this.buckets - 1)\n  this.evict = opts.evict || null\n}\n\nLRU.prototype.set = function (index, val) {\n  var pageStart = this.collisions * this.hash(index)\n  var pageEnd = pageStart + this.collisions\n  var ptr = pageStart\n  var page = null\n\n  while (ptr < pageEnd) {\n    page = this.cache[ptr]\n\n    if (!page) {\n      // no exiting version, but we have space to store it\n      page = this.cache[ptr] = this.wrap ? new Node(index, val) : val\n      move(this.cache, pageStart, ptr, page)\n      return\n    }\n\n    if (page.index === index) {\n      // update existing version and move to head of bucket\n      if (this.wrap) page.value = val\n      else this.cache[ptr] = val\n      move(this.cache, pageStart, ptr, page)\n      return\n    }\n\n    ptr++\n  }\n\n  // bucket is full, update oldest (last element in bucket)\n  if (this.wrap) {\n    if (this.evict) this.evict(page.index, page.value)\n    page.index = index\n    page.value = val\n  } else {\n    if (this.evict) this.evict(page.index, page)\n    this.cache[ptr - 1] = val\n  }\n  move(this.cache, pageStart, ptr - 1, page)\n}\n\nLRU.prototype.get = function (index) {\n  var pageStart = this.collisions * this.hash(index)\n  var pageEnd = pageStart + this.collisions\n  var ptr = pageStart\n\n  while (ptr < pageEnd) {\n    var page = this.cache[ptr++]\n\n    if (!page) return null\n    if (page.index !== index) continue\n\n    // we found it! move to head of bucket and return value\n    move(this.cache, pageStart, ptr - 1, page)\n\n    return this.wrap ? page.value : page\n  }\n\n  return null\n}\n\nfunction move (list, index, itemIndex, item) {\n  while (itemIndex > index) list[itemIndex] = list[--itemIndex]\n  list[index] = item\n}\n\nfunction Node (index, value) {\n  this.index = index\n  this.value = value\n}\n\nfunction factorOf (n, factor) {\n  n = factorOfTwo(n)\n  while (n & (factor - 1)) n <<= 1\n  return n\n}\n\nfunction factorOfTwo (n) {\n  if (n && !(n & (n - 1))) return n\n  var p = 1\n  while (p < n) p <<= 1\n  return p\n}\n\nfunction maskedHash (mask) {\n  return function (n) {\n    return hash(n) & mask\n  }\n}\n","// crc16 impl, optimized for numeric inputs\n\nvar TABLE = [\n  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,\n  0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,\n  0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,\n  0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,\n  0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,\n  0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,\n  0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,\n  0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,\n  0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,\n  0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,\n  0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,\n  0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,\n  0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,\n  0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,\n  0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,\n  0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,\n  0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,\n  0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,\n  0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,\n  0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,\n  0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,\n  0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,\n  0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,\n  0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,\n  0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,\n  0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,\n  0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,\n  0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,\n  0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,\n  0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,\n  0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,\n  0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0\n]\n\nmodule.exports = crc16\n\nfunction crc16 (n) {\n  var crc = 0\n  var r = 0\n\n  for (var i = 0; i < 8; i++) {\n    r = n & 0xff\n    n = (n - r) / 256\n    crc = ((crc << 8) ^ TABLE[((crc >> 8) ^ r) & 0xff]) & 0xffff\n  }\n\n  return crc\n}\n","var sodium = require('sodium-universal')\nvar uint64be = require('uint64be')\nvar bufferFrom = require('buffer-from')\nvar bufferAlloc = require('buffer-alloc-unsafe')\n\n// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\nvar LEAF_TYPE = bufferFrom([0])\nvar PARENT_TYPE = bufferFrom([1])\nvar ROOT_TYPE = bufferFrom([2])\nvar HYPERCORE = bufferFrom('hypercore')\n\nexports.keyPair = function (seed) {\n  var publicKey = bufferAlloc(sodium.crypto_sign_PUBLICKEYBYTES)\n  var secretKey = bufferAlloc(sodium.crypto_sign_SECRETKEYBYTES)\n\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n  return {\n    publicKey: publicKey,\n    secretKey: secretKey\n  }\n}\n\nexports.sign = function (message, secretKey) {\n  var signature = bufferAlloc(sodium.crypto_sign_BYTES)\n  sodium.crypto_sign_detached(signature, message, secretKey)\n  return signature\n}\n\nexports.verify = function (message, signature, publicKey) {\n  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n}\n\nexports.data = function (data) {\n  return blake2b([\n    LEAF_TYPE,\n    encodeUInt64(data.length),\n    data\n  ])\n}\n\nexports.leaf = function (leaf) {\n  return exports.data(leaf.data)\n}\n\nexports.parent = function (a, b) {\n  if (a.index > b.index) {\n    var tmp = a\n    a = b\n    b = tmp\n  }\n\n  return blake2b([\n    PARENT_TYPE,\n    encodeUInt64(a.size + b.size),\n    a.hash,\n    b.hash\n  ])\n}\n\nexports.tree = function (roots) {\n  var buffers = new Array(3 * roots.length + 1)\n  var j = 0\n\n  buffers[j++] = ROOT_TYPE\n\n  for (var i = 0; i < roots.length; i++) {\n    var r = roots[i]\n    buffers[j++] = r.hash\n    buffers[j++] = encodeUInt64(r.index)\n    buffers[j++] = encodeUInt64(r.size)\n  }\n\n  return blake2b(buffers)\n}\n\nexports.randomBytes = function (n) {\n  var buf = bufferAlloc(n)\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nexports.discoveryKey = function (tree) {\n  var digest = bufferAlloc(32)\n  sodium.crypto_generichash(digest, HYPERCORE, tree)\n  return digest\n}\n\nfunction encodeUInt64 (n) {\n  return uint64be.encode(n, bufferAlloc(8))\n}\n\nfunction blake2b (buffers) {\n  var digest = bufferAlloc(32)\n  sodium.crypto_generichash_batch(digest, buffers)\n  return digest\n}\n","try {\n  if (process.env.SODIUM_NATIVE === 'disable') throw new Error('Use sodium-javascript')\n  module.exports = require('sodium-native')\n} catch (err) {\n  module.exports = require('sodium-javascript')\n}\n","var sodium = require('node-gyp-build')(__dirname)\n\nmodule.exports = sodium\n","var fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n  if (release) return release\n\n  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n  if (debug) return debug\n\n  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild)\n  if (prebuild) return prebuild\n\n  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime)\n  if (napiRuntime) return napiRuntime\n\n  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi)\n  if (napi) return napi\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n","'use strict';\n\n// Based on https://github.com/dchest/tweetnacl-js/blob/6dcbcaf5f5cbfd313f2dcfe763db35c828c8ff5b/nacl-fast.js.\n\nvar sodium = module.exports\nvar cs = require('./crypto_stream')\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n// also forwarded at the bottom but randombytes is non-enumerable\nvar randombytes = require('./randombytes').randombytes\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_stream_xor (c, cpos, m, mpos, clen, n, k) {\n  cs.crypto_stream_xor(c, m, n, k)\n}\n\nfunction crypto_stream (c, cpos, clen, n, k) {\n  cs.crypto_stream(c, n, k)\n}\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  check(q, crypto_scalarmult_BYTES)\n  check(n, crypto_scalarmult_SCALARBYTES)\n  check(p, crypto_scalarmult_BYTES)\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  check(pk, sodium.crypto_sign_PUBLICKEYBYTES)\n  check(sk, sodium.crypto_sign_SECRETKEYBYTES)\n\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nfunction crypto_sign_seed_keypair (pk, sk, seed) {\n  check(seed, sodium.crypto_sign_SEEDBYTES)\n  seed.copy(sk)\n  crypto_sign_keypair(pk, sk, true)\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = (x[j] + 128) >> 8;\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, sk) {\n  check(sm, crypto_sign_BYTES + m.length)\n  check(m, 0)\n  check(sk, crypto_sign_SECRETKEYBYTES)\n  var n = m.length\n\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n}\n\nfunction crypto_sign_detached(sig, m, sk) {\n  var sm = new Uint8Array(m.length + crypto_sign_BYTES)\n  crypto_sign(sm, m, sk)\n  for (var i = 0; i < crypto_sign_BYTES; i++) sig[i] = sm[i]\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(msg, sm, pk) {\n  check(msg, sm.length - crypto_sign_BYTES)\n  check(sm, crypto_sign_BYTES)\n  check(pk, crypto_sign_PUBLICKEYBYTES)\n  var n = sm.length\n  var m = new Uint8Array(sm.length)\n\n  var i, mlen;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  mlen = -1;\n  if (n < 64) return false;\n\n  if (unpackneg(q, pk)) return false;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return false;\n  }\n\n  for (i = 0; i < n; i++) msg[i] = sm[i + 64];\n  mlen = n;\n  return true;\n}\n\nfunction crypto_sign_verify_detached (sig, m, pk) {\n  check(sig, crypto_sign_BYTES)\n  var sm = new Uint8Array(m.length + crypto_sign_BYTES)\n  var i = 0\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i]\n  for (i = 0; i < m.length; i++) sm[i + crypto_sign_BYTES] = m[i]\n  return crypto_sign_open(m, sm, pk)\n}\n\nfunction crypto_secretbox_detached (o, mac, msg, n, k) {\n  check(mac, sodium.crypto_secretbox_MACBYTES)\n  var tmp = new Uint8Array(msg.length + mac.length)\n  crypto_secretbox_easy(tmp, msg, n, k)\n  o.set(tmp.subarray(0, msg.length))\n  mac.set(tmp.subarray(msg.length))\n}\n\nfunction crypto_secretbox_open_detached (msg, o, mac, n, k) {\n  check(mac, sodium.crypto_secretbox_MACBYTES)\n  var tmp = new Uint8Array(o.length + mac.length)\n  tmp.set(o)\n  tmp.set(mac, msg.length)\n  return crypto_secretbox_open_easy(msg, tmp, n, k)\n}\n\nfunction crypto_secretbox_easy(o, msg, n, k) {\n  check(msg, 0)\n  check(o, msg.length + sodium.crypto_secretbox_MACBYTES)\n  check(n, crypto_secretbox_NONCEBYTES)\n  check(k, crypto_secretbox_KEYBYTES)\n\n  var i\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, n, k);\n  for (i = crypto_secretbox_BOXZEROBYTES; i < c.length; i++) o[i - crypto_secretbox_BOXZEROBYTES] = c[i]\n}\n\nfunction crypto_secretbox_open_easy(msg, box, n, k) {\n  check(box, sodium.crypto_secretbox_MACBYTES)\n  check(msg, box.length - sodium.crypto_secretbox_MACBYTES)\n  check(n, crypto_secretbox_NONCEBYTES)\n  check(k, crypto_secretbox_KEYBYTES)\n\n  var i\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return false;\n  if (crypto_secretbox_open(m, c, c.length, n, k) !== 0) return false;\n\n  for (i = crypto_secretbox_ZEROBYTES; i < m.length; i++) msg[i - crypto_secretbox_ZEROBYTES] = m[i]\n  return true\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nsodium.memzero = function (len, offset) {\n  for (var i = offset; i < len; i++) arr[i] = 0;\n}\n\nsodium.crypto_sign_BYTES = crypto_sign_BYTES\nsodium.crypto_sign_PUBLICKEYBYTES = crypto_sign_PUBLICKEYBYTES\nsodium.crypto_sign_SECRETKEYBYTES = crypto_sign_SECRETKEYBYTES\nsodium.crypto_sign_SEEDBYTES = crypto_sign_SEEDBYTES\nsodium.crypto_sign_keypair = crypto_sign_keypair\nsodium.crypto_sign_seed_keypair = crypto_sign_seed_keypair\nsodium.crypto_sign = crypto_sign\nsodium.crypto_sign_open = crypto_sign_open\nsodium.crypto_sign_detached = crypto_sign_detached\nsodium.crypto_sign_verify_detached = crypto_sign_verify_detached\n\nforward(require('./crypto_generichash'))\nforward(require('./crypto_kdf'))\nforward(require('./crypto_shorthash'))\nforward(require('./randombytes'))\nforward(require('./crypto_stream'))\n\nsodium.crypto_scalarmult_BYTES = crypto_scalarmult_BYTES\nsodium.crypto_scalarmult_SCALARBYTES = crypto_scalarmult_SCALARBYTES\nsodium.crypto_scalarmult_base = crypto_scalarmult_base\nsodium.crypto_scalarmult = crypto_scalarmult\n\nsodium.crypto_secretbox_KEYBYTES = crypto_secretbox_KEYBYTES,\nsodium.crypto_secretbox_NONCEBYTES = crypto_secretbox_NONCEBYTES,\nsodium.crypto_secretbox_MACBYTES = 16\nsodium.crypto_secretbox_easy = crypto_secretbox_easy\nsodium.crypto_secretbox_open_easy = crypto_secretbox_open_easy\nsodium.crypto_secretbox_detached = crypto_secretbox_detached\nsodium.crypto_secretbox_open_detached = crypto_secretbox_open_detached\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\nfunction check (buf, len) {\n  if (!buf || (len && buf.length < len)) throw new Error('Argument must be a buffer' + (len ? ' of length ' + len : ''))\n}\n\nfunction forward (submodule) {\n  Object.keys(submodule).forEach(function (prop) {\n    module.exports[prop] = submodule[prop]\n  })\n}\n","var xsalsa20 = require('xsalsa20')\n\nexports.crypto_stream_KEYBYTES = 32\nexports.crypto_stream_NONCEBYTES = 24\nexports.crypto_stream_PRIMITIVE = 'xsalsa20'\n\nexports.crypto_stream = function (out, nonce, key) {\n  out.fill(0)\n  exports.crypto_stream_xor(out, out, nonce, key)\n}\n\nexports.crypto_stream_xor = function (out, inp, nonce, key) {\n  var xor = xsalsa20(nonce, key)\n  xor.update(inp, out)\n  xor.final()\n}\n\nexports.crypto_stream_xor_instance = function (nonce, key) {\n  return new XOR(nonce, key)\n}\n\nfunction XOR (nonce, key) {\n  this._instance = xsalsa20(nonce, key)\n}\n\nXOR.prototype.update = function (out, inp) {\n  this._instance.update(inp, out)\n}\n\nXOR.prototype.final = function () {\n  this._instance.finalize()\n  this._instance = null\n}\n","var xsalsa20 = require('./xsalsa20')()\n\nvar SIGMA = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107])\nvar head = 144\nvar top = head\nvar free = []\n\nmodule.exports = XSalsa20\n\nXSalsa20.NONCEBYTES = 24\nXSalsa20.KEYBYTES = 32\n\nfunction XSalsa20 (nonce, key) {\n  if (!(this instanceof XSalsa20)) return new XSalsa20(nonce, key)\n  if (!nonce || nonce.length < 24) throw new Error('nonce must be at least 24 bytes')\n  if (!key || key.length < 32) throw new Error('key must be at least 32 bytes')\n  this._xor = xsalsa20 && xsalsa20.exports ? new WASM(nonce, key) : new Fallback(nonce, key)\n}\n\nXSalsa20.prototype.update = function (input, output) {\n  if (!input) throw new Error('input must be Uint8Array or Buffer')\n  if (!output) output = new Uint8Array(input.length)\n  if (input.length) this._xor.update(input, output)\n  return output\n}\n\nXSalsa20.prototype.final =\nXSalsa20.prototype.finalize = function () {\n  this._xor.finalize()\n  this._xor = null\n}\n\nfunction WASM (nonce, key) {\n  if (!free.length) {\n    free.push(head)\n    head += 64\n  }\n\n  this._pointer = free.pop()\n  this._nonce = this._pointer + 8\n  this._key = this._nonce + 24\n  this._overflow = 0\n\n  xsalsa20.memory.fill(0, this._pointer, this._pointer + 8)\n  xsalsa20.memory.set(nonce, this._nonce)\n  xsalsa20.memory.set(key, this._key)\n}\n\nWASM.prototype.update = function (input, output) {\n  var len = this._overflow + input.length\n  var start = head + this._overflow\n\n  top = head + len\n  if (top >= xsalsa20.memory.length) xsalsa20.realloc(top)\n\n  xsalsa20.memory.set(input, start)\n  xsalsa20.exports.xsalsa20_xor(this._pointer, head, head, len, this._nonce, this._key)\n  output.set(xsalsa20.memory.subarray(start, head + len))\n\n  this._overflow = len & 63\n}\n\nWASM.prototype.finalize = function () {\n  xsalsa20.memory.fill(0, this._pointer, this._key + 32)\n  if (top > head) {\n    xsalsa20.memory.fill(0, head, top)\n    top = 0\n  }\n  free.push(this._pointer)\n}\n\nfunction Fallback (nonce, key) {\n  this._s = new Uint8Array(32)\n  this._z = new Uint8Array(16)\n  this._overflow = 0\n  core_hsalsa20(this._s, nonce, key, SIGMA)\n  for (var i = 0; i < 8; i++) this._z[i] = nonce[i + 16]\n}\n\nFallback.prototype.update = function (input, output) {\n  var x = new Uint8Array(64)\n  var u = 0\n  var i = this._overflow\n  var b = input.length + this._overflow\n  var z = this._z\n  var mpos = -this._overflow\n  var cpos = -this._overflow\n\n  while (b >= 64) {\n    core_salsa20(x, z, this._s, SIGMA)\n    for (; i < 64; i++) output[cpos + i] = input[mpos + i] ^ x[i]\n    u = 1\n    for (i = 8; i < 16; i++) {\n      u += (z[i] & 0xff) | 0\n      z[i] = u & 0xff\n      u >>>= 8\n    }\n    b -= 64\n    cpos += 64\n    mpos += 64\n    i = 0\n  }\n  if (b > 0) {\n    core_salsa20(x, z, this._s, SIGMA)\n    for (; i < b; i++) output[cpos + i] = input[mpos + i] ^ x[i]\n  }\n\n  this._overflow = b & 63\n}\n\nFallback.prototype.finalize = function () {\n  this._s.fill(0)\n  this._z.fill(0)\n}\n\n// below methods are ported from tweet nacl\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff) << 8 | (c[ 2] & 0xff) << 16 | (c[ 3] & 0xff) << 24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff) << 8 | (k[ 2] & 0xff) << 16 | (k[ 3] & 0xff) << 24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff) << 8 | (k[ 6] & 0xff) << 16 | (k[ 7] & 0xff) << 24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,\n      j4  = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff) << 8 | (c[ 6] & 0xff) << 16 | (c[ 7] & 0xff) << 24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff) << 8 | (p[ 2] & 0xff) << 16 | (p[ 3] & 0xff) << 24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff) << 8 | (p[ 6] & 0xff) << 16 | (p[ 7] & 0xff) << 24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,\n      j9  = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,\n      j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,\n      j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,\n      j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,\n      j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,\n      j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0\n    x4 ^= u << 7 | u >>> 25\n    u = x4 + x0 | 0\n    x8 ^= u << 9 | u >>> 23\n    u = x8 + x4 | 0\n    x12 ^= u << 13 | u >>> 19\n    u = x12 + x8 | 0\n    x0 ^= u << 18 | u >>> 14\n\n    u = x5 + x1 | 0\n    x9 ^= u << 7 | u >>> 25\n    u = x9 + x5 | 0\n    x13 ^= u << 9 | u >>> 23\n    u = x13 + x9 | 0\n    x1 ^= u << 13 | u >>> 19\n    u = x1 + x13 | 0\n    x5 ^= u << 18 | u >>> 14\n\n    u = x10 + x6 | 0\n    x14 ^= u << 7 | u >>> 25\n    u = x14 + x10 | 0\n    x2 ^= u << 9 | u >>> 23\n    u = x2 + x14 | 0\n    x6 ^= u << 13 | u >>> 19\n    u = x6 + x2 | 0\n    x10 ^= u << 18 | u >>> 14\n\n    u = x15 + x11 | 0\n    x3 ^= u << 7 | u >>> 25\n    u = x3 + x15 | 0\n    x7 ^= u << 9 | u >>> 23\n    u = x7 + x3 | 0\n    x11 ^= u << 13 | u >>> 19\n    u = x11 + x7 | 0\n    x15 ^= u << 18 | u >>> 14\n\n    u = x0 + x3 | 0\n    x1 ^= u << 7 | u >>> 25\n    u = x1 + x0 | 0\n    x2 ^= u << 9 | u >>> 23\n    u = x2 + x1 | 0\n    x3 ^= u << 13 | u >>> 19\n    u = x3 + x2 | 0\n    x0 ^= u << 18 | u >>> 14\n\n    u = x5 + x4 | 0\n    x6 ^= u << 7 | u >>> 25\n    u = x6 + x5 | 0\n    x7 ^= u << 9 | u >>> 23\n    u = x7 + x6 | 0\n    x4 ^= u << 13 | u >>> 19\n    u = x4 + x7 | 0\n    x5 ^= u << 18 | u >>> 14\n\n    u = x10 + x9 | 0\n    x11 ^= u << 7 | u >>> 25\n    u = x11 + x10 | 0\n    x8 ^= u << 9 | u >>> 23\n    u = x8 + x11 | 0\n    x9 ^= u << 13 | u >>> 19\n    u = x9 + x8 | 0\n    x10 ^= u << 18 | u >>> 14\n\n    u = x15 + x14 | 0\n    x12 ^= u << 7 | u >>> 25\n    u = x12 + x15 | 0\n    x13 ^= u << 9 | u >>> 23\n    u = x13 + x12 | 0\n    x14 ^= u << 13 | u >>> 19\n    u = x14 + x13 | 0\n    x15 ^= u << 18 | u >>> 14\n  }\n   x0 =  x0 +  j0 | 0\n   x1 =  x1 +  j1 | 0\n   x2 =  x2 +  j2 | 0\n   x3 =  x3 +  j3 | 0\n   x4 =  x4 +  j4 | 0\n   x5 =  x5 +  j5 | 0\n   x6 =  x6 +  j6 | 0\n   x7 =  x7 +  j7 | 0\n   x8 =  x8 +  j8 | 0\n   x9 =  x9 +  j9 | 0\n  x10 = x10 + j10 | 0\n  x11 = x11 + j11 | 0\n  x12 = x12 + j12 | 0\n  x13 = x13 + j13 | 0\n  x14 = x14 + j14 | 0\n  x15 = x15 + j15 | 0\n\n  o[ 0] = x0 >>>  0 & 0xff\n  o[ 1] = x0 >>>  8 & 0xff\n  o[ 2] = x0 >>> 16 & 0xff\n  o[ 3] = x0 >>> 24 & 0xff\n\n  o[ 4] = x1 >>>  0 & 0xff\n  o[ 5] = x1 >>>  8 & 0xff\n  o[ 6] = x1 >>> 16 & 0xff\n  o[ 7] = x1 >>> 24 & 0xff\n\n  o[ 8] = x2 >>>  0 & 0xff\n  o[ 9] = x2 >>>  8 & 0xff\n  o[10] = x2 >>> 16 & 0xff\n  o[11] = x2 >>> 24 & 0xff\n\n  o[12] = x3 >>>  0 & 0xff\n  o[13] = x3 >>>  8 & 0xff\n  o[14] = x3 >>> 16 & 0xff\n  o[15] = x3 >>> 24 & 0xff\n\n  o[16] = x4 >>>  0 & 0xff\n  o[17] = x4 >>>  8 & 0xff\n  o[18] = x4 >>> 16 & 0xff\n  o[19] = x4 >>> 24 & 0xff\n\n  o[20] = x5 >>>  0 & 0xff\n  o[21] = x5 >>>  8 & 0xff\n  o[22] = x5 >>> 16 & 0xff\n  o[23] = x5 >>> 24 & 0xff\n\n  o[24] = x6 >>>  0 & 0xff\n  o[25] = x6 >>>  8 & 0xff\n  o[26] = x6 >>> 16 & 0xff\n  o[27] = x6 >>> 24 & 0xff\n\n  o[28] = x7 >>>  0 & 0xff\n  o[29] = x7 >>>  8 & 0xff\n  o[30] = x7 >>> 16 & 0xff\n  o[31] = x7 >>> 24 & 0xff\n\n  o[32] = x8 >>>  0 & 0xff\n  o[33] = x8 >>>  8 & 0xff\n  o[34] = x8 >>> 16 & 0xff\n  o[35] = x8 >>> 24 & 0xff\n\n  o[36] = x9 >>>  0 & 0xff\n  o[37] = x9 >>>  8 & 0xff\n  o[38] = x9 >>> 16 & 0xff\n  o[39] = x9 >>> 24 & 0xff\n\n  o[40] = x10 >>>  0 & 0xff\n  o[41] = x10 >>>  8 & 0xff\n  o[42] = x10 >>> 16 & 0xff\n  o[43] = x10 >>> 24 & 0xff\n\n  o[44] = x11 >>>  0 & 0xff\n  o[45] = x11 >>>  8 & 0xff\n  o[46] = x11 >>> 16 & 0xff\n  o[47] = x11 >>> 24 & 0xff\n\n  o[48] = x12 >>>  0 & 0xff\n  o[49] = x12 >>>  8 & 0xff\n  o[50] = x12 >>> 16 & 0xff\n  o[51] = x12 >>> 24 & 0xff\n\n  o[52] = x13 >>>  0 & 0xff\n  o[53] = x13 >>>  8 & 0xff\n  o[54] = x13 >>> 16 & 0xff\n  o[55] = x13 >>> 24 & 0xff\n\n  o[56] = x14 >>>  0 & 0xff\n  o[57] = x14 >>>  8 & 0xff\n  o[58] = x14 >>> 16 & 0xff\n  o[59] = x14 >>> 24 & 0xff\n\n  o[60] = x15 >>>  0 & 0xff\n  o[61] = x15 >>>  8 & 0xff\n  o[62] = x15 >>> 16 & 0xff\n  o[63] = x15 >>> 24 & 0xff\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff) << 8 | (c[ 2] & 0xff) << 16 | (c[ 3] & 0xff) << 24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff) << 8 | (k[ 2] & 0xff) << 16 | (k[ 3] & 0xff) << 24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff) << 8 | (k[ 6] & 0xff) << 16 | (k[ 7] & 0xff) << 24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,\n      j4  = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff) << 8 | (c[ 6] & 0xff) << 16 | (c[ 7] & 0xff) << 24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff) << 8 | (p[ 2] & 0xff) << 16 | (p[ 3] & 0xff) << 24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff) << 8 | (p[ 6] & 0xff) << 16 | (p[ 7] & 0xff) << 24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,\n      j9  = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,\n      j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,\n      j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,\n      j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,\n      j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,\n      j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0\n    x4 ^= u << 7 | u >>> 25\n    u = x4 + x0 | 0\n    x8 ^= u << 9 | u >>> 23\n    u = x8 + x4 | 0\n    x12 ^= u << 13 | u >>> 19\n    u = x12 + x8 | 0\n    x0 ^= u << 18 | u >>> 14\n\n    u = x5 + x1 | 0\n    x9 ^= u << 7 | u >>> 25\n    u = x9 + x5 | 0\n    x13 ^= u << 9 | u >>> 23\n    u = x13 + x9 | 0\n    x1 ^= u << 13 | u >>> 19\n    u = x1 + x13 | 0\n    x5 ^= u << 18 | u >>> 14\n\n    u = x10 + x6 | 0\n    x14 ^= u << 7 | u >>> 25\n    u = x14 + x10 | 0\n    x2 ^= u << 9 | u >>> 23\n    u = x2 + x14 | 0\n    x6 ^= u << 13 | u >>> 19\n    u = x6 + x2 | 0\n    x10 ^= u << 18 | u >>> 14\n\n    u = x15 + x11 | 0\n    x3 ^= u << 7 | u >>> 25\n    u = x3 + x15 | 0\n    x7 ^= u << 9 | u >>> 23\n    u = x7 + x3 | 0\n    x11 ^= u << 13 | u >>> 19\n    u = x11 + x7 | 0\n    x15 ^= u << 18 | u >>> 14\n\n    u = x0 + x3 | 0\n    x1 ^= u << 7 | u >>> 25\n    u = x1 + x0 | 0\n    x2 ^= u << 9 | u >>> 23\n    u = x2 + x1 | 0\n    x3 ^= u << 13 | u >>> 19\n    u = x3 + x2 | 0\n    x0 ^= u << 18 | u >>> 14\n\n    u = x5 + x4 | 0\n    x6 ^= u << 7 | u >>> 25\n    u = x6 + x5 | 0\n    x7 ^= u << 9 | u >>> 23\n    u = x7 + x6 | 0\n    x4 ^= u << 13 | u >>> 19\n    u = x4 + x7 | 0\n    x5 ^= u << 18 | u >>> 14\n\n    u = x10 + x9 | 0\n    x11 ^= u << 7 | u >>> 25\n    u = x11 + x10 | 0\n    x8 ^= u << 9 | u >>> 23\n    u = x8 + x11 | 0\n    x9 ^= u << 13 | u >>> 19\n    u = x9 + x8 | 0\n    x10 ^= u << 18 | u >>> 14\n\n    u = x15 + x14 | 0\n    x12 ^= u << 7 | u >>> 25\n    u = x12 + x15 | 0\n    x13 ^= u << 9 | u >>> 23\n    u = x13 + x12 | 0\n    x14 ^= u << 13 | u >>> 19\n    u = x14 + x13 | 0\n    x15 ^= u << 18 | u >>> 14\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff\n  o[ 1] = x0 >>>  8 & 0xff\n  o[ 2] = x0 >>> 16 & 0xff\n  o[ 3] = x0 >>> 24 & 0xff\n\n  o[ 4] = x5 >>>  0 & 0xff\n  o[ 5] = x5 >>>  8 & 0xff\n  o[ 6] = x5 >>> 16 & 0xff\n  o[ 7] = x5 >>> 24 & 0xff\n\n  o[ 8] = x10 >>>  0 & 0xff\n  o[ 9] = x10 >>>  8 & 0xff\n  o[10] = x10 >>> 16 & 0xff\n  o[11] = x10 >>> 24 & 0xff\n\n  o[12] = x15 >>>  0 & 0xff\n  o[13] = x15 >>>  8 & 0xff\n  o[14] = x15 >>> 16 & 0xff\n  o[15] = x15 >>> 24 & 0xff\n\n  o[16] = x6 >>>  0 & 0xff\n  o[17] = x6 >>>  8 & 0xff\n  o[18] = x6 >>> 16 & 0xff\n  o[19] = x6 >>> 24 & 0xff\n\n  o[20] = x7 >>>  0 & 0xff\n  o[21] = x7 >>>  8 & 0xff\n  o[22] = x7 >>> 16 & 0xff\n  o[23] = x7 >>> 24 & 0xff\n\n  o[24] = x8 >>>  0 & 0xff\n  o[25] = x8 >>>  8 & 0xff\n  o[26] = x8 >>> 16 & 0xff\n  o[27] = x8 >>> 24 & 0xff\n\n  o[28] = x9 >>>  0 & 0xff\n  o[29] = x9 >>>  8 & 0xff\n  o[30] = x9 >>> 16 & 0xff\n  o[31] = x9 >>> 24 & 0xff\n}\n","\nmodule.exports = loadWebAssembly\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (opts) {\n  if (!loadWebAssembly.supported) return null\n\n  var imp = opts && opts.imports\n  var wasm = toUint8Array('AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL')\n  var ready = null\n\n  var mod = {\n    buffer: wasm,\n    memory: null,\n    exports: null,\n    realloc: realloc,\n    onload: onload\n  }\n\n  onload(function () {})\n\n  return mod\n\n  function realloc (size) {\n    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536))\n    mod.memory = new Uint8Array(mod.exports.memory.buffer)\n  }\n\n  function onload (cb) {\n    if (mod.exports) return cb()\n\n    if (ready) {\n      ready.then(cb.bind(null, null)).catch(cb)\n      return\n    }\n\n    try {\n      if (opts && opts.async) throw new Error('async')\n      setup({instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)})\n    } catch (err) {\n      ready = WebAssembly.instantiate(wasm, imp).then(setup)\n    }\n\n    onload(cb)\n  }\n\n  function setup (w) {\n    mod.exports = w.instance.exports\n    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer)\n  }\n}\n\nfunction toUint8Array (s) {\n  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt))\n  return new (require('buf' + 'fer').Buffer)(s, 'base64')\n}\n\nfunction charCodeAt (c) {\n  return c.charCodeAt(0)\n}\n","var assert = require('nanoassert')\nvar randombytes = (function () {\n  var QUOTA = 65536 // limit for QuotaExceededException\n  var crypto = typeof global !== 'undefined' ? crypto = (global.crypto || global.msCrypto) : null\n\n  function browserBytes (out, n) {\n    for (var i = 0; i < n; i += QUOTA) {\n      crypto.getRandomValues(out.subarray(i, i + Math.min(n - i, QUOTA)))\n    }\n  }\n\n  function nodeBytes (out, n) {\n    out.set(crypto.randomBytes(n))\n  }\n\n  function noImpl () {\n    throw new Error('No secure random number generator available')\n  }\n\n  if (crypto && crypto.getRandomValues) {\n    return browserBytes\n  } else if (typeof require !== 'undefined') {\n    // Node.js.\n    crypto = require('crypto')\n    if (crypto && crypto.randomBytes) {\n      return nodeBytes\n    }\n  }\n\n  return noImpl\n})()\n\nObject.defineProperty(module.exports, 'randombytes', {\n  value: randombytes\n})\n\nmodule.exports.randombytes_buf = function (out) {\n  assert(out, 'out must be given')\n  randombytes(out, out.length)\n}\n","assert.notEqual = notEqual\nassert.notOk = notOk\nassert.equal = equal\nassert.ok = assert\n\nmodule.exports = assert\n\nfunction equal (a, b, m) {\n  assert(a == b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notEqual (a, b, m) {\n  assert(a != b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notOk (t, m) {\n  assert(!t, m)\n}\n\nfunction assert (t, m) {\n  if (!t) throw new Error(m || 'AssertionError')\n}\n","module.exports = require(\"crypto\");","var blake2b = require('blake2b')\n\nmodule.exports.crypto_generichash_PRIMITIVE = 'blake2b'\nmodule.exports.crypto_generichash_BYTES_MIN = blake2b.BYTES_MIN\nmodule.exports.crypto_generichash_BYTES_MAX = blake2b.BYTES_MAX\nmodule.exports.crypto_generichash_BYTES = blake2b.BYTES\nmodule.exports.crypto_generichash_KEYBYTES_MIN = blake2b.KEYBYTES_MIN\nmodule.exports.crypto_generichash_KEYBYTES_MAX = blake2b.KEYBYTES_MAX\nmodule.exports.crypto_generichash_KEYBYTES = blake2b.KEYBYTES\nmodule.exports.crypto_generichash_WASM_SUPPORTED = blake2b.WASM_SUPPORTED\nmodule.exports.crypto_generichash_WASM_LOADED = false\n\nmodule.exports.crypto_generichash = function (output, input, key) {\n  blake2b(output.length, key).update(input).final(output)\n}\n\nmodule.exports.crypto_generichash_ready = blake2b.ready\n\nmodule.exports.crypto_generichash_batch = function (output, inputArray, key) {\n  var ctx = blake2b(output.length, key)\n  for (var i = 0; i < inputArray.length; i++) {\n    ctx.update(inputArray[i])\n  }\n  ctx.final(output)\n}\n\nmodule.exports.crypto_generichash_instance = function (key, outlen) {\n  if (outlen == null) outlen = module.exports.crypto_generichash_BYTES\n  return blake2b(outlen, key)\n}\n\nblake2b.ready(function (err) {\n  module.exports.crypto_generichash_WASM_LOADED = blake2b.WASM_LOADED\n})\n","var assert = require('nanoassert')\nvar b2wasm = require('blake2b-wasm')\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA (v, a, b) {\n  var o0 = v[a] + v[b]\n  var o1 = v[a + 1] + v[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC (v, a, b0, b1) {\n  var o0 = v[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  var o1 = v[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// Little-endian byte access\nfunction B2B_GET32 (arr, i) {\n  return (arr[i] ^\n  (arr[i + 1] << 8) ^\n  (arr[i + 2] << 16) ^\n  (arr[i + 3] << 24))\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G (a, b, c, d, ix, iy) {\n  var x0 = m[ix]\n  var x1 = m[ix + 1]\n  var y0 = m[iy]\n  var y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  var xor0 = v[d] ^ v[a]\n  var xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nvar BLAKE2B_IV32 = new Uint32Array([\n  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,\n  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,\n  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,\n  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19\n])\n\nvar SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3\n]\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nvar SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))\n\n// Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\nvar v = new Uint32Array(32)\nvar m = new Uint32Array(32)\nfunction blake2bCompress (ctx, last) {\n  var i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] = v[24] ^ ctx.t\n  v[25] = v[25] ^ (ctx.t / 0x100000000)\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  for (i = 0; i < 12; i++) {\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n}\n\n// reusable parameter_block\nvar parameter_block = new Uint8Array([\n  0, 0, 0, 0,      //  0: outlen, keylen, fanout, depth\n  0, 0, 0, 0,      //  4: leaf length, sequential mode\n  0, 0, 0, 0,      //  8: node offset\n  0, 0, 0, 0,      // 12: node offset\n  0, 0, 0, 0,      // 16: node depth, inner length, rfu\n  0, 0, 0, 0,      // 20: rfu\n  0, 0, 0, 0,      // 24: rfu\n  0, 0, 0, 0,      // 28: rfu\n  0, 0, 0, 0,      // 32: salt\n  0, 0, 0, 0,      // 36: salt\n  0, 0, 0, 0,      // 40: salt\n  0, 0, 0, 0,      // 44: salt\n  0, 0, 0, 0,      // 48: personal\n  0, 0, 0, 0,      // 52: personal\n  0, 0, 0, 0,      // 56: personal\n  0, 0, 0, 0       // 60: personal\n])\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\nfunction Blake2b (outlen, key, salt, personal) {\n  // zero out parameter_block before usage\n  parameter_block.fill(0)\n  // state, 'param block'\n\n  this.b = new Uint8Array(128)\n  this.h = new Uint32Array(16)\n  this.t = 0 // input count\n  this.c = 0 // pointer within buffer\n  this.outlen = outlen // output length in bytes\n\n  parameter_block[0] = outlen\n  if (key) parameter_block[1] = key.length\n  parameter_block[2] = 1 // fanout\n  parameter_block[3] = 1 // depth\n\n  if (salt) parameter_block.set(salt, 32)\n  if (personal) parameter_block.set(personal, 48)\n\n  // initialize hash state\n  for (var i = 0; i < 16; i++) {\n    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4)\n  }\n\n  // key the hash, if applicable\n  if (key) {\n    blake2bUpdate(this, key)\n    // at the end\n    this.c = 128\n  }\n}\n\nBlake2b.prototype.update = function (input) {\n  assert(input != null, 'input must be Uint8Array or Buffer')\n  blake2bUpdate(this, input)\n  return this\n}\n\nBlake2b.prototype.digest = function (out) {\n  var buf = (!out || out === 'binary' || out === 'hex') ? new Uint8Array(this.outlen) : out\n  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space')\n  blake2bFinal(this, buf)\n  if (out === 'hex') return hexSlice(buf)\n  return buf\n}\n\nBlake2b.prototype.final = Blake2b.prototype.digest\n\nBlake2b.ready = function (cb) {\n  b2wasm.ready(function () {\n    cb() // ignore the error\n  })\n}\n\n// Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2bUpdate (ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 128) { // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2bFinal (ctx, out) {\n  ctx.t += ctx.c // mark last block offset\n\n  while (ctx.c < 128) { // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\nfunction hexSlice (buf) {\n  var str = ''\n  for (var i = 0; i < buf.length; i++) str += toHex(buf[i])\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nvar Proto = Blake2b\n\nmodule.exports = function createHash (outlen, key, salt, personal, noAssert) {\n  if (noAssert !== true) {\n    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen)\n    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen)\n    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length)\n    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length)\n    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length)\n    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length)\n  }\n\n  return new Proto(outlen, key, salt, personal)\n}\n\nmodule.exports.ready = function (cb) {\n  b2wasm.ready(function () { // ignore errors\n    cb()\n  })\n}\n\nmodule.exports.WASM_SUPPORTED = b2wasm.SUPPORTED\nmodule.exports.WASM_LOADED = false\n\nvar BYTES_MIN = module.exports.BYTES_MIN = 16\nvar BYTES_MAX = module.exports.BYTES_MAX = 64\nvar BYTES = module.exports.BYTES = 32\nvar KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16\nvar KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64\nvar KEYBYTES = module.exports.KEYBYTES = 32\nvar SALTBYTES = module.exports.SALTBYTES = 16\nvar PERSONALBYTES = module.exports.PERSONALBYTES = 16\n\nb2wasm.ready(function (err) {\n  if (!err) {\n    module.exports.WASM_LOADED = true\n    Proto = b2wasm\n  }\n})\n","var assert = require('nanoassert')\nvar wasm = require('./blake2b')()\n\nvar head = 64\nvar freeList = []\n\nmodule.exports = Blake2b\nvar BYTES_MIN = module.exports.BYTES_MIN = 16\nvar BYTES_MAX = module.exports.BYTES_MAX = 64\nvar BYTES = module.exports.BYTES = 32\nvar KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16\nvar KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64\nvar KEYBYTES = module.exports.KEYBYTES = 32\nvar SALTBYTES = module.exports.SALTBYTES = 16\nvar PERSONALBYTES = module.exports.PERSONALBYTES = 16\n\nfunction Blake2b (digestLength, key, salt, personal, noAssert) {\n  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert)\n  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)')\n  if (!digestLength) digestLength = 32\n\n  if (noAssert !== true) {\n    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength)\n    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength)\n    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length)\n    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length)\n    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length)\n    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length)\n  }\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += 216\n  }\n\n  this.digestLength = digestLength\n  this.finalized = false\n  this.pointer = freeList.pop()\n\n  wasm.memory.fill(0, 0, 64)\n  wasm.memory[0] = this.digestLength\n  wasm.memory[1] = key ? key.length : 0\n  wasm.memory[2] = 1 // fanout\n  wasm.memory[3] = 1 // depth\n\n  if (salt) wasm.memory.set(salt, 32)\n  if (personal) wasm.memory.set(personal, 48)\n\n  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216) // we need 216 bytes for the state\n  wasm.exports.blake2b_init(this.pointer, this.digestLength)\n\n  if (key) {\n    this.update(key)\n    wasm.memory.fill(0, head, head + key.length) // whiteout key\n    wasm.memory[this.pointer + 200] = 128\n  }\n}\n\n\nBlake2b.prototype.update = function (input) {\n  assert(this.finalized === false, 'Hash instance finalized')\n  assert(input, 'input must be TypedArray or Buffer')\n\n  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length)\n  wasm.memory.set(input, head)\n  wasm.exports.blake2b_update(this.pointer, head, head + input.length)\n  return this\n}\n\nBlake2b.prototype.digest = function (enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n  this.finalized = true\n\n  freeList.push(this.pointer)\n  wasm.exports.blake2b_final(this.pointer)\n\n  if (!enc || enc === 'binary') {\n    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength)\n  }\n\n  if (enc === 'hex') {\n    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength)\n  }\n\n  assert(enc.length >= this.digestLength, 'input must be TypedArray or Buffer')\n  for (var i = 0; i < this.digestLength; i++) {\n    enc[i] = wasm.memory[this.pointer + 128 + i]\n  }\n\n  return enc\n}\n\n// libsodium compat\nBlake2b.prototype.final = Blake2b.prototype.digest\n\nBlake2b.WASM = wasm && wasm.buffer\nBlake2b.SUPPORTED = typeof WebAssembly !== 'undefined'\n\nBlake2b.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasm) return cb(new Error('WebAssembly not supported'))\n\n  // backwards compat, can be removed in a new major\n  var p = new Promise(function (reject, resolve) {\n    wasm.onload(function (err) {\n      if (err) resolve()\n      else reject()\n      cb(err)\n    })\n  })\n\n  return p\n}\n\nBlake2b.prototype.ready = Blake2b.ready\n\nfunction noop () {}\n\nfunction hexSlice (buf, start, len) {\n  var str = ''\n  for (var i = 0; i < len; i++) str += toHex(buf[start + i])\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n","\nmodule.exports = loadWebAssembly\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (opts) {\n  if (!loadWebAssembly.supported) return null\n\n  var imp = opts && opts.imports\n  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL')\n  var ready = null\n\n  var mod = {\n    buffer: wasm,\n    memory: null,\n    exports: null,\n    realloc: realloc,\n    onload: onload\n  }\n\n  onload(function () {})\n\n  return mod\n\n  function realloc (size) {\n    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536))\n    mod.memory = new Uint8Array(mod.exports.memory.buffer)\n  }\n\n  function onload (cb) {\n    if (mod.exports) return cb()\n\n    if (ready) {\n      ready.then(cb.bind(null, null)).catch(cb)\n      return\n    }\n\n    try {\n      if (opts && opts.async) throw new Error('async')\n      setup({instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)})\n    } catch (err) {\n      ready = WebAssembly.instantiate(wasm, imp).then(setup)\n    }\n\n    onload(cb)\n  }\n\n  function setup (w) {\n    mod.exports = w.instance.exports\n    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer)\n  }\n}\n\nfunction toUint8Array (s) {\n  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt))\n  return new (require('buf' + 'fer').Buffer)(s, 'base64')\n}\n\nfunction charCodeAt (c) {\n  return c.charCodeAt(0)\n}\n","var assert = require('nanoassert')\nvar randombytes_buf = require('./randombytes').randombytes_buf\nvar blake2b = require('blake2b')\n\nmodule.exports.crypto_kdf_PRIMITIVE = 'blake2b'\nmodule.exports.crypto_kdf_BYTES_MIN = 16\nmodule.exports.crypto_kdf_BYTES_MAX = 64\nmodule.exports.crypto_kdf_CONTEXTBYTES = 8\nmodule.exports.crypto_kdf_KEYBYTES = 32\n\nfunction STORE64_LE(dest, int) {\n  var mul = 1\n  var i = 0\n  dest[0] = int & 0xFF\n  while (++i < 8 && (mul *= 0x100)) {\n    dest[i] = (int / mul) & 0xFF\n  }\n}\n\nmodule.exports.crypto_kdf_derive_from_key = function crypto_kdf_derive_from_key (subkey, subkey_id, ctx, key) {\n  assert(subkey.length >= module.exports.crypto_kdf_BYTES_MIN, 'subkey must be at least crypto_kdf_BYTES_MIN')\n  assert(subkey_id >= 0 && subkey_id <= 0x1fffffffffffff, 'subkey_id must be safe integer')\n  assert(ctx.length >= module.exports.crypto_kdf_CONTEXTBYTES, 'context must be at least crypto_kdf_CONTEXTBYTES')\n\n  var ctx_padded = new Uint8Array(blake2b.PERSONALBYTES)\n  var salt = new Uint8Array(blake2b.SALTBYTES)\n\n  ctx_padded.set(ctx, 0, module.exports.crypto_kdf_CONTEXTBYTES)\n  STORE64_LE(salt, subkey_id)\n\n  var outlen = Math.min(subkey.length, module.exports.crypto_kdf_BYTES_MAX)\n  blake2b(outlen, key.subarray(0, module.exports.crypto_kdf_KEYBYTES), salt, ctx_padded, true)\n    .final(subkey)\n}\n\nmodule.exports.crypto_kdf_keygen = function crypto_kdf_keygen (out) {\n  assert(out.length >= module.exports.crypto_kdf_KEYBYTES, 'out.length must be crypto_kdf_KEYBYTES')\n  randombytes_buf(out.subarray(0, module.exports.crypto_kdf_KEYBYTES))\n}\n","var siphash = require('siphash24')\n\nexports.crypto_shorthash_PRIMITIVE = 'siphash24'\nexports.crypto_shorthash_BYTES = siphash.BYTES\nexports.crypto_shorthash_KEYBYTES = siphash.KEYBYTES\nexports.crypto_shorthash_WASM_SUPPORTED = siphash.WASM_SUPPORTED\nexports.crypto_shorthash_WASM_LOADED = siphash.WASM_LOADED\nexports.crypto_shorthash = shorthash\n\nfunction shorthash (out, data, key, noAssert) {\n  siphash(data, key, out, noAssert)\n}\n","var wasm = require('./siphash24')\nvar fallback = require('./fallback')\nvar assert = require('nanoassert')\n\nmodule.exports = siphash24\n\nvar BYTES = siphash24.BYTES = 8\nvar KEYBYTES = siphash24.KEYBYTES = 16\nvar mod = wasm()\n\nsiphash24.WASM_SUPPORTED = typeof WebAssembly !== 'undefined'\nsiphash24.WASM_LOADED = false\n\nif (mod) {\n  mod.onload(function (err) {\n    siphash24.WASM_LOADED = !err\n  })\n}\n\nfunction siphash24 (data, key, out, noAssert) {\n  if (!out) out = new Uint8Array(8)\n\n  if (noAssert !== true) {\n    assert(out.length >= BYTES, 'output must be at least ' + BYTES)\n    assert(key.length >= KEYBYTES, 'key must be at least ' + KEYBYTES)\n  }\n\n  if (mod && mod.exports) {\n    if (data.length + 24 > mod.memory.length) mod.realloc(data.length + 24)\n    mod.memory.set(key, 8)\n    mod.memory.set(data, 24)\n    mod.exports.siphash(24, data.length)\n    out.set(mod.memory.subarray(0, 8))\n  } else {\n    fallback(out, data, key)\n  }\n\n  return out\n}\n","\nmodule.exports = loadWebAssembly\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (opts) {\n  if (!loadWebAssembly.supported) return null\n\n  var imp = opts && opts.imports\n  var wasm = toUint8Array('AGFzbQEAAAABBgFgAn9/AAMCAQAFBQEBCpBOBxQCBm1lbW9yeQIAB3NpcGhhc2gAAArdCAHaCAIIfgJ/QvXKzYPXrNu38wAhAkLt3pHzlszct+QAIQNC4eSV89bs2bzsACEEQvPK0cunjNmy9AAhBUEIKQMAIQdBECkDACEIIAGtQjiGIQYgAUEHcSELIAAgAWogC2shCiAFIAiFIQUgBCAHhSEEIAMgCIUhAyACIAeFIQICQANAIAAgCkYNASAAKQMAIQkgBSAJhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAmFIQIgAEEIaiEADAALCwJAAkACQAJAAkACQAJAAkAgCw4HBwYFBAMCAQALIAYgADEABkIwhoQhBgsgBiAAMQAFQiiGhCEGCyAGIAAxAARCIIaEIQYLIAYgADEAA0IYhoQhBgsgBiAAMQACQhCGhCEGCyAGIAAxAAFCCIaEIQYLIAYgADEAAIQhBgsgBSAGhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAaFIQIgBEL/AYUhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEQQAgAiADIAQgBYWFhTcDAAs=')\n  var ready = null\n\n  var mod = {\n    buffer: wasm,\n    memory: null,\n    exports: null,\n    realloc: realloc,\n    onload: onload\n  }\n\n  onload(function () {})\n\n  return mod\n\n  function realloc (size) {\n    mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)))\n    mod.memory = new Uint8Array(mod.exports.memory.buffer)\n  }\n\n  function onload (cb) {\n    if (mod.exports) return cb()\n\n    if (ready) {\n      ready.then(cb.bind(null, null)).catch(cb)\n      return\n    }\n\n    try {\n      if (opts && opts.async) throw new Error('async')\n      setup({instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)})\n    } catch (err) {\n      ready = WebAssembly.instantiate(wasm, imp).then(setup)\n    }\n\n    onload(cb)\n  }\n\n  function setup (w) {\n    mod.exports = w.instance.exports\n    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer)\n  }\n}\n\nfunction toUint8Array (s) {\n  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt))\n  return new (require('buf' + 'fer').Buffer)(s, 'base64')\n}\n\nfunction charCodeAt (c) {\n  return c.charCodeAt(0)\n}\n","module.exports = fallback\n\nfunction _add (a, b) {\n  var rl = a.l + b.l\n  var a2 = {\n    h: a.h + b.h + (rl / 2 >>> 31) >>> 0,\n    l: rl >>> 0\n  }\n  a.h = a2.h\n  a.l = a2.l\n}\n\nfunction _xor (a, b) {\n  a.h ^= b.h\n  a.h >>>= 0\n  a.l ^= b.l\n  a.l >>>= 0\n}\n\nfunction _rotl (a, n) {\n  var a2 = {\n    h: a.h << n | a.l >>> (32 - n),\n    l: a.l << n | a.h >>> (32 - n)\n  }\n  a.h = a2.h\n  a.l = a2.l\n}\n\nfunction _rotl32 (a) {\n  var al = a.l\n  a.l = a.h\n  a.h = al\n}\n\nfunction _compress (v0, v1, v2, v3) {\n  _add(v0, v1)\n  _add(v2, v3)\n  _rotl(v1, 13)\n  _rotl(v3, 16)\n  _xor(v1, v0)\n  _xor(v3, v2)\n  _rotl32(v0)\n  _add(v2, v1)\n  _add(v0, v3)\n  _rotl(v1, 17)\n  _rotl(v3, 21)\n  _xor(v1, v2)\n  _xor(v3, v0)\n  _rotl32(v2)\n}\n\nfunction _get_int (a, offset) {\n  return (a[offset + 3] << 24) | (a[offset + 2] << 16) | (a[offset + 1] << 8) | a[offset]\n}\n\nfunction fallback (out, m, key) { // modified from https://github.com/jedisct1/siphash-js to use uint8arrays\n  var k0 = {h: _get_int(key, 4), l: _get_int(key, 0)}\n  var k1 = {h: _get_int(key, 12), l: _get_int(key, 8)}\n  var v0 = {h: k0.h, l: k0.l}\n  var v2 = k0\n  var v1 = {h: k1.h, l: k1.l}\n  var v3 = k1\n  var mi\n  var mp = 0\n  var ml = m.length\n  var ml7 = ml - 7\n  var buf = new Uint8Array(new ArrayBuffer(8))\n\n  _xor(v0, {h: 0x736f6d65, l: 0x70736575})\n  _xor(v1, {h: 0x646f7261, l: 0x6e646f6d})\n  _xor(v2, {h: 0x6c796765, l: 0x6e657261})\n  _xor(v3, {h: 0x74656462, l: 0x79746573})\n\n  while (mp < ml7) {\n    mi = {h: _get_int(m, mp + 4), l: _get_int(m, mp)}\n    _xor(v3, mi)\n    _compress(v0, v1, v2, v3)\n    _compress(v0, v1, v2, v3)\n    _xor(v0, mi)\n    mp += 8\n  }\n\n  buf[7] = ml\n  var ic = 0\n  while (mp < ml) {\n    buf[ic++] = m[mp++]\n  }\n  while (ic < 7) {\n    buf[ic++] = 0\n  }\n\n  mi = {\n    h: buf[7] << 24 | buf[6] << 16 | buf[5] << 8 | buf[4],\n    l: buf[3] << 24 | buf[2] << 16 | buf[1] << 8 | buf[0]\n  }\n\n  _xor(v3, mi)\n  _compress(v0, v1, v2, v3)\n  _compress(v0, v1, v2, v3)\n  _xor(v0, mi)\n  _xor(v2, { h: 0, l: 0xff })\n  _compress(v0, v1, v2, v3)\n  _compress(v0, v1, v2, v3)\n  _compress(v0, v1, v2, v3)\n  _compress(v0, v1, v2, v3)\n\n  var h = v0\n  _xor(h, v1)\n  _xor(h, v2)\n  _xor(h, v3)\n\n  out[0] = h.l & 0xff\n  out[1] = (h.l >> 8) & 0xff\n  out[2] = (h.l >> 16) & 0xff\n  out[3] = (h.l >> 24) & 0xff\n  out[4] = h.h & 0xff\n  out[5] = (h.h >> 8) & 0xff\n  out[6] = (h.h >> 16) & 0xff\n  out[7] = (h.h >> 24) & 0xff\n}\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n","var util = require('util')\nvar custom = util.inspect.custom\n\nmodule.exports = custom || Symbol.for('util.inspect.custom')\n","\nmodule.exports = function prettyHash (buf) {\n  if (Buffer.isBuffer(buf)) buf = buf.toString('hex')\n  if (typeof buf === 'string' && buf.length > 8) {\n    return buf.slice(0, 6) + '..' + buf.slice(-2)\n  }\n  return buf\n}","var protocol = require('hypercore-protocol')\nvar bitfield = require('fast-bitfield')\nvar set = require('unordered-set')\nvar rle = require('bitfield-rle').align(4)\nvar treeIndex = require('./tree-index')\n\nvar EMPTY = new Uint8Array(1024)\n\nmodule.exports = replicate\n\nfunction replicate (feed, opts) {\n  var stream = opts.stream\n\n  if (!stream) {\n    if (!opts.expectedFeeds) opts.expectedFeeds = 1\n    if (!opts.id) opts.id = feed.id\n    stream = protocol(opts)\n  }\n\n  feed.ready(function (err) {\n    if (err) return stream.destroy(err)\n    if (stream.destroyed) return\n\n    var peer = new Peer(feed, opts)\n    peer.feed = feed\n    peer.stream = stream.feed(feed.key, {peer: peer})\n\n    peer.remoteId = stream.remoteId\n    stream.setMaxListeners(0)\n    stream.on('handshake', function () {\n      peer.remoteId = stream.remoteId\n    })\n\n    // stream might get destroyed on feed init in case of conf errors\n    if (stream.destroyed) return\n\n    peer.ready()\n  })\n\n  return stream\n}\n\nfunction Peer (feed, opts) {\n  this.feed = feed\n  this.stream = null // set by replicate just after creation\n  this.remoteId = null\n  this.wants = bitfield()\n  this.remoteBitfield = bitfield()\n  this.remoteLength = 0\n  this.remoteWant = false\n  this.remoteTree = null\n  this.live = !!opts.live\n  this.sparse = feed.sparse\n\n  this.remoteDownloading = true\n  this.downloading = typeof opts.download === 'boolean' ? opts.download : !feed.writable\n  this.uploading = true\n\n  this.maxRequests = opts.maxRequests || feed.maxRequests || 16\n  this.inflightRequests = []\n  this.inflightWants = 0\n\n  this._index = -1\n  this._lastBytes = 0\n  this._first = true\n  this._closed = false\n  this._destroyed = false\n  this._defaultDownloading = this.downloading\n  this._iterator = this.remoteBitfield.iterator()\n}\n\nPeer.prototype.onwant = function (want) {\n  if ((want.start & 8191) || (want.length & 8191)) return\n  if (!this.remoteWant && this.feed.length) {\n    // Eagerly send the length of the feed to the otherside\n    // TODO: only send this if the remote is not wanting a region\n    // where this is contained in\n    this.stream.have({ start: this.feed.length - 1 })\n  }\n  this.remoteWant = true\n  var rle = this.feed.bitfield.compress(want.start, want.length)\n  this.stream.have({start: want.start, length: want.length, bitfield: rle})\n}\n\nPeer.prototype.ondata = function (data) {\n  var self = this\n\n  // Ignore unrequested messages unless we allow push\n  // TODO: would be better to check if the byte range was requested instead, but this works fine\n  var allowPush = this.feed.allowPush || !data.value\n  if (!allowPush && !this.feed._reserved.get(data.index)) {\n    // If we do not have this block, send back unhave message for this index,\n    // to let the remote know we rejected it.\n    // TODO: we might want to have some \"unwanted push\" threshold to punish spammers\n    if (!self.feed.bitfield.get(data.index)) self.unhave({start: data.index})\n    self._clear(data.index, !data.value)\n    return\n  }\n\n  this.feed._putBuffer(data.index, data.value, data, this, function (err) {\n    if (err) return self.destroy(err)\n    self.remoteBitfield.set(data.index, false)\n    self._clear(data.index, !data.value)\n  })\n}\n\nPeer.prototype._clear = function (index, hash) {\n  // TODO: optimize me (no splice and do not run through all ...)\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].index === index) {\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.feed._reserved.set(index, false)\n  // TODO: only update all if we have overlapping selections\n  this.feed._updatePeers()\n}\n\nPeer.prototype.onrequest = function (request) {\n  if (request.bytes) return this._onbytes(request)\n\n  // lazily instantiate the remote tree\n  if (!this.remoteTree) this.remoteTree = treeIndex()\n\n  var self = this\n  var opts = {digest: request.nodes, hash: request.hash, tree: this.remoteTree}\n\n  this.feed.proof(request.index, opts, onproof)\n\n  function onproof (err, proof) {\n    if (err) return self.destroy(err)\n    if (request.hash) onvalue(null, null)\n    else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue)\n\n    function onvalue (err, value) {\n      if (err) return self.destroy(err)\n\n      if (value) {\n        self.feed.emit('upload', request.index, value, self)\n      }\n\n      // TODO: prob not needed with new bitfield\n      if (request.index + 1 > self.remoteLength) {\n        self.remoteLength = request.index + 1\n        self._updateEnd()\n      }\n\n      self.stream.data({\n        index: request.index,\n        value: value,\n        nodes: proof.nodes,\n        signature: proof.signature\n      })\n    }\n  }\n}\n\nPeer.prototype._onbytes = function (request) {\n  var self = this\n\n  this.feed.seek(request.bytes, {wait: false}, function (err, index) {\n    if (err) {\n      request.bytes = 0\n      self.onrequest(request)\n      return\n    }\n\n    // quick'n'dirty filter for parallel bytes requests\n    // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization\n    if (self._lastBytes === request.bytes) return\n    self._lastBytes = request.bytes\n\n    request.bytes = 0\n    request.index = index\n    request.nodes = 0\n\n    self.onrequest(request)\n  })\n}\n\nPeer.prototype.ontick = function () {\n  if (!this.inflightRequests.length) return\n\n  var first = this.inflightRequests[0]\n  if (--first.tick) return\n\n  if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {\n    // prob a bytes response\n    this.inflightRequests.shift()\n    this.feed._reserved.set(first.index, false)\n    return\n  }\n\n  this.destroy(new Error('Request timeout'))\n}\n\nPeer.prototype.onhave = function (have) {\n  var updated = this._first\n  if (this._first) this._first = false\n\n  if (have.length === 1024 * 1024) {\n    this.inflightWants--\n  }\n\n  if (have.bitfield) { // TODO: handle start !== 0\n    if (have.length === 0 || have.length === 1) { // length === 1 is for backwards compat\n      this.wants = null // we are in backwards compat mode where we subscribe everything\n    }\n    var buf = rle.decode(have.bitfield)\n    var bits = buf.length * 8\n    remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start)\n    this.remoteBitfield.fill(buf, have.start)\n    if (bits > this.remoteLength) {\n      this.remoteLength = this.remoteBitfield.last() + 1\n      updated = true\n    }\n  } else {\n    // TODO: if len > something simply copy a 0b1111... buffer to the bitfield\n\n    var start = have.start\n    var len = have.length || 1\n\n    while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++))\n    if (start > this.remoteLength) {\n      this.remoteLength = start\n      updated = true\n    }\n  }\n\n  if (updated) {\n    this.feed.emit('remote-update', this)\n  }\n\n  this._updateEnd()\n  this.update()\n}\n\nPeer.prototype._updateEnd = function () {\n  if (this.live || this.feed.sparse || !this.feed._selections.length) return\n\n  var sel = this.feed._selections[0]\n  var remoteLength = this.feed.length || -1\n\n  for (var i = 0; i < this.feed.peers.length; i++) {\n    if (this.feed.peers[i].remoteLength > remoteLength) {\n      remoteLength = this.feed.peers[i].remoteLength\n    }\n  }\n\n  sel.end = remoteLength\n}\n\nPeer.prototype.oninfo = function (info) {\n  this.remoteDownloading = info.downloading\n  if (info.downloading || this.live) return\n  this.update()\n  if (this.feed._selections.length && this.downloading) return\n  this.end()\n}\n\nPeer.prototype.onunhave = function (unhave) {\n  var start = unhave.start\n  var len = unhave.length || 1\n\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.onunwant =\nPeer.prototype.oncancel = function () {\n  // TODO: impl all of me\n}\n\nPeer.prototype.onclose = function () {\n  this.destroy()\n}\n\nPeer.prototype.have = function (have) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.have(have)\n  var start = have.start\n  var len = have.length\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.unhave = function (unhave) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.unhave(unhave)\n}\n\nPeer.prototype.haveBytes = function (bytes) { // called by feed\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].bytes === bytes) {\n      this.feed._reserved.set(this.inflightRequests[i].index, false)\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.update()\n}\n\nPeer.prototype.update = function () {\n  // do nothing\n  while (this._update()) {}\n  this._sendWantsMaybe()\n}\n\nPeer.prototype._update = function () {\n  // should return true if mutated false if not\n  if (!this.downloading) return false\n\n  var selections = this.feed._selections\n  var waiting = this.feed._waiting\n  var wlen = waiting.length\n  var slen = selections.length\n  var inflight = this.inflightRequests.length\n  var offset = 0\n  var i = 0\n\n  // TODO: less duplicate code here\n  // TODO: re-add priority levels\n\n  while (inflight < this.maxRequests) {\n    offset = Math.floor(Math.random() * waiting.length)\n\n    for (i = 0; i < waiting.length; i++) {\n      var w = waiting[offset++]\n      if (offset === waiting.length) offset = 0\n\n      this._downloadWaiting(w)\n      if (waiting.length !== wlen) return true // mutated\n      if (this.inflightRequests.length >= this.maxRequests) return false\n    }\n    if (inflight === this.inflightRequests.length) break\n    inflight = this.inflightRequests.length\n  }\n\n  while (inflight < this.maxRequests) {\n    offset = Math.floor(Math.random() * selections.length)\n\n    for (i = 0; i < selections.length; i++) {\n      var s = selections[offset++]\n      if (offset === selections.length) offset = 0\n\n      if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end)\n      this._downloadRange(s)\n      if (selections.length !== slen) return true // mutated\n      if (this.inflightRequests.length >= this.maxRequests) return false\n    }\n\n    if (inflight === this.inflightRequests.length) return false\n    inflight = this.inflightRequests.length\n  }\n\n  return false\n}\n\nPeer.prototype.ready = function () {\n  set.add(this.feed.peers, this)\n  this._sendWants()\n  this.feed.emit('peer-add', this)\n}\n\nPeer.prototype.end = function () {\n  if (!this.downloading && !this.remoteDownloading && !this.live) {\n    if (!this._defaultDownloading) {\n      this.stream.info({downloading: false, uploading: false})\n    }\n    this._close()\n    return\n  }\n  if (!this._closed) {\n    this._closed = true\n    this.downloading = false\n    this.stream.info({downloading: false, uploading: true})\n  } else {\n    if (!this.live) this._close()\n  }\n}\n\nPeer.prototype._close = function () {\n  if (this._index === -1) return\n  if (!this._destroyed) {\n    this.stream.close()\n    this._destroyed = true\n  }\n  set.remove(this.feed.peers, this)\n  this._index = -1\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    this.feed._reserved.set(this.inflightRequests[i].index, false)\n  }\n  this._updateEnd()\n  this.remoteWant = false\n  this.feed._updatePeers()\n  this.feed.emit('peer-remove', this)\n}\n\nPeer.prototype.destroy = function (err) {\n  if (this._index === -1 || this._destroyed) return\n  this.stream.destroy(err)\n  this._destroyed = true\n  this._close()\n}\n\nPeer.prototype._sendWantsMaybe = function () {\n  if (this.inflightRequests.length < this.maxRequests) this._sendWants()\n}\n\nPeer.prototype._sendWants = function () {\n  if (!this.wants || !this.downloading) return\n  if (this.inflightWants >= 16) return\n\n  var i\n\n  for (i = 0; i < this.feed._waiting.length; i++) {\n    var w = this.feed._waiting[i]\n    if (w.index === -1) this._sendWantRange(w)\n    else this._sendWant(w.index)\n    if (this.inflightWants >= 16) return\n  }\n\n  for (i = 0; i < this.feed._selections.length; i++) {\n    var s = this.feed._selections[i]\n    this._sendWantRange(s)\n    if (this.inflightWants >= 16) return\n  }\n\n  // always sub to the first range for now, usually what you want\n  this._sendWant(0)\n}\n\nPeer.prototype._sendWantRange = function (s) {\n  while (true) {\n    if (s.want >= this.remoteLength) return\n    if (s.end !== -1 && s.want >= s.end) return\n\n    if (this._sendWant(s.want)) {\n      s.want += 1024 * 1024\n      return\n    }\n\n    // check if region is already selected - if so try next one\n    if (!this.wants.get(Math.floor(s.want / 1024 / 1024))) return\n    s.want += 1024 * 1024\n  }\n}\n\nPeer.prototype._sendWant = function (index) {\n  var len = 1024 * 1024\n  var j = Math.floor(index / len)\n  if (this.wants.get(j)) return false\n  this.wants.set(j, true)\n  this.inflightWants++\n  this.stream.want({start: j * len, length: len})\n  return true\n}\n\nPeer.prototype._downloadWaiting = function (wait) {\n  if (!wait.bytes) {\n    if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) return\n    this._request(wait.index, 0, false)\n    return\n  }\n\n  this._downloadRange(wait)\n}\n\nPeer.prototype._downloadRange = function (range) {\n  if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end)\n\n  var reserved = this.feed._reserved\n  var ite = this._iterator\n  var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength)\n\n  var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd)\n  var start = i\n\n  if (i === -1 || i >= wantedEnd) {\n    if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {\n      set.remove(this.feed._selections, range)\n      range.callback(null)\n      if (!this.live && !this.sparse && !this.feed._selections.length) this.end()\n    }\n    return\n  }\n\n  while ((range.hash && this.feed.tree.get(2 * i)) || !reserved.set(i, true)) {\n    i = ite.next(true)\n\n    if (i > -1 && i < wantedEnd) {\n      // check this index\n      continue\n    }\n\n    if (!range.linear && start !== 0) {\n      // retry from the beginning since we are iterating randomly and started !== 0\n      i = ite.seek(range.start).next(true)\n      start = 0\n      if (i > -1 && i < wantedEnd) continue\n    }\n\n    // we have checked all indexes.\n    // if we are looking for hashes we should check if we have all now (first check only checks blocks)\n    if (range.hash) {\n      // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots\n      // but we don't really request long ranges of hashes so yolo\n      for (var j = range.start; j < wantedEnd; j++) {\n        if (!this.feed.tree.get(2 * j)) return\n      }\n      if (!range.bytes) {\n        set.remove(this.feed._selections, range)\n        range.callback(null)\n      }\n    }\n\n    // exit the update loop - nothing to do\n    return\n  }\n\n  this._request(i, range.bytes || 0, range.hash)\n}\n\nPeer.prototype._request = function (index, bytes, hash) {\n  var request = {\n    tick: 6,\n    bytes: bytes,\n    index: index,\n    hash: hash,\n    nodes: this.feed.digest(index)\n  }\n\n  this.inflightRequests.push(request)\n  this.stream.request(request)\n}\n\nfunction createView (page) {\n  var buf = page ? page.buffer : EMPTY\n  return new DataView(buf.buffer, buf.byteOffset, 1024)\n}\n\nfunction remoteAndNotLocal (local, buf, le, start) {\n  var remote = new DataView(buf.buffer, buf.byteOffset)\n  var len = Math.floor(buf.length / 4)\n  var arr = new Uint32Array(buf.buffer, buf.byteOffset, len)\n  var p = start / 8192 // 8192 is bits per bitfield page\n  var l = 0\n  var page = createView(local.pages.get(p++, true))\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * (l++), !le)\n\n    if (l === 256) {\n      page = createView(local.pages.get(p++, true))\n      l = 0\n    }\n  }\n}\n\nfunction nextRandom (ite, start, end) {\n  var len = end - start\n  var i = ite.seek(Math.floor(Math.random() * len) + start).next(true)\n  return i === -1 || i >= end ? ite.seek(start).next(true) : i\n}\n","var stream = require('readable-stream')\nvar inherits = require('inherits')\nvar varint = require('varint')\nvar sodium = require('sodium-universal')\nvar indexOf = require('sorted-indexof')\nvar feed = require('./feed')\nvar messages = require('./messages')\nvar bufferAlloc = require('buffer-alloc-unsafe')\nvar bufferFrom = require('buffer-from')\n\nmodule.exports = Protocol\n\nfunction Protocol (opts) {\n  if (!(this instanceof Protocol)) return new Protocol(opts)\n  if (!opts) opts = {}\n\n  stream.Duplex.call(this)\n  var self = this\n\n  this.id = opts.id || randomBytes(32)\n  this.live = !!opts.live\n  this.ack = !!opts.ack\n  this.userData = opts.userData || null\n  this.remoteId = null\n  this.remoteLive = false\n  this.remoteUserData = null\n\n  this.destroyed = false\n  this.encrypted = opts.encrypt !== false\n  this.key = null\n  this.discoveryKey = null\n  this.remoteDiscoveryKey = null\n  this.feeds = []\n  this.expectedFeeds = opts.expectedFeeds || 0\n  this.extensions = opts.extensions || []\n  this.remoteExtensions = null\n  this.maxFeeds = opts.maxFeeds || 256\n\n  this._localFeeds = []\n  this._remoteFeeds = []\n  this._feeds = {}\n\n  this._nonce = null\n  this._remoteNonce = null\n  this._xor = null\n  this._remoteXor = null\n  this._needsKey = false\n  this._length = bufferAlloc(varint.encodingLength(8388608))\n  this._missing = 0\n  this._buf = null\n  this._pointer = 0\n  this._data = null\n  this._start = 0\n  this._cb = null\n  this._interval = null\n  this._keepAlive = 0\n  this._remoteKeepAlive = 0\n  this._maybeFinalize = maybeFinalize\n  this._utp = null\n\n  if (opts.timeout !== 0 && opts.timeout !== false) this.setTimeout(opts.timeout || 5000, this._ontimeout)\n  this.on('finish', this.finalize)\n  this.on('pipe', this._onpipe)\n\n  function maybeFinalize (err) {\n    if (err) return self.destroy(err)\n    if (!self.expectedFeeds) self.finalize()\n  }\n}\n\ninherits(Protocol, stream.Duplex)\n\nProtocol.prototype._onpipe = function (stream) {\n  if (typeof stream.setContentSize === 'function') this._utp = stream\n}\n\nProtocol.prototype._prefinalize = function () {\n  if (!this.emit('prefinalize', this._maybeFinalize)) this.finalize()\n}\n\nProtocol.prototype.setTimeout = function (ms, ontimeout) {\n  if (this.destroyed) return\n  if (ontimeout) this.once('timeout', ontimeout)\n\n  var self = this\n\n  this._keepAlive = 0\n  this._remoteKeepAlive = 0\n\n  clearInterval(this._interval)\n  if (!ms) return\n\n  this._interval = setInterval(kick, (ms / 4) | 0)\n  if (this._interval.unref) this._interval.unref()\n\n  function kick () {\n    self._kick()\n  }\n}\n\nProtocol.prototype.feed = function (key, opts) {\n  if (this.destroyed) return null\n  if (!opts) opts = {}\n\n  var dk = opts.discoveryKey || discoveryKey(key)\n  var ch = this._feed(dk)\n\n  if (ch.id > -1) {\n    if (opts.peer) ch.peer = opts.peer\n    return ch\n  }\n\n  if (this._localFeeds.length >= this.maxFeeds) {\n    this._tooManyFeeds()\n    return null\n  }\n\n  ch.id = this._localFeeds.push(ch) - 1\n  ch.header = ch.id << 4\n  ch.headerLength = varint.encodingLength(ch.header)\n  ch.key = key\n  ch.discoveryKey = dk\n  if (opts.peer) ch.peer = opts.peer\n\n  this.feeds.push(ch)\n\n  var first = !this.key\n  var feed = {\n    discoveryKey: dk,\n    nonce: null\n  }\n\n  if (first) {\n    this.key = key\n    this.discoveryKey = dk\n\n    if (!this._sameKey()) return null\n\n    if (this.encrypted) {\n      feed.nonce = this._nonce = randomBytes(24)\n      this._xor = sodium.crypto_stream_xor_instance(this._nonce, this.key)\n      if (this._remoteNonce) {\n        this._remoteXor = sodium.crypto_stream_xor_instance(this._remoteNonce, this.key)\n      }\n    }\n\n    if (this._needsKey) {\n      this._needsKey = false\n      this._resume()\n    }\n  }\n\n  var box = encodeFeed(feed, ch.id)\n  if (!feed.nonce && this.encrypted) this._xor.update(box, box)\n  this._keepAlive = 0\n  this.push(box)\n\n  if (this.destroyed) return null\n\n  if (first) {\n    ch.handshake({\n      id: this.id,\n      live: this.live,\n      userData: this.userData,\n      extensions: this.extensions,\n      ack: this.ack\n    })\n  }\n\n  if (ch._buffer.length) ch._resume()\n  else ch._buffer = null\n\n  return ch\n}\n\nProtocol.prototype._resume = function () {\n  var self = this\n  process.nextTick(resume)\n\n  function resume () {\n    if (!self._data) return\n\n    var data = self._data\n    var start = self._start\n    var cb = self._cb\n\n    self._data = null\n    self._start = 0\n    self._cb = null\n    self._parse(data, start, cb)\n  }\n}\n\nProtocol.prototype._kick = function () {\n  if (this._remoteKeepAlive > 4) {\n    clearInterval(this._interval)\n    this.emit('timeout')\n    return\n  }\n\n  for (var i = 0; i < this.feeds.length; i++) {\n    var ch = this.feeds[i]\n    if (ch.peer) ch.peer.ontick()\n    else ch.emit('tick')\n  }\n\n  this._remoteKeepAlive++\n\n  if (this._keepAlive > 2) {\n    this.ping()\n    this._keepAlive = 0\n  } else {\n    this._keepAlive++\n  }\n}\n\nProtocol.prototype.ping = function () {\n  if (!this.key) return true\n  var ping = bufferFrom([0])\n  if (this._xor) this._xor.update(ping, ping)\n  return this.push(ping)\n}\n\nProtocol.prototype.destroy = function (err) {\n  if (this.destroyed) return\n  this.destroyed = true\n  if (err) this.emit('error', err)\n  this._close()\n  this.emit('close')\n}\n\nProtocol.prototype.finalize = function () {\n  if (this.destroyed) return\n  this.destroyed = true\n  this._close()\n  this.push(null)\n}\n\nProtocol.prototype._close = function () {\n  clearInterval(this._interval)\n\n  var feeds = this.feeds\n  this.feeds = []\n  for (var i = 0; i < feeds.length; i++) feeds[i]._onclose()\n\n  if (this._xor) {\n    this._xor.final()\n    this._xor = null\n  }\n}\n\nProtocol.prototype._read = function () {\n  // do nothing, user back-pressures\n}\n\nProtocol.prototype._push = function (data) {\n  if (this.destroyed) return\n  this._keepAlive = 0\n  if (this._xor) this._xor.update(data, data)\n  return this.push(data)\n}\n\nProtocol.prototype._write = function (data, enc, cb) {\n  this._remoteKeepAlive = 0\n  this._parse(data, 0, cb)\n}\n\nProtocol.prototype._feed = function (dk) {\n  var hex = dk.toString('hex')\n  var ch = this._feeds[hex]\n  if (ch) return ch\n  ch = this._feeds[hex] = feed(this)\n  return ch\n}\n\nProtocol.prototype.remoteSupports = function (name) {\n  var i = this.extensions.indexOf(name)\n  return i > -1 && !!this.remoteExtensions && this.remoteExtensions.indexOf(i) > -1\n}\n\nProtocol.prototype._onhandshake = function (handshake) {\n  if (this.remoteId) return\n\n  this.remoteId = handshake.id || randomBytes(32)\n  this.remoteLive = handshake.live\n  this.remoteUserData = handshake.userData\n  this.remoteExtensions = indexOf(this.extensions, handshake.extensions)\n  this.remoteAck = handshake.ack\n\n  this.emit('handshake')\n}\n\nProtocol.prototype._onopen = function (id, data, start, end) {\n  var feed = decodeFeed(data, start, end)\n\n  if (!feed) return this._badFeed()\n\n  if (!this.remoteDiscoveryKey) {\n    this.remoteDiscoveryKey = feed.discoveryKey\n    if (!this._sameKey()) return\n\n    if (this.encrypted && !this._remoteNonce) {\n      if (!feed.nonce) {\n        this.destroy(new Error('Remote did not include a nonce'))\n        return\n      }\n      this._remoteNonce = feed.nonce\n    }\n\n    if (this.encrypted && this.key && !this._remoteXor) {\n      this._remoteXor = sodium.crypto_stream_xor_instance(this._remoteNonce, this.key)\n    }\n  }\n\n  this._remoteFeeds[id] = this._feed(feed.discoveryKey)\n  feed.remoteId = id\n\n  this.emit('feed', feed.discoveryKey)\n}\n\nProtocol.prototype._onmessage = function (data, start, end) {\n  if (end - start < 2) return\n\n  var header = decodeHeader(data, start)\n  if (header === -1) return this.destroy(new Error('Remote sent invalid header'))\n\n  start += varint.decode.bytes\n\n  var id = header >> 4\n  var type = header & 15\n\n  if (id >= this.maxFeeds) return this._tooManyFeeds()\n  while (this._remoteFeeds.length < id) this._remoteFeeds.push(null)\n\n  var ch = this._remoteFeeds[id]\n\n  if (type === 0) {\n    if (ch) ch._onclose()\n    return this._onopen(id, data, start, end)\n  }\n\n  if (!ch) return this._badFeed()\n  if (type === 15) return ch._onextension(data, start, end)\n  ch._onmessage(type, data, start, end)\n}\n\nProtocol.prototype._parse = function (data, start, cb) {\n  var decrypted = !!this._remoteXor\n\n  if (start) {\n    data = data.slice(start)\n    start = 0\n  }\n\n  if (this._remoteXor) this._remoteXor.update(data, data)\n\n  while (start < data.length && !this.destroyed) {\n    if (this._missing) start = this._parseMessage(data, start)\n    else start = this._parseLength(data, start)\n\n    if (this._needsKey) {\n      this._data = data\n      this._start = start\n      this._cb = cb\n      return\n    }\n\n    if (!decrypted && this._remoteXor) {\n      return this._parse(data, start, cb)\n    }\n  }\n\n  cb()\n}\n\nProtocol.prototype._parseMessage = function (data, start) {\n  var end = start + this._missing\n\n  if (end <= data.length) {\n    var ret = end\n\n    if (this._buf) {\n      data.copy(this._buf, this._pointer, start)\n      data = this._buf\n      start = 0\n      end = data.length\n      this._buf = null\n    }\n\n    this._missing = 0\n    this._pointer = 0\n    if (this.encrypted && !this.key) this._needsKey = true\n    this._onmessage(data, start, end)\n\n    return ret\n  }\n\n  if (!this._buf) {\n    this._buf = bufferAlloc(this._missing)\n    this._pointer = 0\n  }\n\n  var rem = data.length - start\n\n  data.copy(this._buf, this._pointer, start)\n  this._pointer += rem\n  this._missing -= rem\n\n  return data.length\n}\n\nProtocol.prototype._parseLength = function (data, start) {\n  while (!this._missing && start < data.length) {\n    var byte = this._length[this._pointer++] = data[start++]\n\n    if (!(byte & 0x80)) {\n      this._missing = varint.decode(this._length)\n      this._pointer = 0\n      if (this._missing > 8388608) return this._tooBig(data.length)\n      if (this._utp) {\n        var reallyMissing = this._missing - (data.length - start)\n        if (reallyMissing > 0 && !this._needsKey) this._utp.setContentSize(reallyMissing)\n      }\n      return start\n    }\n\n    if (this._pointer >= this._length.length) return this._tooBig(data.length)\n  }\n\n  return start\n}\n\nProtocol.prototype._sameKey = function () {\n  if (!this.discoveryKey || !this.remoteDiscoveryKey) return true\n  if (this.remoteDiscoveryKey.toString('hex') === this.discoveryKey.toString('hex')) return true\n  this.destroy(new Error('First shared hypercore must be the same'))\n  return false\n}\n\nProtocol.prototype._tooManyFeeds = function () {\n  this.destroy(new Error('Only ' + this.maxFeeds + ' feeds currently supported. Open a Github issue if you need more'))\n}\n\nProtocol.prototype._tooBig = function (len) {\n  this.destroy(new Error('Remote message is larger than 8MB (max allowed)'))\n  return len\n}\n\nProtocol.prototype._badFeed = function () {\n  this.destroy(new Error('Remote sent invalid feed message'))\n}\n\nProtocol.prototype._ontimeout = function () {\n  this.destroy(new Error('Remote timed out'))\n}\n\nfunction decodeHeader (data, start) {\n  try {\n    return varint.decode(data, start)\n  } catch (err) {\n    return -1\n  }\n}\n\nfunction decodeFeed (data, start, end) {\n  var feed = null\n\n  try {\n    feed = messages.Feed.decode(data, start, end)\n  } catch (err) {\n    return null\n  }\n\n  if (feed.discoveryKey.length !== 32) return null\n  if (feed.nonce && feed.nonce.length !== 24) return null\n\n  return feed\n}\n\nfunction encodeFeed (feed, id) {\n  var header = id << 4\n  var len = varint.encodingLength(header) + messages.Feed.encodingLength(feed)\n  var box = bufferAlloc(varint.encodingLength(len) + len)\n  var offset = 0\n\n  varint.encode(len, box, offset)\n  offset += varint.encode.bytes\n\n  varint.encode(header, box, offset)\n  offset += varint.encode.bytes\n\n  messages.Feed.encode(feed, box, offset)\n  return box\n}\n\nfunction discoveryKey (key) {\n  var buf = bufferAlloc(32)\n  sodium.crypto_generichash(buf, bufferFrom('hypercore'), key)\n  return buf\n}\n\nfunction randomBytes (n) {\n  var buf = bufferAlloc(n)\n  sodium.randombytes_buf(buf)\n  return buf\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","module.exports = indexOf\n\nfunction indexOf (left, right) {\n  var result = new Array(right.length)\n  var i = 0\n  var j = 0\n\n  while (i < left.length && j < right.length) {\n    var a = left[i]\n    var b = right[j]\n\n    if (a === b) {\n      result[j++] = i\n      continue\n    }\n\n    if (a < b) {\n      i++\n      continue\n    }\n\n    result[j++] = -1\n    continue\n  }\n\n  for (; j < right.length; j++) result[j] = -1\n\n  return result\n}\n","var events = require('events')\nvar inherits = require('inherits')\nvar varint = require('varint')\nvar messages = require('./messages')\nvar bufferAlloc = require('buffer-alloc-unsafe')\n\nmodule.exports = Feed\n\nfunction Feed (stream) {\n  if (!(this instanceof Feed)) return new Feed(stream)\n  events.EventEmitter.call(this)\n\n  this.key = null\n  this.discoveryKey = null\n  this.stream = stream\n  this.peer = null // support a peer object to avoid event emitter + closures overhead\n\n  this.id = -1\n  this.remoteId = -1\n  this.header = 0\n  this.headerLength = 0\n  this.closed = false\n\n  this._buffer = []\n}\n\ninherits(Feed, events.EventEmitter)\n\nFeed.prototype.handshake = function (message) {\n  return this._send(1, messages.Handshake, message)\n}\n\nFeed.prototype.info = function (message) {\n  return this._send(2, messages.Info, message)\n}\n\nFeed.prototype.have = function (message) {\n  return this._send(3, messages.Have, message)\n}\n\nFeed.prototype.unhave = function (message) {\n  return this._send(4, messages.Unhave, message)\n}\n\nFeed.prototype.want = function (message) {\n  return this._send(5, messages.Want, message)\n}\n\nFeed.prototype.unwant = function (message) {\n  return this._send(6, messages.Unwant, message)\n}\n\nFeed.prototype.request = function (message) {\n  return this._send(7, messages.Request, message)\n}\n\nFeed.prototype.cancel = function (message) {\n  return this._send(8, messages.Cancel, message)\n}\n\nFeed.prototype.data = function (message) {\n  return this._send(9, messages.Data, message)\n}\n\nFeed.prototype.extension = function (type, message) {\n  var id = this.stream.extensions.indexOf(type)\n  if (id === -1) return false\n\n  var header = this.header | 15\n  var len = this.headerLength + varint.encodingLength(id) + message.length\n  var box = bufferAlloc(varint.encodingLength(len) + len)\n  var offset = 0\n\n  varint.encode(len, box, offset)\n  offset += varint.encode.bytes\n\n  varint.encode(header, box, offset)\n  offset += varint.encode.bytes\n\n  varint.encode(id, box, offset)\n  offset += varint.encode.bytes\n\n  message.copy(box, offset)\n  return this.stream._push(box)\n}\n\nFeed.prototype.remoteSupports = function (name) {\n  return this.stream.remoteSupports(name)\n}\n\nFeed.prototype.destroy = function (err) {\n  this.stream.destroy(err)\n}\n\nFeed.prototype.close = function () {\n  var i = this.stream.feeds.indexOf(this)\n\n  if (i > -1) {\n    this.stream.feeds[i] = this.stream.feeds[this.stream.feeds.length - 1]\n    this.stream.feeds.pop()\n    this.stream._localFeeds[this.id] = null\n    this.id = -1\n\n    if (this.stream.destroyed) return\n    if (this.stream.expectedFeeds <= 0 || --this.stream.expectedFeeds) return\n\n    this.stream._prefinalize()\n  }\n}\n\nFeed.prototype._onclose = function () {\n  if (this.closed) return\n  this.closed = true\n\n  if (!this.stream.destroyed) {\n    this.close()\n    if (this.remoteId > -1) this.stream._remoteFeeds[this.remoteId] = null\n    var hex = this.discoveryKey.toString('hex')\n    if (this.stream._feeds[hex] === this) delete this.stream._feeds[hex]\n  }\n\n  if (this.peer) this.peer.onclose()\n  else this.emit('close')\n}\n\nFeed.prototype._resume = function () {\n  var self = this\n  process.nextTick(resume)\n\n  function resume () {\n    while (self._buffer.length) {\n      var next = self._buffer.shift()\n      self._emit(next.type, next.message)\n    }\n    self._buffer = null\n  }\n}\n\nFeed.prototype._onextension = function (data, start, end) {\n  if (end <= start) return\n\n  var id = varint.decode(data, start)\n  var r = this.stream.remoteExtensions\n  var localId = !r || id >= r.length ? -1 : r[id]\n\n  if (localId === -1) return\n\n  var message = data.slice(start + varint.decode.bytes, end)\n  var name = this.stream.extensions[localId]\n\n  if (this.peer && this.peer.onextension) this.peer.onextension(name, message)\n  else this.emit('extension', name, message)\n}\n\nFeed.prototype._onmessage = function (type, data, start, end) {\n  var message = decodeMessage(type, data, start, end)\n  if (!message || this.closed) return\n\n  if (type === 1) return this.stream._onhandshake(message)\n\n  if (!this._buffer) {\n    this._emit(type, message)\n    return\n  }\n\n  if (this._buffer.length > 16) {\n    this.destroy(new Error('Remote sent too many messages on an unopened feed'))\n    return\n  }\n\n  this._buffer.push({type: type, message: message})\n}\n\nFeed.prototype._emit = function (type, message) {\n  if (this.peer) {\n    switch (type) {\n      case 2: return this.peer.oninfo(message)\n      case 3: return this.peer.onhave(message)\n      case 4: return this.peer.onunhave(message)\n      case 5: return this.peer.onwant(message)\n      case 6: return this.peer.onunwant(message)\n      case 7: return this.peer.onrequest(message)\n      case 8: return this.peer.oncancel(message)\n      case 9: return this.peer.ondata(message)\n    }\n  } else {\n    switch (type) {\n      case 2: return this.emit('info', message)\n      case 3: return this.emit('have', message)\n      case 4: return this.emit('unhave', message)\n      case 5: return this.emit('want', message)\n      case 6: return this.emit('unwant', message)\n      case 7: return this.emit('request', message)\n      case 8: return this.emit('cancel', message)\n      case 9: return this.emit('data', message)\n    }\n  }\n}\n\nFeed.prototype._send = function (type, enc, message) {\n  var header = this.header | type\n  var len = this.headerLength + enc.encodingLength(message)\n  var box = bufferAlloc(varint.encodingLength(len) + len)\n  var offset = 0\n\n  varint.encode(len, box, offset)\n  offset += varint.encode.bytes\n\n  varint.encode(header, box, offset)\n  offset += varint.encode.bytes\n\n  enc.encode(message, box, offset)\n\n  return this.stream._push(box)\n}\n\nfunction decodeMessage (type, data, start, end) {\n  switch (type) {\n    case 1: return decode(messages.Handshake, data, start, end)\n    case 2: return decode(messages.Info, data, start, end)\n    case 3: return decode(messages.Have, data, start, end)\n    case 4: return decode(messages.Unhave, data, start, end)\n    case 5: return decode(messages.Want, data, start, end)\n    case 6: return decode(messages.Unwant, data, start, end)\n    case 7: return decode(messages.Request, data, start, end)\n    case 8: return decode(messages.Cancel, data, start, end)\n    case 9: return decode(messages.Data, data, start, end)\n  }\n}\n\nfunction decode (enc, data, start, end) {\n  try {\n    return enc.decode(data, start, end)\n  } catch (err) {\n    return null\n  }\n}\n","// This file is auto generated by the protocol-buffers cli tool\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require('protocol-buffers-encodings')\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar Feed = exports.Feed = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Handshake = exports.Handshake = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Info = exports.Info = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Have = exports.Have = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unhave = exports.Unhave = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Want = exports.Want = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unwant = exports.Unwant = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Request = exports.Request = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Cancel = exports.Cancel = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Data = exports.Data = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineFeed()\ndefineHandshake()\ndefineInfo()\ndefineHave()\ndefineUnhave()\ndefineWant()\ndefineUnwant()\ndefineRequest()\ndefineCancel()\ndefineData()\n\nfunction defineFeed () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Feed.encodingLength = encodingLength\n  Feed.encode = encode\n  Feed.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    var len = enc[0].encodingLength(obj.discoveryKey)\n    length += 1 + len\n    if (defined(obj.nonce)) {\n      var len = enc[0].encodingLength(obj.nonce)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.discoveryKey, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.nonce)) {\n      buf[offset++] = 18\n      enc[0].encode(obj.nonce, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null,\n      nonce: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.nonce = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHandshake () {\n  var enc = [\n    encodings.bytes,\n    encodings.bool,\n    encodings.string\n  ]\n\n  Handshake.encodingLength = encodingLength\n  Handshake.encode = encode\n  Handshake.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.id)) {\n      var len = enc[0].encodingLength(obj.id)\n      length += 1 + len\n    }\n    if (defined(obj.live)) {\n      var len = enc[1].encodingLength(obj.live)\n      length += 1 + len\n    }\n    if (defined(obj.userData)) {\n      var len = enc[0].encodingLength(obj.userData)\n      length += 1 + len\n    }\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        var len = enc[2].encodingLength(obj.extensions[i])\n        length += 1 + len\n      }\n    }\n    if (defined(obj.ack)) {\n      var len = enc[1].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.id)) {\n      buf[offset++] = 10\n      enc[0].encode(obj.id, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.live)) {\n      buf[offset++] = 16\n      enc[1].encode(obj.live, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.userData)) {\n      buf[offset++] = 26\n      enc[0].encode(obj.userData, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        buf[offset++] = 34\n        enc[2].encode(obj.extensions[i], buf, offset)\n        offset += enc[2].encode.bytes\n      }\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 40\n      enc[1].encode(obj.ack, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      id: null,\n      live: false,\n      userData: null,\n      extensions: [],\n      ack: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.id = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.live = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        obj.userData = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 4:\n        obj.extensions.push(enc[2].decode(buf, offset))\n        offset += enc[2].decode.bytes\n        break\n        case 5:\n        obj.ack = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineInfo () {\n  var enc = [\n    encodings.bool\n  ]\n\n  Info.encodingLength = encodingLength\n  Info.encode = encode\n  Info.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.uploading)) {\n      var len = enc[0].encodingLength(obj.uploading)\n      length += 1 + len\n    }\n    if (defined(obj.downloading)) {\n      var len = enc[0].encodingLength(obj.downloading)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.uploading)) {\n      buf[offset++] = 8\n      enc[0].encode(obj.uploading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.downloading)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.downloading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      uploading: false,\n      downloading: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.uploading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.downloading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHave () {\n  var enc = [\n    encodings.varint,\n    encodings.bytes\n  ]\n\n  Have.encodingLength = encodingLength\n  Have.encode = encode\n  Have.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    if (defined(obj.bitfield)) {\n      var len = enc[1].encodingLength(obj.bitfield)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.bitfield)) {\n      buf[offset++] = 26\n      enc[1].encode(obj.bitfield, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1,\n      bitfield: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.bitfield = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnhave () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unhave.encodingLength = encodingLength\n  Unhave.encode = encode\n  Unhave.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineWant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Want.encodingLength = encodingLength\n  Want.encode = encode\n  Want.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnwant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unwant.encodingLength = encodingLength\n  Unwant.encode = encode\n  Unwant.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineRequest () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Request.encodingLength = encodingLength\n  Request.encode = encode\n  Request.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      var len = enc[0].encodingLength(obj.nodes)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      buf[offset++] = 32\n      enc[0].encode(obj.nodes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false,\n      nodes: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.nodes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineCancel () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Cancel.encodingLength = encodingLength\n  Cancel.encode = encode\n  Cancel.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineData () {\n  var Node = Data.Node = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineNode()\n\n  function defineNode () {\n    var enc = [\n      encodings.varint,\n      encodings.bytes\n    ]\n\n    Node.encodingLength = encodingLength\n    Node.encode = encode\n    Node.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      var len = enc[0].encodingLength(obj.index)\n      length += 1 + len\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      var len = enc[0].encodingLength(obj.size)\n      length += 1 + len\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      buf[offset++] = 8\n      enc[0].encode(obj.index, buf, offset)\n      offset += enc[0].encode.bytes\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      buf[offset++] = 18\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      buf[offset++] = 24\n      enc[0].encode(obj.size, buf, offset)\n      offset += enc[0].encode.bytes\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        index: 0,\n        hash: null,\n        size: 0\n      }\n      var found0 = false\n      var found1 = false\n      var found2 = false\n      while (true) {\n        if (end <= offset) {\n          if (!found0 || !found1 || !found2) throw new Error(\"Decoded message is not valid\")\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.index = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found0 = true\n          break\n          case 2:\n          obj.hash = enc[1].decode(buf, offset)\n          offset += enc[1].decode.bytes\n          found1 = true\n          break\n          case 3:\n          obj.size = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found2 = true\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    Node\n  ]\n\n  Data.encodingLength = encodingLength\n  Data.encode = encode\n  Data.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = enc[1].encodingLength(obj.value)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        var len = enc[2].encodingLength(obj.nodes[i])\n        length += varint.encodingLength(len)\n        length += 1 + len\n      }\n    }\n    if (defined(obj.signature)) {\n      var len = enc[1].encodingLength(obj.signature)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.value, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        buf[offset++] = 26\n        varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset)\n        offset += varint.encode.bytes\n        enc[2].encode(obj.nodes[i], buf, offset)\n        offset += enc[2].encode.bytes\n      }\n    }\n    if (defined(obj.signature)) {\n      buf[offset++] = 34\n      enc[1].encode(obj.signature, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      value: null,\n      nodes: [],\n      signature: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.value = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.nodes.push(enc[2].decode(buf, offset, offset + len))\n        offset += enc[2].decode.bytes\n        break\n        case 4:\n        obj.signature = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n","var varint = require('varint')\nvar svarint = require('signed-varint')\n\nexports.make = encoder\n\nexports.name = function (enc) {\n  var keys = Object.keys(exports)\n  for (var i = 0; i < keys.length; i++) {\n    if (exports[keys[i]] === enc) return keys[i]\n  }\n  return null\n}\n\nexports.skip = function (type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset)\n      return offset + varint.decode.bytes\n\n    case 1:\n      return offset + 8\n\n    case 2:\n      var len = varint.decode(buffer, offset)\n      return offset + varint.decode.bytes + len\n\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported')\n\n    case 5:\n      return offset + 4\n  }\n\n  throw new Error('Unknown wire type: ' + type)\n}\n\nexports.bytes = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = bufferLength(val)\n\n    varint.encode(len, buffer, offset)\n    offset += varint.encode.bytes\n\n    if (Buffer.isBuffer(val)) val.copy(buffer, offset)\n    else buffer.write(val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = buffer.slice(offset, offset + len)\n    offset += val.length\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = bufferLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.string = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = Buffer.byteLength(val)\n\n    varint.encode(len, buffer, offset, 'utf-8')\n    offset += varint.encode.bytes\n\n    buffer.write(val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = buffer.toString('utf-8', offset, offset + len)\n    offset += len\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = Buffer.byteLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.bool = encoder(0,\n  function encode (val, buffer, offset) {\n    buffer[offset] = val ? 1 : 0\n    encode.bytes = 1\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var bool = buffer[offset] > 0\n    decode.bytes = 1\n    return bool\n  },\n  function encodingLength () {\n    return 1\n  }\n)\n\nexports.int32 = encoder(0,\n  function encode (val, buffer, offset) {\n    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)\n    encode.bytes = varint.encode.bytes\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    decode.bytes = varint.decode.bytes\n    return val > 2147483647 ? val - 4294967296 : val\n  },\n  function encodingLength (val) {\n    return varint.encodingLength(val < 0 ? val + 4294967296 : val)\n  }\n)\n\nexports.int64 = encoder(0,\n  function encode (val, buffer, offset) {\n    if (val < 0) {\n      var last = offset + 9\n      varint.encode(val * -1, buffer, offset)\n      offset += varint.encode.bytes - 1\n      buffer[offset] = buffer[offset] | 0x80\n      while (offset < last - 1) {\n        offset++\n        buffer[offset] = 0xff\n      }\n      buffer[last] = 0x01\n      encode.bytes = 10\n    } else {\n      varint.encode(val, buffer, offset)\n      encode.bytes = varint.encode.bytes\n    }\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    if (val >= Math.pow(2, 63)) {\n      var limit = 9\n      while (buffer[offset + limit - 1] === 0xff) limit--\n      limit = limit || 9\n      var subset = Buffer.allocUnsafe(limit)\n      buffer.copy(subset, 0, offset, offset + limit)\n      subset[limit - 1] = subset[limit - 1] & 0x7f\n      val = -1 * varint.decode(subset, 0)\n      decode.bytes = 10\n    } else {\n      decode.bytes = varint.decode.bytes\n    }\n    return val\n  },\n  function encodingLength (val) {\n    return val < 0 ? 10 : varint.encodingLength(val)\n  }\n)\n\nexports.sint32 =\nexports.sint64 = encoder(0,\n  svarint.encode,\n  svarint.decode,\n  svarint.encodingLength\n)\n\nexports.uint32 =\nexports.uint64 =\nexports.enum =\nexports.varint = encoder(0,\n  varint.encode,\n  varint.decode,\n  varint.encodingLength\n)\n\n// we cannot represent these in javascript so we just use buffers\nexports.fixed64 =\nexports.sfixed64 = encoder(1,\n  function encode (val, buffer, offset) {\n    val.copy(buffer, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.slice(offset, offset + 8)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.double = encoder(1,\n  function encode (val, buffer, offset) {\n    buffer.writeDoubleLE(val, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.readDoubleLE(offset)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.fixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    buffer.writeUInt32LE(val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.readUInt32LE(offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.sfixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    buffer.writeInt32LE(val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.readInt32LE(offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.float = encoder(5,\n  function encode (val, buffer, offset) {\n    buffer.writeFloatLE(val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.readFloatLE(offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nfunction encoder (type, encode, decode, encodingLength) {\n  encode.bytes = decode.bytes = 0\n\n  return {\n    type: type,\n    encode: encode,\n    decode: decode,\n    encodingLength: encodingLength\n  }\n}\n\nfunction bufferLength (val) {\n  return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val)\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","var varint = require('varint')\nexports.encode = function encode (v, b, o) {\n  v = v >= 0 ? v*2 : v*-2 - 1\n  var r = varint.encode(v, b, o)\n  encode.bytes = varint.encode.bytes\n  return r\n}\nexports.decode = function decode (b, o) {\n  var v = varint.decode(b, o)\n  decode.bytes = varint.decode.bytes\n  return v & 1 ? (v+1) / -2 : v / 2\n}\n\nexports.encodingLength = function (v) {\n  return varint.encodingLength(v >= 0 ? v*2 : v*-2 - 1)\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","'use strict'\n\nconst ctz = require('count-trailing-zeros')\n\nmodule.exports = () => new Bitfield()\n\nclass Page {\n  constructor (level) {\n    const buf = new Uint8Array(level ? 8456 : 4360)\n    const b = buf.byteOffset\n\n    this.buffer = buf\n    this.bits = level ? null : new Uint32Array(buf.buffer, b, 1024)\n    this.children = level ? new Array(32768) : null\n    this.level = level\n\n    this.allOne = level\n      ? [\n        new Uint32Array(buf.buffer, b, 1024),\n        new Uint32Array(buf.buffer, b + 4096, 32),\n        new Uint32Array(buf.buffer, b + 4224, 1)\n      ]\n      : [\n        this.bits,\n        new Uint32Array(buf.buffer, b + 4096, 32),\n        new Uint32Array(buf.buffer, b + 4224, 1)\n      ]\n\n    this.oneOne = level\n      ? [\n        new Uint32Array(buf.buffer, b + 4228, 1024),\n        new Uint32Array(buf.buffer, b + 8324, 32),\n        new Uint32Array(buf.buffer, b + 8452, 1)\n      ]\n      : [\n        this.bits,\n        new Uint32Array(buf.buffer, b + 4228, 32),\n        new Uint32Array(buf.buffer, b + 4356, 1)\n      ]\n  }\n}\n\nconst ZEROS = [new Page(0), new Page(1), new Page(2), new Page(3)]\nconst MASK = new Uint32Array(32)\nconst MASK_INCL = new Uint32Array(32)\n\nfor (var i = 0; i < 32; i++) {\n  MASK[i] = Math.pow(2, 31 - i) - 1\n  MASK_INCL[i] = Math.pow(2, 32 - i) - 1\n}\n\nconst LITTLE_ENDIAN = new Uint8Array(MASK.buffer, MASK.byteOffset, 1)[0] === 0xff\n\nclass Bitfield {\n  constructor () {\n    this.length = 32768\n    this.littleEndian = LITTLE_ENDIAN\n\n    this._path = new Uint16Array(5)\n    this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4)\n    this._parents = new Array(4).fill(null)\n    this._page = new Page(0)\n    this._allocs = 1\n  }\n\n  last () {\n    var page = this._page\n    var b = 0\n\n    while (true) {\n      for (var i = 2; i >= 0; i--) {\n        const c = ctz(page.oneOne[i][b])\n        if (c === 32) return -1\n        b = (b << 5) + (31 - c)\n      }\n\n      this._path[page.level] = b\n      if (!page.level) return defactor(this._path)\n      page = page.children[b]\n      b = 0\n    }\n  }\n\n  set (index, bit) {\n    const page = this._getPage(index, bit)\n    if (!page) return false\n\n    const i = this._path[0]\n    const r = i & 31\n    const b = i >>> 5\n    const prev = page.bits[b]\n\n    page.bits[b] = bit\n      ? (prev | (0x80000000 >>> r))\n      : (prev & ~(0x80000000 >>> r))\n\n    const upd = page.bits[b]\n    if (upd === prev) return false\n\n    this._updateAllOne(page, b, upd)\n    this._updateOneOne(page, b, upd)\n\n    return true\n  }\n\n  get (index) {\n    const page = this._getPage(index, false)\n    if (!page) return false\n\n    const i = this._path[0]\n    const r = i & 31\n\n    return (page.bits[i >>> 5] & (0x80000000 >>> r)) !== 0\n  }\n\n  iterator () {\n    return new Iterator(this)\n  }\n\n  fill (val, start, end) {\n    if (!start) start = 0\n    if (val === true) return this._fillBit(true, start, end === 0 ? end : (end || this.length))\n    if (val === false) return this._fillBit(false, start, end === 0 ? end : (end || this.length))\n    this._fillBuffer(val, start, end === 0 ? end : (end || (start + 8 * val.length)))\n  }\n\n  grow () {\n    if (this._page.level === 3) throw new Error('Cannot grow beyond ' + this.length)\n    const page = this._page\n    this._page = new Page(page.level + 1)\n    this._page.children[0] = page\n    if (this._page.level === 3) this.length = Number.MAX_SAFE_INTEGER\n    else this.length *= 32768\n  }\n\n  _fillBuffer (buf, start, end) {\n    if ((start & 7) || (end & 7)) throw new Error('Offsets must be a multiple of 8')\n\n    start /= 8\n    while (end > this.length) this.grow()\n    end /= 8\n\n    const offset = start\n    var page = this._getPage(8 * start, true)\n\n    while (start < end) {\n      const delta = end - start < 4096 ? end - start : 4096\n      const s = start - offset\n\n      start += this._setPageBuffer(page, buf.subarray(s, s + delta), start & 1023)\n      if (start !== end) page = this._nextPage(page, 8 * start)\n    }\n  }\n\n  _fillBit (bit, start, end) {\n    var page = this._getPage(start, bit)\n\n    // TODO: this can be optimised a lot in the case of end - start > 32768\n    // in that case clear levels of 32768 ** 2 instead etc\n\n    while (start < end) {\n      const delta = end - start < 32768 ? end - start : 32768\n      start += this._setPageBits(page, bit, start & 32767, delta)\n      if (start !== end) page = this._nextPage(page, start)\n    }\n  }\n\n  _nextPage (page, start) {\n    const i = ++this._offsets[page.level]\n    return i === 32768\n      ? this._getPage(start, true)\n      : this._parents[page.level].children[i] || this._addPage(this._parents[page.level], i)\n  }\n\n  _setPageBuffer (page, buf, start) {\n    new Uint8Array(page.bits.buffer, page.bits.byteOffset, page.bits.length * 4).set(buf, start)\n    start >>>= 2\n    this._update(page, start, start + (buf.length >>> 2) + (buf.length & 3 ? 1 : 0))\n    return buf.length\n  }\n\n  _setPageBits (page, bit, start, end) {\n    const s = start >>> 5\n    const e = end >>> 5\n    const sm = 0xffffffff >>> (start & 31)\n    const em = ~(0xffffffff >>> (end & 31))\n\n    if (s === e) {\n      page.bits[s] = bit\n        ? page.bits[s] | (sm & em)\n        : page.bits[s] & ~(sm & em)\n      this._update(page, s, s + 1)\n      return end - start\n    }\n\n    page.bits[s] = bit\n      ? page.bits[s] | sm\n      : page.bits[s] & (~sm)\n\n    if (e - s > 2) page.bits.fill(bit ? 0xffffffff : 0, s + 1, e - 1)\n\n    if (e === 1024) {\n      page.bits[e - 1] = bit ? 0xffffffff : 0\n      this._update(page, s, e)\n      return end - start\n    }\n\n    page.bits[e] = bit\n      ? page.bits[e] | em\n      : page.bits[e] & (~em)\n\n    this._update(page, s, e + 1)\n    return end - start\n  }\n\n  _update (page, start, end) {\n    for (; start < end; start++) {\n      const upd = page.bits[start]\n      this._updateAllOne(page, start, upd)\n      this._updateOneOne(page, start, upd)\n    }\n  }\n\n  _updateAllOne (page, b, upd) {\n    var i = 1\n\n    do {\n      for (; i < 3; i++) {\n        const buf = page.allOne[i]\n        const r = b & 31\n        const prev = buf[b >>>= 5]\n        buf[b] = upd === 0xffffffff\n          ? (prev | (0x80000000 >>> r))\n          : (prev & ~(0x80000000 >>> r))\n        upd = buf[b]\n        if (upd === prev) return\n      }\n\n      b += this._offsets[page.level]\n      page = this._parents[page.level]\n      i = 0\n    } while (page)\n  }\n\n  _updateOneOne (page, b, upd) {\n    var i = 1\n\n    do {\n      for (; i < 3; i++) {\n        const buf = page.oneOne[i]\n        const r = b & 31\n        const prev = buf[b >>>= 5]\n        buf[b] = upd !== 0\n          ? (prev | (0x80000000 >>> r))\n          : (prev & ~(0x80000000 >>> r))\n        upd = buf[b]\n        if (upd === prev) return\n      }\n\n      b += this._offsets[page.level]\n      page = this._parents[page.level]\n      i = 0\n\n      if (upd === 0 && page) {\n        // all zeros, non root -> free page\n        page.children[this._offsets[page.level - 1]] = undefined\n      }\n    } while (page)\n  }\n\n  _getPage (index, createIfMissing) {\n    factor(index, this._path)\n\n    while (index >= this.length) {\n      if (!createIfMissing) return null\n      this.grow()\n    }\n\n    var page = this._page\n\n    for (var i = page.level; i > 0 && page; i--) {\n      const p = this._path[i]\n      this._parents[i - 1] = page\n      page = page.children[p] || (createIfMissing ? this._addPage(page, p) : null)\n    }\n\n    return page\n  }\n\n  _addPage (page, i) {\n    this._allocs++\n    page = page.children[i] = new Page(page.level - 1)\n    return page\n  }\n}\n\nclass Iterator {\n  constructor (bitfield) {\n    this._bitfield = bitfield\n    this._path = new Uint16Array(5)\n    this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4)\n    this._parents = new Array(4).fill(null)\n    this._page = null\n    this._allocs = bitfield._allocs\n\n    this.seek(0)\n  }\n\n  seek (index) {\n    this._allocs = this._bitfield._allocs\n\n    if (index >= this._bitfield.length) {\n      this._page = null\n      return this\n    }\n\n    factor(index, this._path)\n\n    this._page = this._bitfield._page\n    for (var i = this._page.level; i > 0; i--) {\n      this._parents[i - 1] = this._page\n      this._page = this._page.children[this._path[i]] || ZEROS[i - 1]\n    }\n\n    return this\n  }\n\n  next (bit) {\n    return bit ? this.nextTrue() : this.nextFalse()\n  }\n\n  nextFalse () {\n    if (this._allocs !== this._bitfield._allocs) {\n      // If a page has been alloced while we are iterating\n      // and we have a zero page in our path we need to reseek\n      // in case that page has been overwritten\n      this.seek(defactor(this._path))\n    }\n\n    var page = this._page\n    var b = this._path[0]\n    var mask = MASK_INCL\n\n    while (page) {\n      for (var i = 0; i < 3; i++) {\n        const r = b & 31\n        const clz = Math.clz32((~page.allOne[i][b >>>= 5]) & mask[r])\n        if (clz !== 32) return this._downLeftFalse(page, i, b, clz)\n        mask = MASK\n      }\n\n      b = this._offsets[page.level]\n      page = this._parents[page.level]\n    }\n\n    return -1\n  }\n\n  _downLeftFalse (page, i, b, clz) {\n    while (true) {\n      while (i) {\n        b = (b << 5) + clz\n        clz = Math.clz32(~page.allOne[--i][b])\n      }\n\n      b = (b << 5) + clz\n\n      if (!page.level) break\n\n      this._parents[page.level - 1] = page\n      this._path[page.level] = b\n\n      page = page.children[b]\n      i = 3\n      clz = b = 0\n    }\n\n    this._page = page\n    this._path[0] = b\n\n    return this._inc()\n  }\n\n  nextTrue () {\n    var page = this._page\n    var b = this._path[0]\n    var mask = MASK_INCL\n\n    while (page) {\n      for (var i = 0; i < 3; i++) {\n        const r = b & 31\n        const clz = Math.clz32(page.oneOne[i][b >>>= 5] & mask[r])\n        if (clz !== 32) return this._downLeftTrue(page, i, b, clz)\n        mask = MASK\n      }\n\n      b = this._offsets[page.level]\n      page = this._parents[page.level]\n    }\n\n    return -1\n  }\n\n  _downLeftTrue (page, i, b, clz) {\n    while (true) {\n      while (i) {\n        b = (b << 5) + clz\n        clz = Math.clz32(page.oneOne[--i][b])\n      }\n\n      b = (b << 5) + clz\n\n      if (!page.level) break\n\n      this._parents[page.level - 1] = page\n      this._path[page.level] = b\n\n      page = page.children[b]\n      i = 3\n      clz = b = 0\n    }\n\n    this._page = page\n    this._path[0] = b\n\n    return this._inc()\n  }\n\n  _inc () {\n    const n = defactor(this._path)\n    if (this._path[0] < 32767) this._path[0]++\n    else this.seek(n + 1)\n    return n\n  }\n}\n\nfunction defactor (out) {\n  return ((((out[3] * 32768 + out[2]) * 32768) + out[1]) * 32768) + out[0]\n}\n\nfunction factor (n, out) {\n  n = (n - (out[0] = (n & 32767))) / 32768\n  n = (n - (out[1] = (n & 32767))) / 32768\n  out[3] = ((n - (out[2] = (n & 32767))) / 32768) & 32767\n}\n","module.exports = function(v) {\n  var c = 32\n  v &= -v\n  if (v) c--\n  if (v & 0x0000FFFF) c -= 16\n  if (v & 0x00FF00FF) c -= 8\n  if (v & 0x0F0F0F0F) c -= 4\n  if (v & 0x33333333) c -= 2\n  if (v & 0x55555555) c -= 1\n  return c\n}\n","var mutexify = function() {\n  var queue = []\n  var used = null\n\n  var call = function () {\n    used(release)\n  }\n\n  var acquire = function (fn) {\n    if (used) return queue.push(fn)\n    used = fn\n    acquire.locked = true\n    process.nextTick(call)\n    return 0\n  }\n\n  acquire.locked = false\n\n  var release = function (fn, err, value) {\n    used = null\n    acquire.locked = false\n    if (queue.length) acquire(queue.shift())\n    if (fn) fn(err, value)\n  }\n\n  return acquire\n}\n\nmodule.exports = mutexify\n","var from = require('from2')\nvar mutexify = require('mutexify')\nvar varint = require('varint')\nvar messages = require('./messages')\nvar codecs = require('codecs')\nvar inherits = require('inherits')\nvar events = require('events')\nvar cache = require('array-lru')\nvar nextTick = require('process-nextick-args')\n\nmodule.exports = Tree\n\nfunction Tree (feed, opts) {\n  if (!(this instanceof Tree)) return new Tree(feed, opts)\n  if (!opts) opts = {}\n\n  events.EventEmitter.call(this)\n\n  this._offset = opts.offset || 0\n  this._codec = opts.codec || codecs(opts.valueEncoding)\n  this._head = typeof opts.checkout === 'number' ? opts.checkout : -1\n  this._lock = mutexify()\n  this._cache = getCache(opts)\n  this._wait = opts.wait !== false\n  this._cached = !!opts.cached\n  this._asNode = !!opts.node\n  this._readonly = !!opts.readonly\n\n  this.feed = feed\n  this.version = this._head\n\n  var self = this\n\n  this.ready(function (err) {\n    if (!err) self.emit('ready')\n  })\n}\n\ninherits(Tree, events.EventEmitter)\n\nTree.prototype.put = function (name, value, cb) {\n  var self = this\n  var names = split(name)\n\n  this._lock(function (release) {\n    self.head(function (err, head, seq) {\n      if (err) return done(err)\n      if (self._readonly) return done(new Error('Cannot delete on a checkout'))\n      if (!head) self._init(names, value, done)\n      else self._put(head, seq, names, value, done)\n    })\n\n    function done (err) {\n      release(cb, err)\n    }\n  })\n}\n\nTree.prototype._put = function (head, seq, names, value, cb) {\n  var self = this\n  var i = 0\n  var end = names.length + 1\n  var index = []\n  var len = self.feed.length\n\n  loop(null, null, null)\n\n  function loop (err, nodes, seqs) {\n    if (err) return cb(err)\n\n    if (nodes) {\n      var result = []\n\n      for (var j = 0; j < nodes.length; j++) {\n        if (split(nodes[j].name)[i - 1] !== names[i - 1]) {\n          result.push(seqs[j])\n        }\n      }\n\n      result.push(len)\n      index.push(result)\n    }\n\n    if (i === end) {\n      var node = {\n        name: join(names),\n        value: self._codec.encode(value),\n        paths: self._deflate(len, index)\n      }\n\n      self.version = self.feed.length\n      self.feed.append(messages.Node.encode(node), cb)\n      return\n    }\n\n    self._list(head, seq, names.slice(0, i++), null, loop)\n  }\n}\n\nTree.prototype.list = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.list(name, null, opts)\n  opts = this._defaultOpts(opts)\n\n  var self = this\n  var names = split(name)\n  var ns = !!(opts.node || opts.nodes)\n\n  this.head(opts, function (err, head, seq) {\n    if (err) return cb(err)\n    if (!head) return cb(notFound(names))\n\n    self._list(head, seq, names, opts, onnodes)\n\n    function onnodes (err, nodes, seqs) {\n      if (err) return cb(err)\n      if (!nodes.length) return cb(notFound(names))\n\n      var list = []\n      for (var i = 0; i < nodes.length; i++) {\n        var nodeNames = split(nodes[i].name)\n        if (nodeNames.length > names.length) {\n          list.push(ns ? self._node(nodes[i], seqs[i]) : nodeNames[names.length])\n        }\n      }\n\n      cb(null, list)\n    }\n  })\n}\n\nTree.prototype._list = function (head, seq, names, opts, cb) {\n  var headIndex\n  try {\n    headIndex = this._inflate(seq, head.paths)\n  } catch (e) {\n    return cb(e)\n  }\n  var cmp = compare(split(head.name), names)\n\n  var index = cmp < headIndex.length && headIndex[cmp]\n  var closest = cmp === names.length\n\n  if (!closest) {\n    if (!index || !index.length || (index.length === 1 && index[0] === seq)) return cb(null, [], [])\n    this._closer(names, cmp, index, opts, cb)\n    return\n  }\n\n  if (!index || !index.length) return cb(null, [], [])\n\n  this._getAll(index, opts, cb)\n}\n\nTree.prototype.get = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.get(name, null, opts)\n  opts = this._defaultOpts(opts)\n\n  var names = split(name)\n  var self = this\n\n  this.head(opts, function (err, head, seq) {\n    if (err) return cb(err)\n    if (!head) return cb(notFound(names))\n    self._get(head, seq, names, null, opts, cb)\n  })\n}\n\nTree.prototype.path = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.path(name, null, opts)\n  opts = this._defaultOpts(opts)\n\n  var names = split(name)\n  var path = []\n  var self = this\n\n  this.head(opts, function (err, head, seq) {\n    if (err) return cb(err)\n    if (!head) return cb(notFound(names))\n    self._get(head, seq, names, path, opts, function (err) {\n      if (err && !err.notFound) return cb(err)\n      cb(null, path)\n    })\n  })\n}\n\nTree.prototype.checkout = function (seq, opts) {\n  opts = this._defaultOpts(opts)\n\n  return new Tree(this.feed, {\n    checkout: seq,\n    readonly: true,\n    offset: this._offset,\n    codec: opts.valueEncoding ? codecs(opts.valueEncoding) : this._codec,\n    cache: this._cache || opts.cache || false,\n    node: opts.node,\n    wait: opts.wait,\n    cached: opts.cached\n  })\n}\n\nTree.prototype._del = function (head, seq, names, cb) {\n  var self = this\n  var i = 0\n  var end = names.length + 1\n  var index = []\n  var len = self.feed.length\n  var ignore = join(names)\n\n  closest(names.length, function (err, c, cseq) {\n    if (err) return cb(err)\n\n    var cnames = c ? split(c.name) : []\n    var depth = compare(names, cnames) + 1\n\n    loop(null, null, null)\n\n    function loop (err, nodes, seqs) {\n      if (err) return cb(err)\n\n      if (nodes && i <= depth) {\n        var result = []\n\n        for (var j = 0; j < nodes.length; j++) {\n          if (split(nodes[j].name)[i - 1] !== names[i - 1]) {\n            if (nodes[j].name !== ignore) {\n              result.push(seqs[j])\n            }\n          }\n        }\n\n        if (i < depth) {\n          result.push(len)\n        }\n\n        index.push(result)\n      }\n\n      if (i === end) {\n        var node = {\n          name: join(names),\n          value: null,\n          paths: self._deflate(len, index)\n        }\n\n        self.version = self.feed.length\n        self.feed.append(messages.Node.encode(node), cb)\n        return\n      }\n\n      self._list(head, seq, names.slice(0, i++), null, loop)\n    }\n  })\n\n  function closest (j, cb) {\n    self._list(head, seq, names.slice(0, j), null, function (err, nodes, seqs) {\n      if (err) return cb(err)\n\n      for (var i = nodes.length - 1; i >= 0; i--) {\n        if (nodes[i].name !== ignore && nodes[i].value) return cb(null, nodes[i], seqs[i])\n      }\n\n      if (j <= 0) {\n        return cb(null, null, -1)\n      }\n\n      closest(j - 1, cb)\n    })\n  }\n}\n\nTree.prototype.del = function (name, cb) {\n  var self = this\n  var names = split(name)\n\n  this._lock(function (release) {\n    self.head(function (err, head, seq) {\n      if (err) return done(err)\n      if (self._readonly) return done(new Error('Cannot delete on a checkout'))\n      if (!head) return done(null)\n      else self._del(head, seq, names, done)\n    })\n\n    function done (err) {\n      release(cb, err)\n    }\n  })\n}\n\nTree.prototype._get = function (head, seq, names, record, opts, cb) {\n  var self = this\n  var headNames = split(head.name)\n  var cmp = compare(names, headNames)\n\n  if (record) record.push(seq)\n\n  if (cmp === headNames.length && cmp === names.length) {\n    if (opts.node) return cb(null, this._node(head, seq))\n    if (!head.value) return cb(notFound(names))\n    return cb(null, this._codec.decode(head.value))\n  }\n\n  var inflated\n  try {\n    inflated = this._inflate(seq, head.paths)\n  } catch (e) {\n    return cb(e)\n  }\n  if (cmp >= inflated.length) return cb(notFound(names))\n\n  var index = inflated[cmp]\n  var len = index.length\n  if (index[len - 1] === seq) len--\n\n  if (!len) return cb(notFound(names))\n\n  var target = cmp < names.length ? names[cmp] : null\n  var error = null\n  var missing = len\n\n  for (var i = 0; i < len; i++) {\n    this._getAndDecode(index[i], opts, onget)\n  }\n\n  function onget (err, node, seq) {\n    if (err) error = err\n\n    if (node) {\n      var nodeNames = split(node.name)\n      if ((cmp < nodeNames.length ? nodeNames[cmp] : null) === target) {\n        return self._get(node, seq, names, record, opts, cb)\n      }\n    }\n\n    if (!--missing) cb(error || notFound(names))\n  }\n}\n\nTree.prototype._closer = function (names, cmp, index, opts, cb) {\n  var self = this\n  var target = names[cmp]\n  var error = null\n  var missing = index.length\n  var done = false\n\n  for (var i = 0; i < index.length; i++) {\n    this._getAndDecode(index[i], opts, onget)\n  }\n\n  function onget (err, node, seq) {\n    if (done) return\n    if (err) error = err\n\n    if (node && split(node.name)[cmp] === target) {\n      self._list(node, seq, names, opts, cb)\n      return\n    }\n\n    if (!--missing) cb(error, [], [])\n  }\n}\n\nTree.prototype.head = function (opts, cb) {\n  if (typeof opts === 'function') return this.head(null, opts)\n  if (this._head >= this._offset) return this._getAndDecode(this._head, opts, cb)\n  if (this._readonly) return cb(null, null, -1)\n\n  var self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (self.feed.length > self._offset) self._getAndDecode(self.feed.length - 1, opts, cb)\n    else cb(null, null, -1)\n  })\n}\n\nTree.prototype.ready = function (cb) {\n  var self = this\n\n  this.feed.ready(function (err) {\n    if (err) return cb(err)\n    if ((self.version === -1 || self._head === -1) && self.feed.length > self._offset) self.version = self.feed.length - 1\n    cb(null)\n  })\n}\n\nTree.prototype.history = function (opts) {\n  opts = this._defaultOpts(opts)\n\n  if (this._offset) opts.start = Math.max(opts.start || 0, this._offset)\n  if (this._head > -1) opts.end = this._head + 1\n\n  var version = opts.start || 0\n  var self = this\n\n  opts.valueEncoding = {\n    encode: function () {},\n    decode: function (buf) {\n      return self._node(messages.Node.decode(buf), version++)\n    }\n  }\n\n  return this.feed.createReadStream(opts)\n}\n\nTree.prototype.diff = function (toTree, opts) {\n  if (typeof toTree === 'number') toTree = this.checkout(toTree)\n  opts = this._defaultOpts(opts)\n\n  var fromTree = this\n  var diffPuts = opts.puts !== false\n  var diffDels = opts.dels !== false\n  var queue = ['/']\n  var first = true\n  var forceVisit = {}\n\n  if (opts.reverse) {\n    fromTree = toTree\n    toTree = this\n  }\n\n  var stream = from.obj(read)\n  return stream\n\n  function firstRead (size, cb) {\n    first = false\n    toTree.head(function (err, head) {\n      if (err) return cb(err)\n      if (!head || head.value) return read(size, cb)\n\n      var parts = head.name.split('/')\n      for (var i = 0; i < parts.length; i++) {\n        forceVisit[parts.slice(0, i).join('/') || '/'] = true\n      }\n\n      read(size, cb)\n    })\n  }\n\n  function read (size, cb) {\n    if (first) return firstRead(size, cb)\n    if (!queue.length) return cb(null, null)\n    visit(queue.pop(), function (err, result) {\n      if (err) return cb(err)\n      if (!result.length) return read(size, cb)\n      for (var i = 0; i < result.length - 1; i++) {\n        stream.push(result[i])\n      }\n      cb(null, result[result.length - 1])\n    })\n  }\n\n  function push (dir, isPut, node, visited, result) {\n    if (isPut && !diffPuts) return\n    if (!isPut && !diffDels) return\n\n    var name = node.name\n    var nameDir = parseDir(dir, node.name)\n\n    if (name === nameDir) {\n      result.push({\n        type: isPut ? 'put' : 'del',\n        name: node.name,\n        version: node.version,\n        value: node.value\n      })\n    }\n\n    if (!visited.hasOwnProperty(nameDir)) {\n      visited[nameDir] = true\n      queue.push(nameDir)\n    }\n  }\n\n  function parseDir (dir, name) {\n    return '/' + split(name).slice(0, split(dir).length + 1).join('/')\n  }\n\n  function visit (dir, cb) {\n    var visited = {}\n\n    toTree.list(dir, {node: true}, function (err, a) {\n      if (err && !err.notFound) return cb(err)\n      if (!a) a = []\n\n      fromTree.list(dir, {node: true}, function (err, b) {\n        if (err && !err.notFound) return cb(err)\n        if (!b) b = []\n\n        var result = []\n        var i = 0\n        var j = 0\n\n        while (i < a.length && j < b.length) {\n          if (a[i].version === b[j].version) {\n            var nameDir = parseDir(dir, a[i].name)\n            if (forceVisit.hasOwnProperty(nameDir) && !visited[nameDir]) {\n              visited[nameDir] = true\n              queue.push(nameDir)\n            }\n            i++\n            j++\n          } else if (a[i].version < b[j].version) {\n            push(dir, true, a[i++], visited, result)\n          } else {\n            push(dir, false, b[j++], visited, result)\n          }\n        }\n\n        for (; i < a.length; i++) push(dir, true, a[i], visited, result)\n        for (; j < b.length; j++) push(dir, false, b[j], visited, result)\n\n        cb(null, result)\n      })\n    })\n  }\n}\n\nTree.prototype._node = function (node, version) {\n  return {\n    type: node.value ? 'put' : 'del',\n    version: version,\n    name: node.name,\n    value: node.value && this._codec.decode(node.value)\n  }\n}\n\nTree.prototype._init = function (names, value, cb) {\n  var index = []\n\n  while (names.length >= index.length) {\n    index.push([this.feed.length])\n  }\n\n  var node = {\n    name: join(names),\n    value: this._codec.encode(value),\n    paths: this._deflate(this.feed.length, index)\n  }\n\n  this.version = this.feed.length\n  this.feed.append(messages.Node.encode(node), cb)\n}\n\nTree.prototype._getAndDecode = function (seq, opts, cb) {\n  if (opts && opts.cached) opts.wait = false\n\n  var self = this\n  var cached = this._cache && this._cache.get(seq)\n  if (cached) return nextTick(cb, null, cached, seq)\n\n  this.feed.get(seq, opts, function (err, value) {\n    if (err) return cb(err)\n    try {\n      var node = new Node(messages.Node.decode(value), seq)\n    } catch (err) {\n      return cb(err)\n    }\n    if (self._cache) self._cache.set(seq, node)\n    cb(null, node, seq)\n  })\n}\n\nTree.prototype._getAll = function (seqs, opts, cb) {\n  if (opts && opts.cached) seqs = this._onlyCached(seqs)\n\n  var nodes = new Array(seqs.length)\n  var missing = seqs.length\n  var error = null\n\n  if (!missing) return cb(null, nodes, seqs)\n  for (var i = 0; i < seqs.length; i++) this._getAndDecode(seqs[i], opts, get)\n\n  function get (err, node, seq) {\n    if (err) error = err\n    else nodes[seqs.indexOf(seq)] = node\n    if (--missing) return\n    if (error) cb(error)\n    else cb(null, nodes, seqs)\n  }\n}\n\nTree.prototype._onlyCached = function (seqs) {\n  var cachedSeqs = []\n\n  for (var i = 0; i < seqs.length; i++) {\n    if (this.feed.has(seqs[i])) cachedSeqs.push(seqs[i])\n  }\n\n  return cachedSeqs\n}\n\nTree.prototype._deflate = function (seq, index) {\n  var endsWithSeq = true\n  var lenIsh = 11\n  var i = 0\n  var idx\n\n  for (i = 0; i < index.length; i++) {\n    idx = index[i]\n\n    lenIsh += idx.length * 11 + 11\n    if (idx[idx.length - 1] !== seq) endsWithSeq = false\n  }\n\n  var header = 0\n  if (endsWithSeq) header |= 1\n\n  var buf = new Buffer(lenIsh)\n  var offset = 0\n\n  buf[offset++] = header\n\n  for (i = 0; i < index.length; i++) {\n    idx = index[i]\n\n    var prev = 0\n    var len = endsWithSeq ? idx.length - 1 : idx.length\n\n    varint.encode(len, buf, offset)\n    offset += varint.encode.bytes\n\n    for (var j = 0; j < len; j++) {\n      varint.encode(idx[j] - prev, buf, offset)\n      offset += varint.encode.bytes\n      prev = idx[j]\n    }\n  }\n\n  if (offset > buf.length) throw new Error('Assert error: buffer length too small')\n  return buf.slice(0, offset)\n}\n\nTree.prototype._inflate = function (seq, buf) {\n  var offset = 0\n\n  var header = varint.decode(buf, offset)\n  offset += varint.decode.bytes\n\n  var endsWithSeq = !!(header & 1)\n  var index = []\n\n  while (offset < buf.length) {\n    var len = varint.decode(buf, offset) // TODO: sanity check this length\n    offset += varint.decode.bytes\n\n    var seqs = new Array(endsWithSeq ? len + 1 : len)\n    var i = 0\n\n    for (; i < len; i++) {\n      if (offset >= buf.length) throw new Error('Invalid index')\n\n      seqs[i] = varint.decode(buf, offset) + (i ? seqs[i - 1] : 0)\n      offset += varint.decode.bytes\n    }\n\n    if (endsWithSeq) seqs[i] = seq\n    index.push(seqs)\n  }\n\n  return index\n}\n\nTree.prototype._defaultOpts = function (opts) {\n  if (!opts) return {wait: this._wait, cached: this._cached, node: this._asNode}\n  if (opts.wait === undefined) opts.wait = this._wait\n  if (opts.cached === undefined) opts.cached = this._cached\n  if (opts.node === undefined) opts.node = this._asNode\n  return opts\n}\n\nfunction join (names) {\n  return '/' + names.join('/')\n}\n\nfunction split (name) {\n  var list = name.split('/')\n  if (list[0] === '') list.shift()\n  if (list[list.length - 1] === '') list.pop()\n  return list\n}\n\nfunction notFound (names) {\n  var err = new Error(join(names) + ' could not be found')\n  err.notFound = true\n  err.status = 404\n  return err\n}\n\nfunction compare (a, b) {\n  var idx = 0\n  while (idx < a.length && a[idx] === b[idx]) idx++\n  return idx\n}\n\nfunction Node (node, seq) {\n  this.index = seq\n  this.name = node.name\n  this.value = node.value\n  this.paths = node.paths\n}\n\nfunction getCache (opts) {\n  if (opts.cache === false) return null\n  if (opts.cache === true || !opts.cache) {\n    var cacheSize = opts.cacheSize || 65536\n    return cache(cacheSize, {indexedValues: true})\n  }\n  return opts.cache\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","// This file is auto generated by the protocol-buffers cli tool\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require('protocol-buffers-encodings')\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar Node = exports.Node = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineNode()\n\nfunction defineNode () {\n  var enc = [\n    encodings.string,\n    encodings.bytes\n  ]\n\n  Node.encodingLength = encodingLength\n  Node.encode = encode\n  Node.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.name)) throw new Error(\"name is required\")\n    var len = enc[0].encodingLength(obj.name)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = enc[1].encodingLength(obj.value)\n      length += 1 + len\n    }\n    if (defined(obj.paths)) {\n      var len = enc[1].encodingLength(obj.paths)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.name)) throw new Error(\"name is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.name, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.value, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.paths)) {\n      buf[offset++] = 26\n      enc[1].encode(obj.paths, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      name: \"\",\n      value: null,\n      paths: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.name = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.value = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        obj.paths = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n","var once = require('once')\n\nmodule.exports = function(stream, cb) {\n  if (!cb) return stream\n\n  var list = []\n\n  cb = once(cb)\n\n  stream.on('data', function(data) {\n    list.push(data)\n  })\n\n  stream.on('end', function() {\n    cb(null, list)\n  })\n\n  stream.on('close', function() {\n    cb(new Error('Premature close'))\n  })\n\n  stream.on('error', cb)\n\n  return stream\n}","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var stream = require('readable-stream')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar shift = require('stream-shift')\n\nvar SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from([0])\n  : new Buffer([0])\n\nvar onuncork = function(self, fn) {\n  if (self._corked) self.once('uncork', fn)\n  else fn()\n}\n\nvar autoDestroy = function (self, err) {\n  if (self._autoDestroy) self.destroy(err)\n}\n\nvar destroyer = function(self, end) {\n  return function(err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)\n    else if (end && !self._ended) self.end()\n  }\n}\n\nvar end = function(ws, fn) {\n  if (!ws) return fn()\n  if (ws._writableState && ws._writableState.finished) return fn()\n  if (ws._writableState) return ws.end(fn)\n  ws.end()\n  fn()\n}\n\nvar toStreams2 = function(rs) {\n  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)\n}\n\nvar Duplexify = function(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)\n  stream.Duplex.call(this, opts)\n\n  this._writable = null\n  this._readable = null\n  this._readable2 = null\n\n  this._autoDestroy = !opts || opts.autoDestroy !== false\n  this._forwardDestroy = !opts || opts.destroy !== false\n  this._forwardEnd = !opts || opts.end !== false\n  this._corked = 1 // start corked\n  this._ondrain = null\n  this._drained = false\n  this._forwarding = false\n  this._unwrite = null\n  this._unread = null\n  this._ended = false\n\n  this.destroyed = false\n\n  if (writable) this.setWritable(writable)\n  if (readable) this.setReadable(readable)\n}\n\ninherits(Duplexify, stream.Duplex)\n\nDuplexify.obj = function(writable, readable, opts) {\n  if (!opts) opts = {}\n  opts.objectMode = true\n  opts.highWaterMark = 16\n  return new Duplexify(writable, readable, opts)\n}\n\nDuplexify.prototype.cork = function() {\n  if (++this._corked === 1) this.emit('cork')\n}\n\nDuplexify.prototype.uncork = function() {\n  if (this._corked && --this._corked === 0) this.emit('uncork')\n}\n\nDuplexify.prototype.setWritable = function(writable) {\n  if (this._unwrite) this._unwrite()\n\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy()\n    return\n  }\n\n  if (writable === null || writable === false) {\n    this.end()\n    return\n  }\n\n  var self = this\n  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))\n\n  var ondrain = function() {\n    var ondrain = self._ondrain\n    self._ondrain = null\n    if (ondrain) ondrain()\n  }\n\n  var clear = function() {\n    self._writable.removeListener('drain', ondrain)\n    unend()\n  }\n\n  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable\n  this._writable.on('drain', ondrain)\n  this._unwrite = clear\n\n  this.uncork() // always uncork setWritable\n}\n\nDuplexify.prototype.setReadable = function(readable) {\n  if (this._unread) this._unread()\n\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy()\n    return\n  }\n\n  if (readable === null || readable === false) {\n    this.push(null)\n    this.resume()\n    return\n  }\n\n  var self = this\n  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))\n\n  var onreadable = function() {\n    self._forward()\n  }\n\n  var onend = function() {\n    self.push(null)\n  }\n\n  var clear = function() {\n    self._readable2.removeListener('readable', onreadable)\n    self._readable2.removeListener('end', onend)\n    unend()\n  }\n\n  this._drained = true\n  this._readable = readable\n  this._readable2 = readable._readableState ? readable : toStreams2(readable)\n  this._readable2.on('readable', onreadable)\n  this._readable2.on('end', onend)\n  this._unread = clear\n\n  this._forward()\n}\n\nDuplexify.prototype._read = function() {\n  this._drained = true\n  this._forward()\n}\n\nDuplexify.prototype._forward = function() {\n  if (this._forwarding || !this._readable2 || !this._drained) return\n  this._forwarding = true\n\n  var data\n\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue\n    this._drained = this.push(data)\n  }\n\n  this._forwarding = false\n}\n\nDuplexify.prototype.destroy = function(err) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  var self = this\n  process.nextTick(function() {\n    self._destroy(err)\n  })\n}\n\nDuplexify.prototype._destroy = function(err) {\n  if (err) {\n    var ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain(err)\n    else this.emit('error', err)\n  }\n\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy()\n    if (this._writable && this._writable.destroy) this._writable.destroy()\n  }\n\n  this.emit('close')\n}\n\nDuplexify.prototype._write = function(data, enc, cb) {\n  if (this.destroyed) return cb()\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))\n  if (data === SIGNAL_FLUSH) return this._finish(cb)\n  if (!this._writable) return cb()\n\n  if (this._writable.write(data) === false) this._ondrain = cb\n  else cb()\n}\n\nDuplexify.prototype._finish = function(cb) {\n  var self = this\n  this.emit('preend')\n  onuncork(this, function() {\n    end(self._forwardEnd && self._writable, function() {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true\n      self.emit('prefinish')\n      onuncork(self, cb)\n    })\n  })\n}\n\nDuplexify.prototype.end = function(data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  this._ended = true\n  if (data) this.write(data)\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nmodule.exports = Duplexify\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tif (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","module.exports = shift\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return rs.objectMode ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    // Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    }\n\n    return state.buffer[0].length\n  }\n\n  return state.length\n}\n","var eos = require('end-of-stream')\nvar shift = require('stream-shift')\n\nmodule.exports = each\n\nfunction each (stream, fn, cb) {\n  var want = true\n  var error = null\n  var ended = false\n  var running = false\n  var calling = false\n\n  stream.on('readable', onreadable)\n  onreadable()\n\n  if (cb) eos(stream, {readable: true, writable: false}, done)\n  return stream\n\n  function done (err) {\n    if (!error) error = err\n    ended = true\n    if (!running) cb(error)\n  }\n\n  function onreadable () {\n    if (want) read()\n  }\n\n  function afterRead (err) {\n    running = false\n\n    if (err) {\n      error = err\n      if (ended) return cb(error)\n      stream.destroy(err)\n      return\n    }\n    if (ended) return cb(error)\n    if (!calling) read()\n  }\n\n  function read () {\n    while (!running && !ended) {\n      want = false\n\n      var data = shift(stream)\n      if (ended) return\n      if (data === null) {\n        want = true\n        return\n      }\n\n      running = true\n      calling = true\n      fn(data, afterRead)\n      calling = false\n    }\n  }\n}\n","/*!\n * unixify <https://github.com/jonschlinkert/unixify>\n *\n * Copyright (c) 2014, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar normalizePath = require('normalize-path');\n\nmodule.exports = function unixify(filepath, stripTrailing) {\n  filepath = normalizePath(filepath, stripTrailing);\n  return filepath.replace(/^([a-zA-Z]+:|\\.\\/)/, '');\n};\n","/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar removeTrailingSeparator = require('remove-trailing-separator');\n\nmodule.exports = function normalizePath(str, stripTrailing) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  str = str.replace(/[\\\\\\/]+/g, '/');\n  if (stripTrailing !== false) {\n    str = removeTrailingSeparator(str);\n  }\n  return str;\n};\n","var isWin = process.platform === 'win32';\n\nmodule.exports = function (str) {\n\tvar i = str.length - 1;\n\tif (i < 2) {\n\t\treturn str;\n\t}\n\twhile (isSeparator(str, i)) {\n\t\ti--;\n\t}\n\treturn str.substr(0, i + 1);\n};\n\nfunction isSeparator(str, i) {\n\tvar char = str[i];\n\treturn i > 0 && (char === '/' || (isWin && char === '\\\\'));\n}\n","// This file is auto generated by the protocol-buffers cli tool\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require('protocol-buffers-encodings')\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar Index = exports.Index = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Stat = exports.Stat = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineIndex()\ndefineStat()\n\nfunction defineIndex () {\n  var enc = [\n    encodings.string,\n    encodings.bytes\n  ]\n\n  Index.encodingLength = encodingLength\n  Index.encode = encode\n  Index.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.type)) throw new Error(\"type is required\")\n    var len = enc[0].encodingLength(obj.type)\n    length += 1 + len\n    if (defined(obj.content)) {\n      var len = enc[1].encodingLength(obj.content)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.type)) throw new Error(\"type is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.type, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.content)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.content, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      type: \"\",\n      content: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.type = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.content = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineStat () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Stat.encodingLength = encodingLength\n  Stat.encode = encode\n  Stat.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.mode)) throw new Error(\"mode is required\")\n    var len = enc[0].encodingLength(obj.mode)\n    length += 1 + len\n    if (defined(obj.uid)) {\n      var len = enc[0].encodingLength(obj.uid)\n      length += 1 + len\n    }\n    if (defined(obj.gid)) {\n      var len = enc[0].encodingLength(obj.gid)\n      length += 1 + len\n    }\n    if (defined(obj.size)) {\n      var len = enc[0].encodingLength(obj.size)\n      length += 1 + len\n    }\n    if (defined(obj.blocks)) {\n      var len = enc[0].encodingLength(obj.blocks)\n      length += 1 + len\n    }\n    if (defined(obj.offset)) {\n      var len = enc[0].encodingLength(obj.offset)\n      length += 1 + len\n    }\n    if (defined(obj.byteOffset)) {\n      var len = enc[0].encodingLength(obj.byteOffset)\n      length += 1 + len\n    }\n    if (defined(obj.mtime)) {\n      var len = enc[0].encodingLength(obj.mtime)\n      length += 1 + len\n    }\n    if (defined(obj.ctime)) {\n      var len = enc[0].encodingLength(obj.ctime)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.mode)) throw new Error(\"mode is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.mode, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.uid)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.uid, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.gid)) {\n      buf[offset++] = 24\n      enc[0].encode(obj.gid, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.size)) {\n      buf[offset++] = 32\n      enc[0].encode(obj.size, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.blocks)) {\n      buf[offset++] = 40\n      enc[0].encode(obj.blocks, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.offset)) {\n      buf[offset++] = 48\n      enc[0].encode(obj.offset, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.byteOffset)) {\n      buf[offset++] = 56\n      enc[0].encode(obj.byteOffset, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.mtime)) {\n      buf[offset++] = 64\n      enc[0].encode(obj.mtime, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.ctime)) {\n      buf[offset++] = 72\n      enc[0].encode(obj.ctime, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      mode: 0,\n      uid: 0,\n      gid: 0,\n      size: 0,\n      blocks: 0,\n      offset: 0,\n      byteOffset: 0,\n      mtime: 0,\n      ctime: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.mode = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.uid = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.gid = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 4:\n        obj.size = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 5:\n        obj.blocks = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 6:\n        obj.offset = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 7:\n        obj.byteOffset = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 8:\n        obj.mtime = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 9:\n        obj.ctime = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n","// http://man7.org/linux/man-pages/man2/stat.2.html\n\nmodule.exports = Stat\n\nfunction Stat (data) {\n  if (!(this instanceof Stat)) return new Stat(data)\n\n  this.dev = 0\n  this.nlink = 1\n  this.rdev = 0\n  this.blksize = 0\n  this.ino = 0\n\n  this.mode = data ? data.mode : 0\n  this.uid = data ? data.uid : 0\n  this.gid = data ? data.gid : 0\n  this.size = data ? data.size : 0\n  this.offset = data ? data.offset : 0\n  this.byteOffset = data ? data.byteOffset : 0\n  this.blocks = data ? data.blocks : 0\n  this.atime = new Date(data ? data.mtime : 0) // we just set this to mtime ...\n  this.mtime = new Date(data ? data.mtime : 0)\n  this.ctime = new Date(data ? data.ctime : 0)\n\n  this.linkname = data ? data.linkname : null\n}\n\nStat.IFSOCK = 49152 // 0b1100...\nStat.IFLNK = 40960 // 0b1010...\nStat.IFREG = 32768 // 0b1000...\nStat.IFBLK = 24576 // 0b0110...\nStat.IFDIR = 16384 // 0b0100...\nStat.IFCHR = 8192 // 0b0010...\nStat.IFIFO = 4096 // 0b0001...\n\nStat.prototype.isSocket = check(Stat.IFSOCK)\nStat.prototype.isSymbolicLink = check(Stat.IFLNK)\nStat.prototype.isFile = check(Stat.IFREG)\nStat.prototype.isBlockDevice = check(Stat.IFBLK)\nStat.prototype.isDirectory = check(Stat.IFDIR)\nStat.prototype.isCharacterDevice = check(Stat.IFCHR)\nStat.prototype.isFIFO = check(Stat.IFIFO)\n\nfunction check (mask) {\n  return function () {\n    return (mask & this.mode) === mask\n  }\n}\n","var thunky = require('thunky')\n\nmodule.exports = Cursor\n\nfunction Cursor (archive, name, opts) {\n  if (!(this instanceof Cursor)) return new Cursor(archive, name, opts)\n\n  var self = this\n\n  this.name = name\n  this.opened = false\n  this.position = 0\n  this.index = 0\n  this.offset = 0\n  this.open = thunky(open)\n\n  this._content = null\n  this._stat = null\n  this._seekTo = 0\n  this._seeking = true\n  this._start = 0\n  this._end = 0\n  this._range = null\n  this._download = !opts || opts.download !== false\n\n  this.open()\n\n  function open (cb) {\n    archive.stat(name, function (err, st) {\n      if (err) return cb(err)\n      archive._ensureContent(function (err) {\n        if (err) return cb(err)\n        if (!st.isFile()) return cb(new Error('Not a file'))\n\n        self._content = archive.content\n        self._stat = st\n        self._start = st.offset\n        self._end = st.offset + st.blocks\n\n        if (self._seekTo === 0 && self._download) {\n          self._range = self._content.download({start: self._start, end: self._end, linear: true})\n        }\n\n        cb(null)\n      })\n    })\n  }\n}\n\nCursor.prototype.seek = function (pos) {\n  if (pos === this.position && this._seekTo === -1) return this\n  this._seeking = true\n  this._seekTo = pos\n  return this\n}\n\nCursor.prototype._seek = function (bytes, cb) {\n  var self = this\n\n  this.open(function (err) {\n    if (err) return cb(err)\n\n    if (bytes < 0) bytes += self._stat.size\n    if (bytes < 0) bytes = 0\n    if (bytes > self._stat.size) bytes = self._stat.size\n\n    var st = self._stat\n    var opts = {start: self._start, end: self._end}\n\n    if (bytes === 0) return onseek(null, self._start, 0)\n    if (bytes === self._stat.size) return onseek(self._end, 0)\n\n    self._content.seek(st.byteOffset + bytes, opts, onseek)\n  })\n\n  function onseek (err, index, offset) {\n    if (err) return cb(err)\n    cb(null, bytes, index, offset)\n  }\n}\n\nCursor.prototype.next = function (cb) {\n  if (this._seeking) this._seekAndNext(cb)\n  else this._next(this.position, this.index, this.offset, cb)\n}\n\nCursor.prototype.close = function (cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  this.open(function (err) {\n    if (err) return cb(err)\n    if (self._range) self._content.undownload(self._range)\n    cb()\n  })\n}\n\nCursor.prototype._next = function (pos, index, offset, cb) {\n  if (index < this._start || index >= this._end) return cb(null, null)\n\n  var self = this\n\n  this._content.get(this.index, function (err, data) {\n    if (err) return cb(err)\n\n    if (offset) {\n      data = data.slice(offset)\n    }\n\n    self.position = pos + data.length\n    self.offset = 0\n    self.index++\n\n    cb(null, data)\n  })\n}\n\nCursor.prototype._seekAndNext = function (cb) {\n  var self = this\n  var seekTo = this._seekTo\n\n  this._seek(seekTo, function (err, pos, index, offset) {\n    if (err) return cb(err)\n\n    if (seekTo === self._seekTo) {\n      self._seeking = false\n      self._seekTo = -1\n      self.position = pos\n      self.index = index\n      self.offset = offset\n\n      if (self._download) {\n        if (self._range) self._content.undownload(self._range)\n        self._range = self._content.download({start: self.index, end: self._end, linear: true})\n      }\n    }\n\n    self._next(pos, index, offset, cb)\n  })\n}\n\nfunction noop () {}\n","var assert = require('assert')\nvar stringKey = require('dat-encoding').toStr\nvar get = require('simple-get')\nvar datDns = require('dat-dns')()\nvar debug = require('debug')('dat-link-resolve')\n\nmodule.exports = resolve\n\nfunction resolve (link, cb) {\n  assert.ok(link, 'dat-link-resolve: link required')\n  assert.strictEqual(typeof cb, 'function', 'dat-link-resolve: callback required')\n\n  var key = null\n\n  try {\n    // validates + removes dat://\n    // also works for http urls with keys in them\n    key = stringKey(link)\n  } catch (e) {\n    lookup()\n    return\n  }\n  cb(null, key)\n\n  function lookup () {\n    // if it starts with http or dat: use as is, otherwise prepend http://\n    var urlLink = (link.indexOf('http') && link.indexOf('dat:')) ? ('http://' + link) : link\n\n    function resolveName () {\n      datDns.resolveName(urlLink, function (err, key) {\n        debug('resolveName', urlLink, err, key)\n        if (key) return cb(null, key)\n        if (err) debug('datDns.resolveName() error')\n        cb(err)\n      })\n    }\n\n    debug('resolveKey', link, urlLink)\n    get({\n      url: urlLink.replace('dat://', 'http://'),\n      json: true,\n      timeout: 1500\n    }, function (err, resp, body) {\n      // no ressource at given URL\n      if (err || resp.statusCode !== 200) {\n        return resolveName()\n      }\n\n      // first check if key is in header response\n      key = resp.headers['hyperdrive-key'] || resp.headers['dat-key']\n      if (key) {\n        debug('Received key from http header:', key)\n        return cb(null, key)\n      }\n\n      // else fall back to parsing the body\n      try {\n        key = stringKey(body.url)\n        debug('Received key via json:', key, typeof body, body && typeof body.url)\n        if (key) return cb(null, key)\n      } catch (e) {\n        // fall back to datDns\n        resolveName()\n      }\n    })\n  }\n}\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\n\nfunction encode (buf) {\n  if (typeof buf === 'string') return encode(decode(buf))\n  if (!Buffer.isBuffer(buf)) throw new Error('Not a buffer')\n  if (buf.length !== 32) throw new Error('Invalid buffer')\n  return buf.toString('hex')\n}\n\nfunction decode (str) {\n  if (Buffer.isBuffer(str)) return decode(encode(str))\n  if (typeof str !== 'string') throw new Error('Not a string')\n  // looking for an hexa string of 64 or 65 consecutive chars\n  var match = /([a-f0-9]{64,65})/i.exec(str)\n  // we need exactly 64, so an hexa string with 65 chars (or more) is not allowed\n  if (!match || match[1].length !== 64) throw new Error('Invalid key')\n  return Buffer.from(match[1], 'hex')\n}\n\nexports.encode = exports.toStr = encode\nexports.decode = exports.toBuf = decode\n","module.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url)\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = {url: opts}\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n","module.exports = function (stream, cb) {\n  var chunks = []\n  stream.on('data', function (chunk) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n","'use strict';\nconst PassThrough = require('stream').PassThrough;\nconst zlib = require('zlib');\nconst mimicResponse = require('mimic-response');\n\nmodule.exports = response => {\n\t// TODO: Use Array#includes when targeting Node.js 6\n\tif (['gzip', 'deflate'].indexOf(response.headers['content-encoding']) === -1) {\n\t\treturn response;\n\t}\n\n\tconst unzip = zlib.createUnzip();\n\tconst stream = new PassThrough();\n\n\tmimicResponse(response, stream);\n\n\tunzip.on('error', err => {\n\t\tif (err.code === 'Z_BUF_ERROR') {\n\t\t\tstream.end();\n\t\t\treturn;\n\t\t}\n\n\t\tstream.emit('error', err);\n\t});\n\n\tresponse.pipe(unzip).pipe(stream);\n\n\treturn stream;\n};\n","module.exports = require(\"zlib\");","'use strict';\n\n// We define these manually to ensure they're always copied\n// even if they would move up the prototype chain\n// https://nodejs.org/api/http.html#http_class_http_incomingmessage\nconst knownProps = [\n\t'destroy',\n\t'setTimeout',\n\t'socket',\n\t'headers',\n\t'trailers',\n\t'rawHeaders',\n\t'statusCode',\n\t'httpVersion',\n\t'httpVersionMinor',\n\t'httpVersionMajor',\n\t'rawTrailers',\n\t'statusMessage'\n];\n\nmodule.exports = (fromStream, toStream) => {\n\tconst fromProps = new Set(Object.keys(fromStream).concat(knownProps));\n\n\tfor (const prop of fromProps) {\n\t\t// Don't overwrite existing properties\n\t\tif (prop in toStream) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttoStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];\n\t}\n};\n","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"querystring\");","module.exports = require(\"url\");","const debug = require('debug')('dat')\nconst url = require('url')\nconst https = require('https')\nconst {stringify} = require('querystring')\nconst memoryCache = require('./cache')\nconst callMeMaybe = require('call-me-maybe')\nconst concat = require('concat-stream')\n\nconst DAT_HASH_REGEX = /^[0-9a-f]{64}?$/i\nconst VERSION_REGEX = /(\\+[^\\/]+)$/\nconst DEFAULT_DAT_DNS_TTL = 3600 // 1hr\nconst MAX_DAT_DNS_TTL = 3600 * 24 * 7 // 1 week\nconst DEFAULT_DNS_HOST = 'dns.google.com'\nconst DEFAULT_DNS_PATH = '/resolve'\n\n// helper to support node6\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n// helper to call promise-generating function\nfunction maybe (cb, p) {\n  if (typeof p === 'function') {\n    p = p()\n  }\n  return callMeMaybe(cb, p)\n}\n\nmodule.exports = function (datDnsOpts) {\n  datDnsOpts = datDnsOpts || {}\n  var pCache = datDnsOpts.persistentCache\n  var mCache = memoryCache()\n  var dnsHost = datDnsOpts.dnsHost || DEFAULT_DNS_HOST\n  var dnsPath = datDnsOpts.dnsPath || DEFAULT_DNS_PATH\n\n  function resolveName (name, opts, cb) {\n    if (typeof opts === 'function') {\n      cb = opts\n      opts = null\n    }\n    var ignoreCache = opts && opts.ignoreCache\n    var ignoreCachedMiss = opts && opts.ignoreCachedMiss\n    var noDnsOverHttps = opts && opts.noDnsOverHttps\n    var noWellknownDat = opts && opts.noWellknownDat\n    return maybe(cb, _asyncToGenerator(function* () {\n      // parse the name as needed\n      var nameParsed = url.parse(name)\n      name = nameParsed.hostname || nameParsed.pathname\n\n      // strip the version\n      name = name.replace(VERSION_REGEX, '')\n\n      // is it a hash?\n      if (DAT_HASH_REGEX.test(name)) {\n        return name.slice(0, 64)\n      }\n\n      try {\n        // check the cache\n        if (!ignoreCache) {\n          const cachedKey = mCache.get(name)\n          if (typeof cachedKey !== 'undefined') {\n            if (cachedKey || (!cachedKey && !ignoreCachedMiss)) {\n              debug('In-memory cache hit for name', name, cachedKey)\n              if (cachedKey) return cachedKey\n              else throw new Error('DNS record not found') // cached miss\n            }\n          }\n        }\n\n        var res\n        var key\n        var ttl\n\n        if (!noDnsOverHttps) {\n          try {\n            // do a DNS-over-HTTPS lookup\n            res = yield fetchDnsOverHttpsRecord(name, {host: dnsHost, path: dnsPath})\n\n            // parse the record\n            res = parseDnsOverHttpsRecord(name, res.body)\n            debug('dns-over-http resolved', name, 'to', res.key)\n          } catch (e) {\n            // ignore, we'll try .well-known/dat next\n            res = false\n          }\n        }\n\n        if (!res && !noWellknownDat) {\n          // do a .well-known/dat lookup\n          res = yield fetchWellKnownRecord(name)\n          if (res.statusCode === 0 || res.statusCode === 404) {\n            debug('.well-known/dat lookup failed for name:', name, res.statusCode, res.err)\n            mCache.set(name, false, 60) // cache the miss for a minute\n            throw new Error('DNS record not found')\n          } else if (res.statusCode !== 200) {\n            debug('.well-known/dat lookup failed for name:', name, res.statusCode)\n            throw new Error('DNS record not found')\n          }\n\n          // parse the record\n          res = parseWellknownDatRecord(name, res.body)\n          debug('.well-known/dat resolved', name, 'to', res.key)\n        }\n\n        // cache\n        if (res.ttl !== 0) mCache.set(name, res.key, res.ttl)\n        if (pCache) pCache.write(name, res.key, res.ttl)\n\n        return res.key\n      } catch (err) {\n        if (pCache) {\n          // read from persistent cache on failure\n          return pCache.read(name, err)\n        }\n        throw err\n      }\n    }))\n  }\n\n  function listCache () {\n    return mCache.list()\n  }\n\n  function flushCache () {\n    mCache.flush()\n  }\n\n  return {\n    resolveName: resolveName,\n    listCache: listCache,\n    flushCache: flushCache\n  }\n}\n\nfunction fetchDnsOverHttpsRecord (name, {host, path}) {\n  return new Promise((resolve, reject) => {\n    var query = {\n      name,\n      type: 'TXT'\n    }\n    debug('dns-over-https lookup for name:', name)\n    https.get({\n      host,\n      path: `${path}?${stringify(query)}`,\n      timeout: 2000\n    }, function (res) {\n      res.setEncoding('utf-8')\n      res.pipe(concat(body => resolve({statusCode: res.statusCode, body})))\n    }).on('error', function (err) {\n      resolve({statusCode: 0, err, body: ''})\n    })\n  })\n}\n\nfunction parseDnsOverHttpsRecord (name, body) {\n  // decode to obj\n  var record\n  try {\n    record = JSON.parse(body)\n  } catch (e) {\n    debug('dns-over-https failed', name, 'did not give a valid JSON response')\n    throw new Error('Invalid dns-over-https record, must provide json')\n  }\n\n  // find valid answers\n  var answers = record['Answer']\n  if (!answers || !Array.isArray(answers)) {\n    debug('dns-over-https failed', name, 'did not give any TXT answers')\n    throw new Error('Invalid dns-over-https record, no TXT answers given')\n  }\n  answers = answers.filter(a => {\n    if (!a || typeof a !== 'object') {\n      return false\n    }\n    if (typeof a.data !== 'string') {\n      return false\n    }\n    var match = /^\"?datkey=([0-9a-f]{64})\"?$/i.exec(a.data)\n    if (!match) {\n      return false\n    }\n    a.key = match[1]\n    return true\n  })\n  if (!answers[0]) {\n    debug('dns-over-https failed', name, 'did not give any TXT datkey answers')\n    throw new Error('Invalid dns-over-https record, no TXT datkey answer given')\n  }\n\n  // put together res\n  var res = {key: answers[0].key, ttl: answers[0].TTL}\n  if (!Number.isSafeInteger(res.ttl) || res.ttl < 0) {\n    res.ttl = DEFAULT_DAT_DNS_TTL\n  }\n  if (res.ttl > MAX_DAT_DNS_TTL) {\n    res.ttl = MAX_DAT_DNS_TTL\n  }\n  return res\n}\n\nfunction fetchWellKnownRecord (name) {\n  return new Promise((resolve, reject) => {\n    debug('.well-known/dat lookup for name:', name)\n    https.get({\n      host: name,\n      path: '/.well-known/dat',\n      timeout: 2000\n    }, function (res) {\n      res.setEncoding('utf-8')\n      res.pipe(concat(body => resolve({statusCode: res.statusCode, body})))\n    }).on('error', function (err) {\n      resolve({statusCode: 0, err, body: ''})\n    })\n  })\n}\n\nfunction parseWellknownDatRecord (name, body) {\n  if (!body || typeof body != 'string') {\n    throw new Error('DNS record not found')\n  }\n\n  const lines = body.split('\\n')\n  var key, ttl\n\n  // parse url\n  try {\n    key = /^dat:\\/\\/([0-9a-f]{64})/i.exec(lines[0])[1]\n  } catch (e) {\n    debug('.well-known/dat failed', name, 'Must be a dat://{key} url')\n    throw new Error('Invalid .well-known/dat record, must provide a dat://{key} url')\n  }\n\n  // parse ttl\n  try {\n    if (lines[1]) {\n      ttl = +(/^ttl=(\\d+)$/i.exec(lines[1])[1])\n    }\n  } catch (e) {\n    debug('.well-known/dat failed to parse TTL for %s, line: %s, error:', name, lines[1], e)\n  }\n  if (!Number.isSafeInteger(ttl) || ttl < 0) {\n    ttl = DEFAULT_DAT_DNS_TTL\n  }\n  if (ttl > MAX_DAT_DNS_TTL) {\n    ttl = MAX_DAT_DNS_TTL\n  }\n\n  return {key, ttl}\n}","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","module.exports = require(\"tty\");","module.exports = require(\"net\");","// taken from https://github.com/tiborv/memory-cache-ttl\n\n'use strict';\n\nmodule.exports = function () {\n\n  var options = {};\n  var cache = {};\n  var ttlQueue = [];\n  var ttlExtend = new Set();\n\n  var genExpire = function genExpire(seconds) {\n    var t = new Date();\n    t.setSeconds(t.getSeconds() + seconds);\n    return t;\n  };\n\n  var binarySearch = function binarySearch(value) {\n    var low = 0;\n    var high = ttlQueue.length;\n\n    while (low < high) {\n      var mid = low + high >>> 1; // eslint-disable-line no-bitwise\n      if (ttlQueue[mid].expires.getTime() < value) low = mid + 1;else high = mid;\n    }\n    return low;\n  };\n\n  var addToTTLQueue = function addToTTLQueue(ttl) {\n    ttlQueue = ttlQueue.filter(function (e) {\n      return e.id !== ttl.id;\n    });\n    ttlQueue.splice(binarySearch(ttl.expires.getTime()), 0, ttl);\n  };\n\n  var cleanExpired = function cleanExpired() {\n    if (ttlQueue.length === 0) return;\n    var now = new Date().getTime();\n    if (ttlQueue[0].expires.getTime() > now) return;\n    var expiredIndex = binarySearch(now);\n    ttlQueue.slice(0, expiredIndex).map(function (ttl) {\n      return delete cache[ttl.id];\n    });\n    ttlQueue = ttlQueue.slice(expiredIndex, ttlQueue.length);\n  };\n\n  var set = function set(id, value, ttl) {\n    if (!ttl && !options.ttl) throw new Error('Global or local TTL needs to be set');\n    cache[id] = value;\n    if (ttl) return addToTTLQueue({ id: id, expires: genExpire(ttl) });\n    addToTTLQueue({\n      id: id,\n      expires: options.randomize ? genExpire(Math.ceil(Math.random() * options.ttl)) : genExpire(options.ttl)\n    });\n  };\n\n  var check = function check(id) {\n    return id in cache;\n  };\n\n  var get = function get(id) {\n    if (options.extendOnHit) ttlExtend.add(id);\n    return cache[id];\n  };\n\n  var del = function del(id) {\n    delete cache[id];\n    ttlQueue = ttlQueue.filter(function (t) {\n      return t.id !== id;\n    });\n  };\n\n  var list = function list() {\n    return cache;\n  };\n\n  var flush = function flush() {\n    cache = {};\n    ttlQueue = [];\n  };\n\n  var onInterval = function onInterval() {\n    if (ttlQueue.length === 0) return;\n    ttlQueue.forEach(function (ttl) {\n      options.onInterval(ttl.id).then(function () {\n        var newValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : cache[ttl.id];\n\n        cache[ttl.id] = newValue;\n      });\n    });\n  };\n\n  var extendOnHit = function extendOnHit() {\n    if (ttlExtend.size === 0) return;\n    ttlExtend.forEach(function (id) {\n      return set(id, cache[id]);\n    });\n    ttlExtend = new Set();\n  };\n\n  var runningProcess = void 0;\n  var runTasks = function runTasks() {\n    if (runningProcess) clearInterval(runningProcess);\n    runningProcess = setInterval(function () {\n      if (options.extendOnHit) extendOnHit();\n      cleanExpired();\n      if (options.onInterval) onInterval();\n    }, options.interval * 1000);\n  };\n\n  var init = function init() {\n    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { interval: 1 };\n\n    options = o;\n    if (o.onInterval && typeof o.onInterval !== 'function') {\n      throw new Error('onInterval needs to be a Promise/function');\n    }\n    runTasks();\n  };\n\n  return {\n    init: init,\n    set: set,\n    get: get,\n    check: check,\n    del: del,\n    list: list,\n    flush: flush,\n    __ttlQueue: function __ttlQueue() {\n      return ttlQueue;\n    },\n    stats: function stats() {\n      return {\n        cacheEntries: Object.keys(cache).length,\n        ttlQueueEntries: ttlQueue.length,\n        ttlExtendEntries: ttlExtend.size\n      };\n    }\n  };\n}","\"use strict\"\n\nvar next = (global.process && process.nextTick) || global.setImmediate || function (f) {\n  setTimeout(f, 0)\n}\n\nmodule.exports = function maybe (cb, promise) {\n  if (cb) {\n    promise\n      .then(function (result) {\n        next(function () { cb(null, result) })\n      }, function (err) {\n        next(function () { cb(err) })\n      })\n    return undefined\n  }\n  else {\n    return promise\n  }\n}\n","var Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar bufferFrom = require('buffer-from')\n\nif (typeof Uint8Array === 'undefined') {\n  var U8 = require('typedarray').Uint8Array\n} else {\n  var U8 = Uint8Array\n}\n\nfunction ConcatStream(opts, cb) {\n  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!opts) opts = {}\n\n  var encoding = opts.encoding\n  var shouldInferEncoding = false\n\n  if (!encoding) {\n    shouldInferEncoding = true\n  } else {\n    encoding =  String(encoding).toLowerCase()\n    if (encoding === 'u8' || encoding === 'uint8') {\n      encoding = 'uint8array'\n    }\n  }\n\n  Writable.call(this, { objectMode: true })\n\n  this.encoding = encoding\n  this.shouldInferEncoding = shouldInferEncoding\n\n  if (cb) this.on('finish', function () { cb(this.getBody()) })\n  this.body = []\n}\n\nmodule.exports = ConcatStream\ninherits(ConcatStream, Writable)\n\nConcatStream.prototype._write = function(chunk, enc, next) {\n  this.body.push(chunk)\n  next()\n}\n\nConcatStream.prototype.inferEncoding = function (buff) {\n  var firstBuffer = buff === undefined ? this.body[0] : buff;\n  if (Buffer.isBuffer(firstBuffer)) return 'buffer'\n  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'\n  if (Array.isArray(firstBuffer)) return 'array'\n  if (typeof firstBuffer === 'string') return 'string'\n  if (Object.prototype.toString.call(firstBuffer) === \"[object Object]\") return 'object'\n  return 'buffer'\n}\n\nConcatStream.prototype.getBody = function () {\n  if (!this.encoding && this.body.length === 0) return []\n  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()\n  if (this.encoding === 'array') return arrayConcat(this.body)\n  if (this.encoding === 'string') return stringConcat(this.body)\n  if (this.encoding === 'buffer') return bufferConcat(this.body)\n  if (this.encoding === 'uint8array') return u8Concat(this.body)\n  return this.body\n}\n\nvar isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]'\n}\n\nfunction isArrayish (arr) {\n  return /Array\\]$/.test(Object.prototype.toString.call(arr))\n}\n\nfunction isBufferish (p) {\n  return typeof p === 'string' || isArrayish(p) || (p && typeof p.subarray === 'function')\n}\n\nfunction stringConcat (parts) {\n  var strings = []\n  var needsToString = false\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]\n    if (typeof p === 'string') {\n      strings.push(p)\n    } else if (Buffer.isBuffer(p)) {\n      strings.push(p)\n    } else if (isBufferish(p)) {\n      strings.push(bufferFrom(p))\n    } else {\n      strings.push(bufferFrom(String(p)))\n    }\n  }\n  if (Buffer.isBuffer(parts[0])) {\n    strings = Buffer.concat(strings)\n    strings = strings.toString('utf8')\n  } else {\n    strings = strings.join('')\n  }\n  return strings\n}\n\nfunction bufferConcat (parts) {\n  var bufs = []\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]\n    if (Buffer.isBuffer(p)) {\n      bufs.push(p)\n    } else if (isBufferish(p)) {\n      bufs.push(bufferFrom(p))\n    } else {\n      bufs.push(bufferFrom(String(p)))\n    }\n  }\n  return Buffer.concat(bufs)\n}\n\nfunction arrayConcat (parts) {\n  var res = []\n  for (var i = 0; i < parts.length; i++) {\n    res.push.apply(res, parts[i])\n  }\n  return res\n}\n\nfunction u8Concat (parts) {\n  var len = 0\n  for (var i = 0; i < parts.length; i++) {\n    if (typeof parts[i] === 'string') {\n      parts[i] = bufferFrom(parts[i])\n    }\n    len += parts[i].length\n  }\n  var u8 = new U8(len)\n  for (var i = 0, offset = 0; i < parts.length; i++) {\n    var part = parts[i]\n    for (var j = 0; j < part.length; j++) {\n      u8[offset++] = part[j]\n    }\n  }\n  return u8\n}\n","var undefined = (void 0); // Paranoia\n\n// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n// create, and consume so much memory, that the browser appears frozen.\nvar MAX_ARRAY_LENGTH = 1e5;\n\n// Approximations of internal ECMAScript conversion functions\nvar ECMAScript = (function() {\n  // Stash a copy in case other scripts modify these\n  var opts = Object.prototype.toString,\n      ophop = Object.prototype.hasOwnProperty;\n\n  return {\n    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n    Class: function(v) { return opts.call(v).replace(/^\\[object *|\\]$/g, ''); },\n    HasProperty: function(o, p) { return p in o; },\n    HasOwnProperty: function(o, p) { return ophop.call(o, p); },\n    IsCallable: function(o) { return typeof o === 'function'; },\n    ToInt32: function(v) { return v >> 0; },\n    ToUint32: function(v) { return v >>> 0; }\n  };\n}());\n\n// Snapshot intrinsics\nvar LN2 = Math.LN2,\n    abs = Math.abs,\n    floor = Math.floor,\n    log = Math.log,\n    min = Math.min,\n    pow = Math.pow,\n    round = Math.round;\n\n// ES5: lock down object properties\nfunction configureProperties(obj) {\n  if (getOwnPropNames && defineProp) {\n    var props = getOwnPropNames(obj), i;\n    for (i = 0; i < props.length; i += 1) {\n      defineProp(obj, props[i], {\n        value: obj[props[i]],\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n}\n\n// emulate ES5 getter/setter API using legacy APIs\n// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\nvar defineProp\nif (Object.defineProperty && (function() {\n      try {\n        Object.defineProperty({}, 'x', {});\n        return true;\n      } catch (e) {\n        return false;\n      }\n    })()) {\n  defineProp = Object.defineProperty;\n} else {\n  defineProp = function(o, p, desc) {\n    if (!o === Object(o)) throw new TypeError(\"Object.defineProperty called on non-object\");\n    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }\n    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }\n    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }\n    return o;\n  };\n}\n\nvar getOwnPropNames = Object.getOwnPropertyNames || function (o) {\n  if (o !== Object(o)) throw new TypeError(\"Object.getOwnPropertyNames called on non-object\");\n  var props = [], p;\n  for (p in o) {\n    if (ECMAScript.HasOwnProperty(o, p)) {\n      props.push(p);\n    }\n  }\n  return props;\n};\n\n// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n// for index in 0 ... obj.length\nfunction makeArrayAccessors(obj) {\n  if (!defineProp) { return; }\n\n  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError(\"Array too large for polyfill\");\n\n  function makeArrayAccessor(index) {\n    defineProp(obj, index, {\n      'get': function() { return obj._getter(index); },\n      'set': function(v) { obj._setter(index, v); },\n      enumerable: true,\n      configurable: false\n    });\n  }\n\n  var i;\n  for (i = 0; i < obj.length; i += 1) {\n    makeArrayAccessor(i);\n  }\n}\n\n// Internal conversion functions:\n//    pack<Type>()   - take a number (interpreted as Type), output a byte array\n//    unpack<Type>() - take a byte array, output a Type-like number\n\nfunction as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\nfunction as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n\nfunction packI8(n) { return [n & 0xff]; }\nfunction unpackI8(bytes) { return as_signed(bytes[0], 8); }\n\nfunction packU8(n) { return [n & 0xff]; }\nfunction unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n\nfunction packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n\nfunction packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packIEEE754(v, ebits, fbits) {\n\n  var bias = (1 << (ebits - 1)) - 1,\n      s, e, f, ln,\n      i, bits, str, bytes;\n\n  function roundToEven(n) {\n    var w = floor(n), f = n - w;\n    if (f < 0.5)\n      return w;\n    if (f > 0.5)\n      return w + 1;\n    return w % 2 ? w + 1 : w;\n  }\n\n  // Compute sign, exponent, fraction\n  if (v !== v) {\n    // NaN\n    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n  } else if (v === Infinity || v === -Infinity) {\n    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n  } else if (v === 0) {\n    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n  } else {\n    s = v < 0;\n    v = abs(v);\n\n    if (v >= pow(2, 1 - bias)) {\n      e = min(floor(log(v) / LN2), 1023);\n      f = roundToEven(v / pow(2, e) * pow(2, fbits));\n      if (f / pow(2, fbits) >= 2) {\n        e = e + 1;\n        f = 1;\n      }\n      if (e > bias) {\n        // Overflow\n        e = (1 << ebits) - 1;\n        f = 0;\n      } else {\n        // Normalized\n        e = e + bias;\n        f = f - pow(2, fbits);\n      }\n    } else {\n      // Denormalized\n      e = 0;\n      f = roundToEven(v / pow(2, 1 - bias - fbits));\n    }\n  }\n\n  // Pack sign, exponent, fraction\n  bits = [];\n  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n  bits.push(s ? 1 : 0);\n  bits.reverse();\n  str = bits.join('');\n\n  // Bits to bytes\n  bytes = [];\n  while (str.length) {\n    bytes.push(parseInt(str.substring(0, 8), 2));\n    str = str.substring(8);\n  }\n  return bytes;\n}\n\nfunction unpackIEEE754(bytes, ebits, fbits) {\n\n  // Bytes to bits\n  var bits = [], i, j, b, str,\n      bias, s, e, f;\n\n  for (i = bytes.length; i; i -= 1) {\n    b = bytes[i - 1];\n    for (j = 8; j; j -= 1) {\n      bits.push(b % 2 ? 1 : 0); b = b >> 1;\n    }\n  }\n  bits.reverse();\n  str = bits.join('');\n\n  // Unpack sign, exponent, fraction\n  bias = (1 << (ebits - 1)) - 1;\n  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n  e = parseInt(str.substring(1, 1 + ebits), 2);\n  f = parseInt(str.substring(1 + ebits), 2);\n\n  // Produce number\n  if (e === (1 << ebits) - 1) {\n    return f !== 0 ? NaN : s * Infinity;\n  } else if (e > 0) {\n    // Normalized\n    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n  } else if (f !== 0) {\n    // Denormalized\n    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n  } else {\n    return s < 0 ? -0 : 0;\n  }\n}\n\nfunction unpackF64(b) { return unpackIEEE754(b, 11, 52); }\nfunction packF64(v) { return packIEEE754(v, 11, 52); }\nfunction unpackF32(b) { return unpackIEEE754(b, 8, 23); }\nfunction packF32(v) { return packIEEE754(v, 8, 23); }\n\n\n//\n// 3 The ArrayBuffer Type\n//\n\n(function() {\n\n  /** @constructor */\n  var ArrayBuffer = function ArrayBuffer(length) {\n    length = ECMAScript.ToInt32(length);\n    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');\n\n    this.byteLength = length;\n    this._bytes = [];\n    this._bytes.length = length;\n\n    var i;\n    for (i = 0; i < this.byteLength; i += 1) {\n      this._bytes[i] = 0;\n    }\n\n    configureProperties(this);\n  };\n\n  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;\n\n  //\n  // 4 The ArrayBufferView Type\n  //\n\n  // NOTE: this constructor is not exported\n  /** @constructor */\n  var ArrayBufferView = function ArrayBufferView() {\n    //this.buffer = null;\n    //this.byteOffset = 0;\n    //this.byteLength = 0;\n  };\n\n  //\n  // 5 The Typed Array View Types\n  //\n\n  function makeConstructor(bytesPerElement, pack, unpack) {\n    // Each TypedArray type requires a distinct constructor instance with\n    // identical logic, which this produces.\n\n    var ctor;\n    ctor = function(buffer, byteOffset, length) {\n      var array, sequence, i, s;\n\n      if (!arguments.length || typeof arguments[0] === 'number') {\n        // Constructor(unsigned long length)\n        this.length = ECMAScript.ToInt32(arguments[0]);\n        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');\n\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {\n        // Constructor(TypedArray array)\n        array = arguments[0];\n\n        this.length = array.length;\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          this._setter(i, array._getter(i));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(sequence<type> array)\n        sequence = arguments[0];\n\n        this.length = ECMAScript.ToUint32(sequence.length);\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          s = sequence[i];\n          this._setter(i, Number(s));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(ArrayBuffer buffer,\n        //             optional unsigned long byteOffset, optional unsigned long length)\n        this.buffer = buffer;\n\n        this.byteOffset = ECMAScript.ToUint32(byteOffset);\n        if (this.byteOffset > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset out of range\");\n        }\n\n        if (this.byteOffset % this.BYTES_PER_ELEMENT) {\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          throw new RangeError(\"ArrayBuffer length minus the byteOffset is not a multiple of the element size.\");\n        }\n\n        if (arguments.length < 3) {\n          this.byteLength = this.buffer.byteLength - this.byteOffset;\n\n          if (this.byteLength % this.BYTES_PER_ELEMENT) {\n            throw new RangeError(\"length of buffer minus byteOffset not a multiple of the element size\");\n          }\n          this.length = this.byteLength / this.BYTES_PER_ELEMENT;\n        } else {\n          this.length = ECMAScript.ToUint32(length);\n          this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        }\n\n        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n\n      this.constructor = ctor;\n\n      configureProperties(this);\n      makeArrayAccessors(this);\n    };\n\n    ctor.prototype = new ArrayBufferView();\n    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;\n    ctor.prototype._pack = pack;\n    ctor.prototype._unpack = unpack;\n    ctor.BYTES_PER_ELEMENT = bytesPerElement;\n\n    // getter type (unsigned long index);\n    ctor.prototype._getter = function(index) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = [], i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    };\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    ctor.prototype.get = ctor.prototype._getter;\n\n    // setter void (unsigned long index, type value);\n    ctor.prototype._setter = function(index, value) {\n      if (arguments.length < 2) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = this._pack(value), i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    };\n\n    // void set(TypedArray array, optional unsigned long offset);\n    // void set(sequence<type> array, optional unsigned long offset);\n    ctor.prototype.set = function(index, value) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n      var array, sequence, offset, len,\n          i, s, d,\n          byteOffset, byteLength, tmp;\n\n      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + array.length > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset;\n               i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ECMAScript.ToUint32(sequence.length);\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + len > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n    };\n\n    // TypedArray subarray(long begin, optional long end);\n    ctor.prototype.subarray = function(start, end) {\n      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n      start = ECMAScript.ToInt32(start);\n      end = ECMAScript.ToInt32(end);\n\n      if (arguments.length < 1) { start = 0; }\n      if (arguments.length < 2) { end = this.length; }\n\n      if (start < 0) { start = this.length + start; }\n      if (end < 0) { end = this.length + end; }\n\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n\n      return new this.constructor(\n        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    };\n\n    return ctor;\n  }\n\n  var Int8Array = makeConstructor(1, packI8, unpackI8);\n  var Uint8Array = makeConstructor(1, packU8, unpackU8);\n  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);\n  var Int16Array = makeConstructor(2, packI16, unpackI16);\n  var Uint16Array = makeConstructor(2, packU16, unpackU16);\n  var Int32Array = makeConstructor(4, packI32, unpackI32);\n  var Uint32Array = makeConstructor(4, packU32, unpackU32);\n  var Float32Array = makeConstructor(4, packF32, unpackF32);\n  var Float64Array = makeConstructor(8, packF64, unpackF64);\n\n  exports.Int8Array = exports.Int8Array || Int8Array;\n  exports.Uint8Array = exports.Uint8Array || Uint8Array;\n  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;\n  exports.Int16Array = exports.Int16Array || Int16Array;\n  exports.Uint16Array = exports.Uint16Array || Uint16Array;\n  exports.Int32Array = exports.Int32Array || Int32Array;\n  exports.Uint32Array = exports.Uint32Array || Uint32Array;\n  exports.Float32Array = exports.Float32Array || Float32Array;\n  exports.Float64Array = exports.Float64Array || Float64Array;\n}());\n\n//\n// 6 The DataView View Type\n//\n\n(function() {\n  function r(array, index) {\n    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];\n  }\n\n  var IS_BIG_ENDIAN = (function() {\n    var u16array = new(exports.Uint16Array)([0x1234]),\n        u8array = new(exports.Uint8Array)(u16array.buffer);\n    return r(u8array, 0) === 0x12;\n  }());\n\n  // Constructor(ArrayBuffer buffer,\n  //             optional unsigned long byteOffset,\n  //             optional unsigned long byteLength)\n  /** @constructor */\n  var DataView = function DataView(buffer, byteOffset, byteLength) {\n    if (arguments.length === 0) {\n      buffer = new exports.ArrayBuffer(0);\n    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {\n      throw new TypeError(\"TypeError\");\n    }\n\n    this.buffer = buffer || new exports.ArrayBuffer(0);\n\n    this.byteOffset = ECMAScript.ToUint32(byteOffset);\n    if (this.byteOffset > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset out of range\");\n    }\n\n    if (arguments.length < 3) {\n      this.byteLength = this.buffer.byteLength - this.byteOffset;\n    } else {\n      this.byteLength = ECMAScript.ToUint32(byteLength);\n    }\n\n    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n    }\n\n    configureProperties(this);\n  };\n\n  function makeGetter(arrayType) {\n    return function(byteOffset, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n      byteOffset += this.byteOffset;\n\n      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n          bytes = [], i;\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(uint8Array, i));\n      }\n\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);\n    };\n  }\n\n  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);\n  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);\n  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);\n  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);\n  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);\n  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);\n  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);\n  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);\n\n  function makeSetter(arrayType) {\n    return function(byteOffset, value, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n\n      // Get bytes\n      var typeArray = new arrayType([value]),\n          byteArray = new exports.Uint8Array(typeArray.buffer),\n          bytes = [], i, byteView;\n\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(byteArray, i));\n      }\n\n      // Flip if necessary\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      // Write them\n      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n      byteView.set(bytes);\n    };\n  }\n\n  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);\n  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);\n  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);\n  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);\n  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);\n  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);\n  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);\n  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);\n\n  exports.DataView = exports.DataView || DataView;\n\n}());\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","var fs = require('fs')\nvar path = require('path')\nvar datStore = require('dat-storage')\n// var secretStorage = require('dat-secret-storage')\nvar raf = require('random-access-file')\nvar ram = require('random-access-memory')\n\nmodule.exports = defaultStorage\n\n/**\n * Parse the storage argument and return storage for hyperdrive.\n * By default, uses dat-secret-storage to storage secret keys in user's home directory.\n * @param {string|object} storage - Storage for hyperdrive.\n *   `string` is a directory or file. Directory: `/my-data`, storage will be in `/my-data/.dat`.\n *   Single File: `/my-file.zip`, storage will be in memory.\n *   Object is a hyperdrive storage object `{metadata: fn, content: fn}`.\n * @param {object} [opts] - options\n * @param {Boolean} [opts.temp] - Use temporary storage (random-access-memory)\n * @returns {object} hyperdrive storage object\n */\nfunction defaultStorage (storage, opts) {\n  // Use custom storage or ram\n  if (typeof storage !== 'string') return storage\n  if (opts.temp) return ram\n  if (opts.latest === false) {\n    // Store as SLEEP files inluding content.data\n    return {\n      metadata: function (name, opts) {\n        // I don't think we want this, we may get multiple 'ogd' sources\n        // if (name === 'secret_key') return secretStorage()(path.join(storage, 'metadata.ogd'), {key: opts.key, discoveryKey: opts.discoveryKey})\n        return raf(path.join(storage, 'metadata.' + name))\n      },\n      content: function (name, opts) {\n        return raf(path.join(storage, 'content.' + name))\n      }\n    }\n  }\n\n  try {\n    // Store in .dat with secret in ~/.dat\n    if (fs.statSync(storage).isDirectory()) {\n      return datStore(storage, opts)\n    }\n  } catch (e) {\n    // Does not exist, make dir\n    try {\n      fs.mkdirSync(storage)\n    } catch (e) {\n      // Invalid path\n      throw new Error('Invalid storage path')\n    }\n    return datStore(storage, opts)\n  }\n  error()\n\n  function error () {\n    // TODO: single file sleep storage\n    throw new Error('Storage must be dir or opts.temp')\n  }\n}\n","var raf = require('random-access-file')\nvar secretStorage = require('dat-secret-storage')\nvar multi = require('multi-random-access')\nvar messages = require('append-tree/messages')\nvar stat = require('hyperdrive/lib/messages').Stat\nvar path = require('path')\n\nmodule.exports = function (dir, opts) {\n  if (!opts) opts = {}\n  var prefix = opts.prefix || '.dat/'\n  return {\n    metadata: function (name, metaOpts) {\n      if (typeof dir === 'function') return dir(prefix + 'metadata.' + name)\n      if (name === 'secret_key') return secretStorage(opts.secretDir)(path.join(dir, prefix + 'metadata.ogd'), {key: metaOpts.key, discoveryKey: metaOpts.discoveryKey})\n      return raf(path.join(dir, prefix + 'metadata.' + name))\n    },\n    content: function (name, contentOpts, archive) {\n      if (!archive) archive = contentOpts\n      if (name === 'data') return createStorage(archive, dir)\n      if (typeof dir === 'function') return dir(prefix + 'content.' + name)\n      return raf(path.join(dir, prefix + 'content.' + name))\n    }\n  }\n}\n\nfunction createStorage (archive, dir) {\n  if (!archive.latest) throw new Error('Currently only \"latest\" mode is supported.')\n\n  var latest = archive.latest\n  var head = null\n  var storage = multi({limit: 128}, locate)\n\n  // TODO: this should be split into two events, 'appending' and 'append'\n  archive.on('appending', onappending)\n  archive.on('append', onappend)\n\n  return storage\n\n  function onappend (name, opts) {\n    if (head) head.end = archive.content.byteLength\n  }\n\n  function onappending (name, opts) {\n    if (head) head.end = archive.content.byteLength\n\n    var v = latest ? '' : '.' + archive.metadata.length\n\n    head = {\n      start: archive.content.byteLength,\n      end: Infinity,\n      storage: file(name + v)\n    }\n\n    storage.add(head)\n  }\n\n  function locate (offset, cb) {\n    archive.ready(function (err) {\n      if (err) return cb(err)\n\n      find(archive.metadata, offset, function (err, node, st, index) {\n        if (err) return cb(err)\n        if (!node) return cb(new Error('Could not locate data'))\n\n        var v = latest ? '' : '.' + index\n\n        cb(null, {\n          start: st.byteOffset,\n          end: st.byteOffset + st.size,\n          storage: file(node.name + v)\n        })\n      })\n    })\n  }\n\n  function file (name) {\n    if (typeof dir === 'function') return dir(name)\n    return raf(name, {directory: dir, rmdir: true})\n  }\n}\n\nfunction get (metadata, btm, seq, cb) {\n  if (seq < btm) return cb(null, -1, null)\n\n  // TODO: this can be done a lot faster using the hypercore internal iterators, expose!\n  var i = seq\n  while (!metadata.has(i) && i > btm) i--\n  if (!metadata.has(i)) return cb(null, -1, null)\n\n  metadata.get(i, {valueEncoding: messages.Node}, function (err, node) {\n    if (err) return cb(err)\n\n    var st = node.value && stat.decode(node.value)\n\n    if (!node.value || (!st.offset && !st.blocks) || (!st.byteOffset && !st.blocks)) {\n      return get(metadata, btm, i - 1, cb) // TODO: check the index instead for fast lookup\n    }\n\n    cb(null, i, node, st)\n  })\n}\n\nfunction find (metadata, bytes, cb) {\n  var top = metadata.length - 1\n  var btm = 1\n  var mid = Math.floor((top + btm) / 2)\n\n  get(metadata, btm, mid, function loop (err, actual, node, st) {\n    if (err) return cb(err)\n\n    var oldMid = mid\n\n    if (!node) {\n      btm = mid\n      mid = Math.floor((top + btm) / 2)\n    } else {\n      var start = st.byteOffset\n      var end = st.byteOffset + st.size\n\n      if (start <= bytes && bytes < end) return cb(null, node, st, actual)\n      if (top <= btm) return cb(null, null, null, -1)\n\n      if (bytes < start) {\n        top = mid\n        mid = Math.floor((top + btm) / 2)\n      } else {\n        btm = mid\n        mid = Math.floor((top + btm) / 2)\n      }\n    }\n\n    if (mid === oldMid) {\n      if (btm < top) mid++\n      else return cb(null, null, null, -1)\n    }\n\n    get(metadata, btm, mid, loop)\n  })\n}\n","var path = require('path')\nvar homedir = require('os-homedir')\nvar raf = require('random-access-file')\n\nmodule.exports = function (dir) {\n  if (!dir) dir = path.join(homedir(), '.dat', 'secret_keys')\n  return function (name, opts) {\n    var discKey = opts.discoveryKey\n    if (!discKey) throw new Error('Discovery key required')\n    if (typeof discKey !== 'string') discKey = discKey.toString('hex')\n\n    return new Storage(\n      raf(name),\n      raf(path.join(dir, discKey.slice(0, 2), discKey.slice(2)))\n    )\n  }\n}\n\nfunction Storage (ownerFile, secretFile) {\n  this.ownerFile = ownerFile\n  this.secretFile = secretFile\n}\n\nStorage.prototype.open = function (cb) {\n  if (!cb) cb = noop\n  var self = this\n\n  this.ownerFile.open(function (err) {\n    if (err) return cb(err)\n    self.secretFile.open(cb)\n  })\n}\n\nStorage.prototype.read = function (offset, length, cb) {\n  var self = this\n\n  this.ownerFile.read(0, 1, function (err) {\n    if (err) return cb(err)\n    self.secretFile.read(offset, length, cb)\n  })\n}\n\nStorage.prototype.write = function (offset, data, cb) {\n  if (!cb) cb = noop\n  var self = this\n\n  this.ownerFile.write(0, new Buffer([0]), function (err) {\n    if (err) return cb(err)\n    self.secretFile.write(offset, data, cb)\n  })\n}\n\nStorage.prototype.close = function (cb) {\n  if (!cb) cb = noop\n  var self = this\n\n  this.ownerFile.close(function () {\n    self.secretFile.close(cb)\n  })\n}\n\nfunction noop () {}\n","'use strict';\nvar os = require('os');\n\nfunction homedir() {\n\tvar env = process.env;\n\tvar home = env.HOME;\n\tvar user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;\n\n\tif (process.platform === 'win32') {\n\t\treturn env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;\n\t}\n\n\tif (process.platform === 'darwin') {\n\t\treturn home || (user ? '/Users/' + user : null);\n\t}\n\n\tif (process.platform === 'linux') {\n\t\treturn home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));\n\t}\n\n\treturn home || null;\n}\n\nmodule.exports = typeof os.homedir === 'function' ? os.homedir : homedir;\n","var AbstractRandomAccess = require('abstract-random-access')\nvar inherits = require('inherits')\nvar sorted = require('sorted-array-functions')\n\nmodule.exports = Storage\n\nfunction Storage (opts, open) {\n  if (!(this instanceof Storage)) return new Storage(opts, open)\n\n  if (typeof opts === 'function') {\n    open = opts\n    opts = null\n  }\n  if (!opts) opts = {}\n\n  AbstractRandomAccess.call(this)\n\n  this.stores = []\n  this.limit = opts.limit || 16\n\n  this._openStorage = open\n  this._last = null\n}\n\ninherits(Storage, AbstractRandomAccess)\n\nStorage.prototype._write = function (offset, buf, cb) {\n  var match = this._get(offset)\n  if (!match) return this._openAndWrite(offset, buf, cb)\n\n  var start = offset - match.start\n  var max = match.end - match.start\n\n  if (buf.length > max - start) this._writeMulti(offset, buf, max - start, cb)\n  else match.storage.write(start, buf, cb)\n}\n\nStorage.prototype._writeMulti = function (offset, buf, next, cb) {\n  var self = this\n\n  this.write(offset, buf.slice(0, next), function (err) {\n    if (err) return cb(err)\n    self.write(offset + next, buf.slice(next), cb)\n  })\n}\n\nStorage.prototype.del = function (offset, length, cb) {\n  if (!cb) cb = noop\n\n  var match = this._get(offset)\n  if (!match) return this._openAndDel(offset, length, cb)\n\n  var start = offset - match.start\n  var max = match.end - match.start\n\n  if (length > max - start) this._delMulti(offset, length, max - start, cb)\n  else if (start === 0 && length === max) this._destroy(match, cb)\n  else if (match.storage.del) match.storage.del(start, length, cb)\n  else process.nextTick(cb)\n}\n\nStorage.prototype._delMulti = function (offset, length, next, cb) {\n  var self = this\n\n  this.del(offset, length - next, function (err) {\n    if (err) return cb(err)\n    self.del(offset + next, length - next, cb)\n  })\n}\n\nStorage.prototype._destroy = function (match, cb) {\n  var i = this.stores.indexOf(match)\n  if (i === -1) return process.nextTick(cb)\n\n  this.stores.splice(i, 1)\n  if (match === this._last) this._last = null\n\n  if (match.storage.destroy) return match.storage.destroy(cb)\n  if (match.storage.unlink) return match.storage.unlink(cb) // legacy, remove in the future\n\n  match.storage.del(0, match.end - match.start, function (err) {\n    if (err) return cb(err)\n    match.storage.close(cb)\n  })\n}\n\nStorage.prototype._read = function (offset, length, cb) {\n  var match = this._get(offset)\n  if (!match) return this._openAndRead(offset, length, cb)\n\n  var start = offset - match.start\n  var max = match.end - match.start\n\n  if (length > max - start) this._readMulti(offset, length, max - start, cb)\n  else match.storage.read(start, length, cb)\n}\n\nStorage.prototype._readMulti = function (offset, length, next, cb) {\n  var self = this\n\n  this.read(offset, next, function (err, head) {\n    if (err) return cb(err)\n    self.read(offset + next, length - next, function (err, tail) {\n      if (err) return cb(err)\n      cb(null, Buffer.concat([head, tail]))\n    })\n  })\n}\n\nStorage.prototype._end = function (opts, cb) {\n  var self = this\n\n  loop(null)\n\n  function loop (err) {\n    if (err) return cb(err)\n    if (!self.stores.length) return cb()\n    end(self.stores.shift().storage, opts, loop)\n  }\n\n  function end (st, opts, cb) {\n    if (st.end) st.end(opts, cb)\n    else process.nextTick(cb)\n  }\n}\n\nStorage.prototype._close = function (cb) {\n  var self = this\n\n  loop(null)\n\n  function loop (err) {\n    if (err) return cb(err)\n    if (!self.stores.length) return cb()\n    self.stores.shift().storage.close(loop)\n  }\n}\n\nStorage.prototype._get = function (offset) {\n  if (this._last) { // high chance that we'll hit the same at least twice\n    if (this._last.start <= offset && this._last.end > offset) return this._last\n  }\n\n  var i = sorted.lte(this.stores, {start: offset}, cmp)\n  if (i === -1) return null\n\n  var next = this.stores[i]\n  if (next.start <= offset && next.end > offset) {\n    this._last = next\n    return next\n  }\n\n  return null\n}\n\nStorage.prototype.add = function (match, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var prev = this._get(match.start)\n\n  if (prev) {\n    match.storage.close()\n    return cb()\n  }\n\n  done(null)\n\n  function done (err) {\n    if (err) return cb(err)\n    if (self.stores.length >= self.limit) {\n      var removed = self.stores.splice(Math.floor(Math.random() * self.stores.length), 1)[0]\n      if (removed === this._last) this._last = null\n      removed.storage.close(done)\n    } else {\n      sorted.add(self.stores, match, cmp)\n      cb()\n    }\n  }\n}\n\nStorage.prototype._openAndDel = function (offset, length, cb) {\n  var self = this\n  this._openStorage(offset, function (err, match) {\n    if (err) return cb(err)\n    self.add(match, function (err) {\n      if (err) return cb(err)\n      self.del(offset, length, cb)\n    })\n  })\n}\n\nStorage.prototype._openAndWrite = function (offset, buf, cb) {\n  var self = this\n  this._openStorage(offset, function (err, match) {\n    if (err) return cb(err)\n    self.add(match, function (err) {\n      if (err) return cb(err)\n      self.write(offset, buf, cb)\n    })\n  })\n}\n\nStorage.prototype._openAndRead = function (offset, length, cb) {\n  var self = this\n  this._openStorage(offset, function (err, match) {\n    if (err) return cb(err)\n    self.add(match, function (err) {\n      if (err) return cb(err)\n      self.read(offset, length, cb)\n    })\n  })\n}\n\nfunction cmp (a, b) {\n  return a.start - b.start\n}\n\nfunction noop () {}\n","var EventEmitter = require('events').EventEmitter\nvar inherits = require('inherits')\n\nvar noop = function () {}\n\nmodule.exports = Abstract\ninherits(Abstract, EventEmitter)\n\nfunction Abstract (opts) {\n  if (!(this instanceof Abstract)) return new Abstract(opts)\n  EventEmitter.call(this)\n\n  this.opened = false\n  this._opening = null\n  this._closing = null\n\n  if (opts) {\n    if (opts.read) this._read = opts.read\n    if (opts.write) this._write = opts.write\n    if (opts.open) this._open = opts.open\n    if (opts.close) this._close = opts.close\n    if (opts.end) this._end = opts.end\n    if (opts.unlink) this._unlink = opts.unlink\n  }\n}\n\nAbstract.prototype.open = function (callback) {\n  if (!callback) callback = noop\n  if (this.opened) return process.nextTick(callback)\n\n  var self = this\n\n  if (this._opening) {\n    this._opening.push(callback)\n  } else {\n    this._opening = [callback]\n    this._open(opened)\n  }\n\n  function opened (err) {\n    if (!err) self.opened = true\n    var cbs = self._opening\n    self._opening = null\n    self.emit('open')\n    for (var i = 0; i < cbs.length; i++) cbs[i](err)\n  }\n}\n\nAbstract.prototype._open = function (callback) {\n  process.nextTick(callback)\n}\n\nAbstract.prototype.write = function (offset, buffer, callback) {\n  if (!callback) callback = noop\n\n  if (typeof offset !== 'number') throw new Error('Scalar offset')\n  if (!Buffer.isBuffer(buffer)) throw new Error('Buffer')\n\n  if (!this.opened) return openAndWrite(this, offset, buffer, callback)\n  this._write(offset, buffer, callback)\n}\n\nAbstract.prototype._write = function (offset, buffer, callback) {\n  process.nextTick(function () {\n    callback(new Error('Write not implemented'))\n  })\n}\n\nAbstract.prototype.read = function (offset, length, callback) {\n  if (typeof offset !== 'number') throw new Error('Scalar offset')\n  if (typeof length !== 'number') throw new Error('Scalar length')\n  if (typeof callback !== 'function') throw new Error('Callback')\n\n  if (!this.opened) return openAndRead(this, offset, length, callback)\n  this._read(offset, length, callback)\n}\n\nAbstract.prototype._read = function (offset, length, callback) {\n  process.nextTick(function () {\n    callback(new Error('Read not implemented'))\n  })\n}\n\nAbstract.prototype.close = function (callback) {\n  if (!callback) callback = noop\n\n  var self = this\n\n  if (!this.opened) this.open(next)\n  else next()\n\n  function next (err) {\n    if (err) return callback(err)\n\n    if (self._closing) {\n      self._closing.push(callback)\n    } else {\n      self._closing = [callback]\n      self._close(closed)\n    }\n  }\n\n  function closed (err) {\n    if (!err) self.opened = false\n    var cbs = self._closing\n    self._closing = null\n    self.emit('close')\n    for (var i = 0; i < cbs.length; i++) cbs[i](err)\n  }\n}\n\nAbstract.prototype._close = function (callback) {\n  process.nextTick(callback)\n}\n\nAbstract.prototype.end = function (options, callback) {\n  if (typeof options === 'function') return this.end(null, options)\n  if (!callback) callback = noop\n\n  var self = this\n\n  if (!this.opened) this.open(next)\n  else next()\n\n  function next (err) {\n    if (err) return callback(err)\n    self._end(options, callback)\n  }\n}\n\nAbstract.prototype._end = function (options, callback) {\n  process.nextTick(callback)\n}\n\nAbstract.prototype.unlink = function (callback) {\n  if (!callback) callback = noop\n\n  var self = this\n\n  if (!this.opened) this.open(next)\n  else next()\n\n  function next (err) {\n    if (err) return callback(err)\n    self._unlink(callback)\n  }\n}\n\nAbstract.prototype._unlink = function (callback) {\n  process.nextTick(callback)\n}\n\nfunction openAndWrite (self, offset, buffer, callback) {\n  self.open(function (err) {\n    if (err) return callback(err)\n    self.write(offset, buffer, callback)\n  })\n}\n\nfunction openAndRead (self, offset, length, callback) {\n  self.open(function (err) {\n    if (err) return callback(err)\n    self.read(offset, length, callback)\n  })\n}\n","exports.add = add\nexports.remove = remove\nexports.has = has\nexports.eq = eq\nexports.lte = lte\nexports.lt = lt\nexports.gte = gte\nexports.gt = gt\nexports.nearest = nearest\n\nfunction defaultCmp (a, b) {\n  if (a === b) return 0\n  return a > b ? 1 : -1\n}\n\nfunction add (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var top = list.push(value) - 1\n\n  while (top) {\n    if (cmp(list[top - 1], value) < 0) return\n    list[top] = list[top - 1]\n    list[top - 1] = value\n    top--\n  }\n}\n\nfunction lte (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var i = indexOf(list, value, cmp)\n  if (i === -1) return -1\n\n  for (; i >= 0; i--) {\n    var c = cmp(list[i], value)\n    if (c <= 0) return i\n  }\n\n  return -1\n}\n\nfunction lt (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var i = indexOf(list, value, cmp)\n  if (i === -1) return -1\n\n  for (; i >= 0; i--) {\n    var c = cmp(list[i], value)\n    if (c < 0) return i\n  }\n\n  return -1\n}\n\nfunction gte (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var i = indexOf(list, value, cmp)\n  if (i === -1) return -1\n\n  for (; i < list.length; i++) {\n    var c = cmp(list[i], value)\n    if (c >= 0) return i\n  }\n\n  return -1\n}\n\nfunction gt (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var i = indexOf(list, value, cmp)\n  if (i === -1) return -1\n\n  for (; i < list.length; i++) {\n    var c = cmp(list[i], value)\n    if (c > 0) return i\n  }\n\n  return -1\n}\n\nfunction eq (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var i = indexOf(list, value, cmp)\n  if (i === -1) return -1\n  return cmp(list[i], value) === 0 ? i : -1\n}\n\nfunction nearest (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var len = list.length\n  var top = len - 1\n  var btm = 0\n  var mid = -1\n  var trending = 1 // 0 = down, 2 = up\n\n  while (top >= btm && btm >= 0 && top < len) {\n    mid = Math.floor((top + btm) / 2)\n\n    var c = cmp(list[mid], value)\n    if (c === 0) return mid\n\n    if (c >= 0) {\n      if (trending === 1) trending = 0\n      else if (trending === 2) {\n        if (Math.abs(list[mid] - value) > Math.abs(list[mid - 1] - value)) return mid - 1\n        return mid\n      }\n\n      top = mid - 1\n    } else {\n      if (trending === 1) trending = 2\n      else if (trending === 0) return mid\n\n      btm = mid + 1\n    }\n  }\n\n  return mid\n}\n\nfunction indexOf (list, value, cmp) {\n  if (!cmp) cmp = defaultCmp\n\n  var len = list.length\n  var top = len - 1\n  var btm = 0\n  var mid = -1\n\n  while (top >= btm && btm >= 0 && top < len) {\n    mid = Math.floor((top + btm) / 2)\n\n    var c = cmp(list[mid], value)\n    if (c === 0) return mid\n\n    if (c >= 0) {\n      top = mid - 1\n    } else {\n      btm = mid + 1\n    }\n  }\n\n  return mid\n}\n\nfunction has (list, value, cmp) {\n  return eq(list, value, cmp) > -1\n}\n\nfunction remove (list, value, cmp) {\n  var i = eq(list, value, cmp)\n  if (i === -1) return false\n  list.splice(i, 1)\n  return true\n}\n","const RandomAccess = require('random-access-storage')\nconst isOptions = require('is-options')\nconst inherits = require('inherits')\n\nconst DEFAULT_PAGE_SIZE = 1024 * 1024\n\nmodule.exports = RAM\n\nfunction RAM (opts) {\n  if (!(this instanceof RAM)) return new RAM(opts)\n  if (typeof opts === 'number') opts = {length: opts}\n  if (!opts) opts = {}\n\n  RandomAccess.call(this)\n\n  if (Buffer.isBuffer(opts)) {\n    opts = {length: opts.length, buffer: opts}\n  }\n  if (!isOptions(opts)) opts = {}\n\n  this.length = opts.length || 0\n  this.pageSize = opts.length || opts.pageSize || DEFAULT_PAGE_SIZE\n  this.buffers = []\n\n  if (opts.buffer) this.buffers.push(opts.buffer)\n}\n\ninherits(RAM, RandomAccess)\n\nRAM.prototype._stat = function (req) {\n  callback(req, null, {size: this.length})\n}\n\nRAM.prototype._write = function (req) {\n  var i = Math.floor(req.offset / this.pageSize)\n  var rel = req.offset - i * this.pageSize\n  var start = 0\n\n  const len = req.offset + req.size\n  if (len > this.length) this.length = len\n\n  while (start < req.size) {\n    const page = this._page(i++, true)\n    const free = this.pageSize - rel\n    const end = free < (req.size - start)\n      ? start + free\n      : req.size\n\n    req.data.copy(page, rel, start, end)\n    start = end\n    rel = 0\n  }\n\n  callback(req, null, null)\n}\n\nRAM.prototype._read = function (req) {\n  var i = Math.floor(req.offset / this.pageSize)\n  var rel = req.offset - i * this.pageSize\n  var start = 0\n\n  if (req.offset + req.size > this.length) {\n    return callback(req, new Error('Could not satisfy length'), null)\n  }\n\n  const data = Buffer.alloc(req.size)\n\n  while (start < req.size) {\n    const page = this._page(i++, false)\n    const avail = this.pageSize - rel\n    const wanted = req.size - start\n    const len = avail < wanted ? avail : wanted\n\n    if (page) page.copy(data, start, rel, rel + len)\n    start += len\n    rel = 0\n  }\n\n  callback(req, null, data)\n}\n\nRAM.prototype._del = function (req) {\n  var i = Math.floor(req.offset / this.pageSize)\n  var rel = req.offset - i * this.pageSize\n  var start = 0\n\n  if (req.offset + req.size > this.length) {\n    req.size = Math.max(0, this.length - req.offset)\n  }\n\n  while (start < req.size) {\n    if (rel === 0 && req.size - start >= this.pageSize) {\n      this.buffers[i++] = undefined\n    }\n\n    rel = 0\n    start += this.pageSize - rel\n  }\n\n  if (req.offset + req.size >= this.length) {\n    this.length = req.offset\n  }\n\n  callback(req, null, null)\n}\n\nRAM.prototype._destroy = function (req) {\n  this._buffers = []\n  this.length = 0\n  callback(req, null, null)\n}\n\nRAM.prototype._page = function (i, upsert) {\n  var page = this.buffers[i]\n  if (page || !upsert) return page\n  page = this.buffers[i] = Buffer.alloc(this.pageSize)\n  return page\n}\n\nRAM.prototype.toBuffer = function () {\n  const buf = Buffer.alloc(this.length)\n\n  for (var i = 0; i < this.buffers.length; i++) {\n    if (this.buffers[i]) this.buffers[i].copy(buf, i * this.pageSize)\n  }\n\n  return buf\n}\n\nfunction callback (req, err, data) {\n  process.nextTick(callbackNT, req, err, data)\n}\n\nfunction callbackNT (req, err, data) {\n  req.callback(err, data)\n}\n","module.exports = isOptions\n\nfunction isOptions (opts) {\n  return typeof opts === 'object' && opts && !Buffer.isBuffer(opts)\n}\n","var assert = require('assert')\nvar path = require('path')\nvar untildify = require('untildify')\nvar importFiles = require('./lib/import-files')\nvar createNetwork = require('./lib/network')\nvar stats = require('./lib/stats')\nvar serveHttp = require('./lib/serve')\nvar debug = require('debug')('dat-node')\n\nmodule.exports = Dat\n\n/**\n * @class Dat\n * @type {Object}\n * @param {Object} archive - Hyperdrive archive\n * @param {Object} [opts] - Options\n * @param {String} [opts.dir] - Directory of archive\n *\n * @property {Object} archive - Hyperdrive Archive\n * @property {String} path - Resolved path of archive\n * @property {Buffer} key - Archive Key (`archive.key`)\n * @property {Boolean} live - Archive is live (`archive.live`)\n * @property {Boolean} writable - Archive is writable (`archive.metadata.writable`)\n * @property {Boolean} version - Archive version (`archive.version`)\n * @property {Object} options - Initial options and all options passed to childen functions.\n * @returns {Object} Dat\n */\nfunction Dat (archive, opts) {\n  if (!(this instanceof Dat)) return new Dat(archive, opts)\n  assert.ok(archive, 'archive required')\n  var self = this\n\n  this.archive = archive\n  this.options = Object.assign({}, opts)\n  if (opts.dir) {\n    this.path = path.resolve(untildify(opts.dir))\n  }\n\n  // Getters for convenience accessors\n  Object.defineProperties(this, {\n    key: {\n      enumerable: true,\n      get: function () {\n        return self.archive.key\n      }\n    },\n    live: {\n      enumerable: true,\n      get: function () {\n        return self.archive.live\n      }\n    },\n    resumed: {\n      enumerable: true,\n      get: function () {\n        return self.archive.resumed\n      }\n    },\n    writable: {\n      enumerable: true,\n      get: function () {\n        return self.archive.metadata.writable\n      }\n    },\n    version: {\n      enumerable: true,\n      get: function () {\n        return self.archive.version\n      }\n    }\n  })\n}\n\n/**\n * Join Dat Network via Hyperdiscovery\n * @type {Function}\n * @param {Object} [opts] - Network options, passed to hyperdiscovery.\n * @param {Function} [cb] - Callback after first round of discovery is finished.\n * @returns {Object} Discovery Swarm Instance\n */\nDat.prototype.joinNetwork =\nDat.prototype.join = function (opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  var self = this\n  if (!opts && self.options.network) opts = self.options.network // use previous options\n  else opts = opts || {}\n  cb = cb || noop\n\n  var netOpts = Object.assign({}, {\n    stream: function (peer) {\n      var stream = self.archive.replicate({\n        upload: !(opts.upload === false),\n        download: !self.writable && opts.download,\n        live: !opts.end\n      })\n      stream.on('close', function () {\n        debug('Stream close')\n      })\n      stream.on('error', function (err) {\n        debug('Replication error:', err.message)\n      })\n      stream.on('end', function () {\n        self.downloaded = true\n        debug('Replication stream ended')\n      })\n      return stream\n    }\n  }, opts)\n\n  var network = self.network = createNetwork(self.archive, netOpts, cb)\n  self.options.network = netOpts\n\n  return network\n}\n\n/**\n * Leave Dat Network\n * @type {Function}\n * @param {Function} [cb] - Callback after network is closed\n */\nDat.prototype.leaveNetwork =\nDat.prototype.leave = function (cb) {\n  if (!this.network) return\n  debug('leaveNetwork()')\n  // TODO: v8 unreplicate ?\n  // this.archive.unreplicate()\n  this.network.leave(this.archive.discoveryKey)\n  this.network.destroy(cb)\n  delete this.network\n}\n\n/**\n * Pause Dat Network\n * @type {Function}\n */\nDat.prototype.pause = function () {\n  debug('pause()')\n  this.leave()\n}\n\n/**\n * Resume Dat Network\n * @type {Function}\n */\nDat.prototype.resume = function () {\n  debug('resume()')\n  this.join()\n}\n\n/**\n * Track archive stats\n * @type {Function}\n */\nDat.prototype.trackStats = function (opts) {\n  opts = Object.assign({}, opts)\n  this.stats = stats(this.archive, opts)\n  return this.stats\n}\n\n/**\n * Import files to archive via mirror-folder\n * @type {Function}\n * @param {String} [src=dat.path] - Directory or File to import to `archive`.\n * @param {Function} [cb] - Callback after import is finished\n * @param {Object} [opts] - Options passed to `mirror-folder` and `dat-ignore`\n * @returns {Object} - Import progress\n */\nDat.prototype.importFiles = function (src, opts, cb) {\n  if (!this.writable) throw new Error('Must be archive owner to import files.')\n  if (typeof src !== 'string') return this.importFiles('', src, opts)\n  if (typeof opts === 'function') return this.importFiles(src, {}, opts)\n\n  var self = this\n  src = src && src.length ? src : self.path\n  opts = Object.assign({\n    indexing: (opts && opts.indexing) || (src === self.path)\n  }, opts)\n\n  self.importer = importFiles(self.archive, src, opts, cb)\n  self.options.importer = self.importer.options\n  return self.importer\n}\n\n/**\n * Serve archive over http\n * @type {Function}\n * @param {Object} [opts] - Options passed to `mirror-folder` and `dat-ignore`\n * @returns {Object} - node http server instance\n */\nDat.prototype.serveHttp = function (opts) {\n  this.server = serveHttp(this.archive, opts)\n  return this.server\n}\n\n/**\n * Close Dat archive and other things\n * @type {Function}\n * @param {Function} [cb] - Callback after all items closed\n */\nDat.prototype.close = function (cb) {\n  cb = cb || noop\n  if (this._closed) return cb(new Error('Dat is already closed'))\n\n  var self = this\n  self._closed = true\n\n  debug('closing network')\n  closeNet(function (err) {\n    if (err) debug('Error while closing network:', err.message)\n    debug('closing closeFileWatch')\n    closeFileWatch(function () {\n      // self.archive.unreplicate()\n      debug('closing archive')\n      self.archive.close(cb)\n    })\n  })\n\n  function closeNet (cb) {\n    if (!self.network) return cb()\n    self.leave(cb)\n  }\n\n  function closeFileWatch (cb) {\n    if (!self.importer) return cb()\n    // Emitting an event, as imported doesn't emit an event on\n    // destroy and there is no other means to see if this was called.\n    self.importer.emit('destroy')\n    self.importer.destroy()\n    delete self.importer\n    process.nextTick(cb)\n  }\n}\n\nfunction noop () { }\n","'use strict';\n\nconst home = require('os').homedir();\n\nmodule.exports = str => {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof str}`);\n\t}\n\n\treturn home ? str.replace(/^~(?=$|\\/|\\\\)/, home) : str;\n};\n","var assert = require('assert')\nvar path = require('path')\nvar mirror = require('mirror-folder')\nvar datIgnore = require('dat-ignore')\nvar speed = require('speedometer')\nvar debug = require('debug')('dat-node')\n\nmodule.exports = importer\n\nfunction importer (archive, src, opts, cb) {\n  assert.ok(archive, 'lib/import-files archive required')\n  assert.ok(src, 'lib/import-files src directory required')\n  if (typeof opts === 'function') return importer(archive, src, {}, opts)\n\n  var progress\n  var importCount\n  var indexSpeed = speed()\n  var ignore = datIgnore(src, opts)\n  var ignoreDirs = !(opts.ignoreDirs === false)\n  src = path.normalize(src)\n\n  opts = Object.assign({\n    watch: false,\n    dereference: true,\n    count: true\n  }, opts, {\n    // overwrite opts.ignore (original opts.ignore parsed in dat-ignore)\n    ignore: function (name, st) {\n      if (ignoreDirs && st && st.isDirectory()) return true\n      return ignore(name, st)\n    }\n  })\n  debug('importFiles()', opts)\n\n  if (opts.count) {\n    // Dry Run Import to get initial import size\n    importCount = { files: 0, bytes: 0 }\n    var dryRunOpts = Object.assign({}, opts, { dryRun: true, watch: false }) // force right side opts\n    var dryRun = mirror(src, { name: '/', fs: archive }, dryRunOpts, function (err) {\n      if (err) return cb(err)\n      progress.emit('count', importCount)\n    })\n    dryRun.on('put', function (src, dst) {\n      if (src.stat.isDirectory() || src.live) return\n      importCount.bytes += src.stat.size\n      importCount.files++\n    })\n  }\n\n  // Importing\n  progress = mirror(src, { name: '/', fs: archive }, opts, cb)\n  progress.on('put-data', function (chunk, src, dst) {\n    progress.indexSpeed = indexSpeed(chunk.length)\n  })\n  if (debug.enabled) {\n    progress.on('put', function (src, dst) {\n      debug('IMPORT put:', dst.name)\n    })\n    progress.on('del', function (src, dst) {\n      debug('IMPORT del:', dst.name)\n    })\n    progress.on('ignore', function (src, dst) {\n      debug('IMPORT ignore:', dst.name)\n    })\n    progress.on('skip', function (src, dst) {\n      debug('IMPORT skip:', dst.name)\n    })\n    progress.on('end', function () {\n      debug('IMPORT done')\n    })\n  }\n  if (opts.count) {\n    progress.count = importCount\n    progress.putDone = {\n      files: 0,\n      bytes: 0\n    }\n    progress.on('put-end', function (src, dst) {\n      if (!src.live) {\n        progress.putDone.bytes += src.stat.size\n        progress.putDone.files++\n      }\n    })\n  }\n\n  progress.options = opts\n  return progress\n}\n","var watch = require('recursive-watch')\nvar createReadStream = require('fd-read-stream')\nvar fs = require('fs')\nvar path = require('path')\nvar events = require('events')\n\nmodule.exports = mirror\n\nfunction mirror (src, dst, opts, cb) {\n  if (typeof opts === 'function') return mirror(src, dst, null, opts)\n  if (!opts) opts = {}\n  if (opts.skipSpecial !== false) opts.skipSpecial = true\n\n  var progress = new events.EventEmitter()\n  progress.destroy = destroy\n\n  if (cb) {\n    progress.on('error', cb)\n    progress.on('end', cb)\n  }\n\n  src = parse(src)\n  dst = parse(dst)\n\n  var stopped = false\n  var waiting = true\n  var walking = [src.name]\n  var pending = progress.pending = []\n  var equals = opts.equals || defaultEquals\n  var stopWatch = null\n\n  if (opts.watch) stopWatch = watch(src.name, onwatch)\n  walk()\n\n  return progress\n\n  function onwatch (name) {\n    update(name, true)\n  }\n\n  function update (name, live) {\n    var item = {name: name.slice(src.name.length) || path.sep, live: live}\n    if (name === src.name) item = {name: '', live: live} // allow single file src (not '/')\n\n    pending.push(item)\n    progress.emit('pending', item)\n    if (pending.length === 1) kick()\n  }\n\n  function stat (fs, name, cb) {\n    if (opts.dereference) fs.stat(name, cb)\n    else fs.lstat(name, cb)\n  }\n\n  function kick () {\n    var name = pending[0].name\n    var live = pending[0].live\n\n    var a = {name: path.join(src.name, name), stat: null, live: live, fs: src.fs}\n    var b = {name: path.join(dst.name, name), stat: null, live: live, fs: dst.fs}\n\n    stat(a.fs, a.name, function (_, st) {\n      if (st) a.stat = st\n      stat(b.fs, b.name, function (_, st) {\n        if (st) b.stat = st\n\n        // skip, not in any folder\n        if (!a.stat && !b.stat) {\n          progress.emit('skip', a, b)\n          return next()\n        }\n\n        if (live && a.stat && a.stat.isDirectory()) {\n          walking.push(a.name) // will retrigger\n          return next()\n        }\n\n        // ignore\n        if (opts.ignore && (opts.ignore(a.name, a.stat) || opts.ignore(b.name, b.stat))) {\n          if (live && b.stat && b.stat.isDirectory() && !a.stat) {\n            return rimraf(b, opts.ignore, next)\n          }\n          progress.emit('ignore', a, b)\n          return next()\n        }\n\n        // del from b\n        if (!a.stat && b.stat) return del(b, next)\n\n        // copy to b\n        if (a.stat && !b.stat) return put(a, b, next)\n\n        if (!a.stat.isDirectory() && opts.skipSpecial && !a.stat.isFile()) {\n          progress.emit('skip', a, b)\n          return next()\n        }\n\n        // check if they are the same\n        equals(a, b, function (err, same) {\n          if (err) throw err\n          if (same) {\n            progress.emit('skip', a, b)\n            return next()\n          }\n          put(a, b, next)\n        })\n      })\n    })\n  }\n\n  function next (err) {\n    if (stopped) return\n    if (err) return progress.emit('error', err)\n    if (stopped) return\n\n    pending.shift()\n    if (pending.length) return kick()\n\n    if (!opts.watch && !walking.length && waiting) return progress.emit('end')\n    walk()\n  }\n\n  function walk () {\n    if (!walking.length || !waiting) return\n\n    var name = walking.pop()\n    waiting = false\n\n    src.fs.lstat(name, function (err, st) {\n      if (err && err.code === 'ENOENT') return walk()\n      if (err) return progress.emit('error', err)\n\n      if (!st.isDirectory()) {\n        waiting = true\n        update(name, false)\n        return\n      }\n\n      src.fs.readdir(name, function (err, names) {\n        if (err && err.code === 'ENOENT') return walk()\n        if (err) return progress.emit('error', err)\n\n        names = names.sort().reverse()\n        for (var i = 0; i < names.length; i++) walking.push(path.join(name, names[i]))\n\n        var dstName = path.join(dst.name, path.relative(src.name, name))\n        dst.fs.readdir(dstName, function (err, dstNames) {\n          if (err) return next()\n\n          if (!opts.keepExisting) {\n            queueFilesToDelete(dstNames)\n          }\n          next()\n        })\n\n        function next () {\n          waiting = true\n          update(name, false)\n        }\n\n        function queueFilesToDelete (dstNames) {\n          // names = array of files in src\n          // dstNames = array of files in dst\n          // return items in dest but not in src (to delete)\n          dstNames = dstNames.sort().reverse().filter(function (file) {\n            return names.indexOf(file) === -1\n          })\n\n          // add files to pending to queue for deletion in dest\n          // use `join(srcName, dstName)` since !src.stat = true, forces delete\n          for (var j = 0; j < dstNames.length; j++) update(path.join(name, dstNames[j]), false)\n        }\n      })\n    })\n  }\n\n  function del (b, cb) {\n    progress.emit('del', b)\n    if (opts.dryRun) return cb()\n    if (!b.stat.isDirectory()) return b.fs.unlink(b.name, cb)\n    rimraf(b, null, function () { // ignore errors for now\n      cb()\n    })\n  }\n\n  function rimraf (b, ignore, cb) { // this one is a bit hacky ...\n    b.fs.readdir(b.name, function (_, list) {\n      if (!list) list = []\n      loop()\n\n      function loop () {\n        if (!list.length) {\n          if (ignore && ignore(b.name, b.stat)) return process.nextTick(cb)\n          if (b.stat.isDirectory()) b.fs.rmdir(b.name, cb)\n          else b.fs.unlink(b.name, cb)\n          return\n        }\n\n        var name = path.join(b.name, list.shift())\n\n        b.fs.lstat(name, function (err, st) {\n          if (err) return cb()\n          rimraf({name: name, stat: st, fs: b.fs}, ignore, loop)\n        })\n      }\n    })\n  }\n\n  function put (a, b, cb) {\n    progress.emit('put', a, b)\n    if (opts.dryRun) {\n      if (a.stat.isDirectory()) return cb() // Don't call put-end\n      return onfinish()\n    }\n    if (a.stat.isDirectory()) return b.fs.mkdir(b.name, a.stat.mode, ignoreError(cb))\n\n    if (a.live && a.fs.open) {\n      // To work around the race condition that files might be written *in progress*\n      // when live watching we use the fd retry 50ms option.\n      a.fs.open(a.name, 'r', function (err, fd) {\n        if (err) return cb(err)\n        copy(createReadStream(fd, {retry: 50}))\n      })\n    } else {\n      copy(a.fs.createReadStream(a.name))\n    }\n\n    function copy (rs) {\n      var ws = b.fs.createWriteStream(b.name, {mode: a.stat.mode})\n\n      rs.on('error', onerror)\n      ws.on('error', onerror)\n      ws.on('finish', onfinish)\n\n      rs.pipe(ws)\n      rs.on('data', ondata)\n\n      function ondata (data) {\n        progress.emit('put-data', data, a, b)\n      }\n\n      function onerror (err) {\n        progress.emit('put-error', a, b)\n        rs.destroy()\n        ws.destroy()\n        ws.removeListener('finish', cb)\n        cb(err)\n      }\n    }\n\n    function onfinish () {\n      progress.emit('put-end', a, b)\n      cb()\n    }\n  }\n\n  function ignoreError (cb) {\n    return function (err) {\n      if (err && err.code !== 'EEXIST') return cb(err)\n      cb(null)\n    }\n  }\n\n  function destroy () {\n    if (opts.watch) stopWatch()\n    pending = []\n    stopped = true\n  }\n}\n\nfunction parse (name) {\n  if (typeof name === 'string') return {name: path.resolve(name), fs: fs}\n  name.name = path.resolve(name.name)\n  if (!name.fs) name.fs = fs\n  return name\n}\n\nfunction defaultEquals (a, b, cb) {\n  if (!a.stat.isDirectory() && (a.stat.size !== b.stat.size)) return cb(null, false)\n  if (a.stat.mtime.getTime() > b.stat.mtime.getTime()) return cb(null, false)\n  cb(null, true)\n}\n","var os = require('os')\nvar fs = require('fs')\nvar path = require('path')\nvar Cache = require('ttl')\n\nvar isLinux = os.platform() === 'linux' // native recursive watching not supported here\nvar watchDirectory = isLinux ? watchFallback : watchRecursive\n\nmodule.exports = watch\n\nfunction watch (name, onchange) {\n  var clear = null\n  var stopped = false\n\n  fs.lstat(name, function (_, st) {\n    if (!st || stopped) {\n      stopped = true\n      return\n    }\n    clear = st.isDirectory() ? watchDirectory(name, onchange) : watchFile(name, onchange)\n  })\n\n  return function () {\n    if (stopped) return\n    stopped = true\n    if (clear) {\n      clear()\n    }\n  }\n}\n\nfunction watchFile (filename, onchange) {\n  var prev = null\n  var prevTime = 0\n\n  var w = fs.watch(filename, function () {\n    fs.lstat(filename, function (_, st) {\n      var now = Date.now()\n      if (now - prevTime > 2000 || !same(st, prev)) onchange(filename)\n      prevTime = now\n      prev = st\n    })\n  })\n\n  return function () {\n    w.close()\n  }\n}\n\nfunction watchRecursive (directory, onchange) {\n  var w = fs.watch(directory, {recursive: true}, function (change, filename) {\n    if (!filename) return // filename not always given (https://nodejs.org/api/fs.html#fs_filename_argument)\n    onchange(path.join(directory, filename))\n  })\n\n  return function () {\n    w.close()\n  }\n}\n\nfunction watchFallback (directory, onchange) {\n  var watching = {}\n  var loaded = false\n  var queued = []\n  var prevs = new Cache({ttl: 2e3, capacity: 30})\n\n  visit('.', function () {\n    loaded = true\n  })\n\n  return function () {\n    Object.keys(watching).forEach(function (dir) {\n      watching[dir].close()\n    })\n  }\n\n  function emit (name) {\n    queued.push(name)\n    if (queued.length === 1) update()\n  }\n\n  function update () {\n    var filename = queued[0]\n\n    fs.lstat(filename, function (err, st) {\n      var w = watching[filename]\n\n      if (err && w) {\n        w.close()\n        delete watching[filename]\n      }\n\n      var prevSt = prevs.get(filename)\n      if (!prevSt || !same(st, prevSt)) onchange(filename)\n      prevs.put(filename, st)\n\n      visit(path.relative(directory, filename), function () {\n        queued.shift()\n        if (queued.length) update()\n      })\n    })\n  }\n\n  function visit (next, cb) {\n    var dir = path.join(directory, next)\n\n    fs.lstat(dir, function (err, st) {\n      if (err || !st.isDirectory()) return cb()\n      if (watching[dir]) return cb()\n      if (loaded) emit(dir)\n\n      var w = fs.watch(dir, function (change, filename) {\n        filename = path.join(next, filename)\n        emit(path.join(directory, filename))\n      })\n\n      w.on('error', noop)\n      watching[dir] = w\n\n      fs.readdir(dir, function (err, list) {\n        if (err) return cb(err)\n\n        loop()\n\n        function loop () {\n          if (!list.length) return cb()\n          visit(path.join(next, list.shift()), loop)\n        }\n      })\n    })\n  }\n}\n\nfunction noop () {}\n\nfunction same (a, b) {\n  if (!a || !b) return false\n  return a.dev === b.dev &&\n    a.mode === b.mode &&\n    a.nlink === b.nlink &&\n    a.uid === b.uid &&\n    a.gid === b.gid &&\n    a.rdev === b.rdev &&\n    a.blksize === b.blksize &&\n    a.ino === b.ino &&\n    // a.size === b.size && DONT TEST - is a lying value\n    // a.blocks === b.blocks && DONT TEST - is a lying value\n    a.atime.getTime() === b.atime.getTime() &&\n    a.mtime.getTime() === b.mtime.getTime() &&\n    a.ctime.getTime() === b.ctime.getTime()\n}\n","var util = require('util');\nvar events = require('events');\n\nfunction Cache(opts) {\n  opts = opts || {};\n\n  this._store = {};\n  this._size = 0;\n  this._ttl = Number(opts.ttl);\n  this._capacity = Infinity;\n\n  this.setCapacity(opts.capacity);\n}\n\nutil.inherits(Cache, events.EventEmitter);\n\nCache.prototype.put = function (key, val, ttl) {\n  if (key === undefined || val === undefined) {\n    return;\n  }\n\n  if (!this._store[key] && this.size() >= this._capacity) {\n      this.emit('drop', key, val, ttl);\n      return;\n  }\n\n  ttl = ttl === undefined ? this._ttl : Number(ttl);\n\n  this.del(key);\n\n  this._store[key] = {\n    val: val,\n    expire: now() + ttl,\n    timeout: setTimeout(function() {\n      this.del(key);\n    }.bind(this), ttl)\n  };\n  this._store[key].timeout.unref();\n  this._size += 1;\n\n  this.emit('put', key, val, ttl);\n};\n\nCache.prototype.get = function (key) {\n  var rec = this._store[key];\n\n  if (rec) {\n    if (!(rec.expire && rec.expire > now())) {\n      this.del(key);\n      this.emit('miss', key);\n      rec = undefined;\n    } else {\n      this.emit('hit', key, rec.val);\n    }\n  } else {\n    this.emit('miss', key);\n  }\n\n  return rec && rec.val;\n};\n\nCache.prototype.del = function (key) {\n  if (this._store[key]) {\n    var val = this._store[key].val;\n\n    clearTimeout(this._store[key].timeout);\n    delete this._store[key];\n    this._size -= 1;\n    this.emit('del', key, val);\n\n    return val;\n  }\n};\n\nCache.prototype.clear = function () {\n  Object.keys(this._store).forEach(function(key) {\n    this.del(key);\n  }.bind(this));\n};\n\nCache.prototype.size = function (accurate) {\n  if (!accurate) {\n      return this._size;\n  }\n\n  return Object.keys(this._store).reduce(function(size, key) {\n    return size + (this.get(key) !== undefined ? 1 : 0);\n  }.bind(this), 0);\n};\n\nCache.prototype.setCapacity = function (capacity) {\n    if (typeof capacity === 'number' && capacity >= 0) {\n        this._capacity = capacity;\n    }\n};\n\nfunction now() {\n  return Date.now();\n}\n\nmodule.exports = Cache;\n","var stream = require('readable-stream')\nvar fs = require('fs')\nvar util = require('util')\n\nmodule.exports = ReadStream\n\nfunction ReadStream (fd, opts) {\n  if (!(this instanceof ReadStream)) return new ReadStream(fd, opts)\n  if (!opts) opts = {}\n\n  stream.Readable.call(this, {highWaterMark: opts.highWaterMark || 65536})\n\n  this.fd = fd\n  this.bytesRead = 0\n  this.destroyed = false\n\n  this._retry = opts.retry || 0\n  this._lastSuccess = true\n  this._tail = !!opts.tail\n  this._timeout = null\n\n  var self = this\n\n  this._callback = onread\n  this._reread = reread\n\n  function onread (err, bytes, buf) {\n    self._onread(err, bytes, buf)\n  }\n\n  function reread () {\n    self._read(65536)\n  }\n}\n\nutil.inherits(ReadStream, stream.Readable)\n\nReadStream.prototype.destroy = function (err) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  var self = this\n\n  fs.close(this.fd, function (closeErr) {\n    if (closeErr) err = closeErr\n    if (err) self.emit('error', err)\n    self.emit('close')\n  })\n}\n\nReadStream.prototype._read = function (size) {\n  if (this.destroyed) return\n  var buf = new Buffer(size)\n  fs.read(this.fd, buf, 0, buf.length, this.bytesRead, this._callback)\n}\n\nReadStream.prototype._onread = function (err, bytes, buf) {\n  if (this._retry && err && this._lastSuccess) {\n    err = null\n    bytes = 0\n  }\n\n  if (err) return this.destroy(err)\n\n  var lastSuccess = this._lastSuccess\n\n  this.bytesRead += bytes\n  this._lastSuccess = bytes > 0\n\n  if (bytes) {\n    this.push(buf.slice(0, bytes))\n    return\n  }\n\n  if ((this._retry && lastSuccess) || this._tail) {\n    this._timeout = setTimeout(this._reread, this._retry || 100)\n    return\n  }\n\n  this.push(null)\n  this.destroy()\n}\n","var assert = require('assert')\nvar fs = require('fs')\nvar path = require('path')\nvar match = require('anymatch')\nvar xtend = require('xtend')\n\nmodule.exports = ignore\n\nfunction ignore (dir, opts) {\n  assert.equal(typeof dir, 'string', 'dat-ignore: directory required')\n  opts = xtend({\n    datignorePath: path.join(dir, '.datignore')\n  }, opts)\n  dir = path.resolve(dir)\n\n  var allow = ['!**/.well-known/dat', '!.well-known/dat']\n  var ignoreMatches = opts.ignore // we end up with array of ignores here\n    ? Array.isArray(opts.ignore)\n      ? opts.ignore\n      : [opts.ignore]\n    : []\n\n  var defaultIgnore = [/^(?:\\/.*)?\\.dat(?:\\/.*)?$/, '.DS_Store', '**/.DS_Store'] // ignore .dat (and DS_Store)\n  var ignoreHidden = !(opts.ignoreHidden === false) ? [/(^\\.|\\/\\.).*/] : null // ignore hidden files anywhere\n  var datIgnore = !(opts.useDatIgnore === false) ? readDatIgnore() : null\n\n  // Add ignore options\n  ignoreMatches = ignoreMatches.concat(defaultIgnore) // always ignore .dat folder\n  if (datIgnore) ignoreMatches = ignoreMatches.concat(datIgnore) // add .datignore\n  if (ignoreHidden) ignoreMatches = ignoreMatches.concat(ignoreHidden) // ignore all hidden things\n  ignoreMatches = ignoreMatches.concat(allow)\n\n  // https://github.com/Kikobeats/micro-dev/blob/76ce110f0a126452256bc642cb1db4b7b2f14bf2/lib/listening.js#L30-L34\n  var ignored = ignoreMatches.reduce(function (acc, ignore) {\n    if (typeof ignore !== 'string') {\n      // globs\n      acc.push(ignore)\n      return acc\n    }\n    var file = path.resolve(dir, ignore)\n    if (isDirSync(file)) {\n      acc.push(`**/${path.basename(file)}`)\n      acc.push(`**/${path.basename(file)}/**`)\n    } else {\n      acc.push(ignore)\n    }\n    return acc\n  }, [])\n\n  return function (file) {\n    file = file.replace(dir, '') // remove dir so we do not ignore anything in that path\n    file = file.replace(/^\\//, '')\n    return match(ignored, file)\n  }\n\n  function isDirSync (path) {\n    return fs.existsSync(path) && fs.statSync(path).isDirectory()\n  }\n\n  function readDatIgnore () {\n    try {\n      var ignores = opts.datignore || fs.readFileSync(opts.datignorePath, 'utf8')\n      if (ignores && typeof opts.datignore !== 'string') ignores = ignores.toString()\n      return ignores\n        .trim()\n        .split(/[\\r\\n]+/g)\n        .filter(function (str) {\n          return !!str.trim()\n        })\n    } catch (e) {\n      return []\n    }\n  }\n}\n","'use strict';\n\nvar micromatch = require('micromatch');\nvar normalize = require('normalize-path');\nvar path = require('path'); // required for tests.\nvar arrify = function(a) { return a == null ? [] : (Array.isArray(a) ? a : [a]); };\n\nvar anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {\n  criteria = arrify(criteria);\n  value = arrify(value);\n  if (arguments.length === 1) {\n    return anymatch.bind(null, criteria.map(function(criterion) {\n      return typeof criterion === 'string' && criterion[0] !== '!' ?\n        micromatch.matcher(criterion) : criterion;\n    }));\n  }\n  startIndex = startIndex || 0;\n  var string = value[0];\n  var altString, altValue;\n  var matched = false;\n  var matchIndex = -1;\n  function testCriteria(criterion, index) {\n    var result;\n    switch (Object.prototype.toString.call(criterion)) {\n    case '[object String]':\n      result = string === criterion || altString && altString === criterion;\n      result = result || micromatch.isMatch(string, criterion);\n      break;\n    case '[object RegExp]':\n      result = criterion.test(string) || altString && criterion.test(altString);\n      break;\n    case '[object Function]':\n      result = criterion.apply(null, value);\n      result = result || altValue && criterion.apply(null, altValue);\n      break;\n    default:\n      result = false;\n    }\n    if (result) {\n      matchIndex = index + startIndex;\n    }\n    return result;\n  }\n  var crit = criteria;\n  var negGlobs = crit.reduce(function(arr, criterion, index) {\n    if (typeof criterion === 'string' && criterion[0] === '!') {\n      if (crit === criteria) {\n        // make a copy before modifying\n        crit = crit.slice();\n      }\n      crit[index] = null;\n      arr.push(criterion.substr(1));\n    }\n    return arr;\n  }, []);\n  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {\n    if (path.sep === '\\\\' && typeof string === 'string') {\n      altString = normalize(string);\n      altString = altString === string ? null : altString;\n      if (altString) altValue = [altString].concat(value.slice(1));\n    }\n    matched = crit.slice(startIndex, endIndex).some(testCriteria);\n  }\n  return returnIndex === true ? matchIndex : matched;\n};\n\nmodule.exports = anymatch;\n","/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar expand = require('./lib/expand');\nvar utils = require('./lib/utils');\n\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length, i = 0;\n  var omit = [], keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}\n\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}\n\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length, i = 0;\n  var patternMatchers = Array(len);\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function(fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length, i = 0;\n    var res = true;\n\n    fp = utils.unixify(fp, opts);\n    while (i < len) {\n      var fn = patternMatchers[i++];\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = (pattern !== '');\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n\n  fp = utils.unixify(fp, opts);\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts);\n\n  // pass in tokens to avoid parsing more than once\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  }\n\n  // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n  return /$^/;\n}\n\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\nfunction wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}\n\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n  return utils.cache(toRegex, glob, opts);\n}\n\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\nmicromatch.any       = any;\nmicromatch.braces    = micromatch.braceExpand = utils.braces;\nmicromatch.contains  = contains;\nmicromatch.expand    = expand;\nmicromatch.filter    = filter;\nmicromatch.isMatch   = isMatch;\nmicromatch.makeRe    = makeRe;\nmicromatch.match     = match;\nmicromatch.matcher   = matcher;\nmicromatch.matchKeys = matchKeys;\n\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;\n","/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar utils = require('./utils');\nvar Glob = require('./glob');\n\n/**\n * Expose `expand`\n */\n\nmodule.exports = expand;\n\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  // parse the glob pattern into tokens\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated;\n\n  // dotfile handling\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  }\n\n  // check for braces with a dotfile pattern\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  }\n\n  // if the leading character is a dot or a slash, escape it\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n\n  /**\n   * Extended globs\n   */\n\n  // expand braces, e.g `{1..5}`\n  glob.track('before braces');\n  if (tok.is.braces) {\n    glob.braces();\n  }\n  glob.track('after braces');\n\n  // expand extglobs, e.g `foo/!(a|b)`\n  glob.track('before extglob');\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n  glob.track('after extglob');\n\n  // expand brackets, e.g `[[:alpha:]]`\n  glob.track('before brackets');\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n  glob.track('after brackets');\n\n  // special patterns\n  glob._replace('[!', '[^');\n  glob._replace('(?', '(%~');\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n  glob._replace('/.', '/(?=.)\\\\.', true);\n\n  // windows drives\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true);\n\n  // negate slashes in exclusion ranges\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern);\n\n    // if the pattern has `**`\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n      glob._replace(/\\*{2,}/g, '**');\n\n      // 'foo/*'\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      }\n\n      // 'foo/**' or '{**,*}', but not 'foo**'\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    }\n\n    // ends with /*\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true);\n    // ends with *, no slashes\n    glob._replace(/(?!\\/)\\*$/, star, true);\n    // has 'n*.' (partial wildcard w/ file extension)\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true);\n    // has '*'\n    glob._replace('*', oneStar(opts.dot), true);\n    glob._replace('?.', '?\\\\.', true);\n    glob._replace('?:', '?:', true);\n\n    glob._replace(/\\?+/g, function(match) {\n      var len = match.length;\n      if (len === 1) {\n        return qmark;\n      }\n      return qmark + '{' + len + '}';\n    });\n\n    // escape '.abc' => '\\\\.abc'\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1');\n    // fix '[^\\\\\\\\/]'\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark);\n    // '///' => '\\/'\n    glob._replace(/\\/+/g, '\\\\/');\n    // '\\\\\\\\\\\\' => '\\\\'\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  }\n\n  // unescape previously escaped patterns\n  glob.unescape(glob.pattern);\n  glob._replace('__UNESC_STAR__', '*');\n\n  // escape dots that follow qmarks\n  glob._replace('?.', '?\\\\.');\n\n  // remove unnecessary slashes in character classes\n  glob._replace('[^\\\\/]', qmark);\n\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n\n  return glob;\n}\n\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function(match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n    return '[^' + inner + ']';\n  });\n}\n\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n  return str;\n}\n\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\nvar qmark       = '[^/]';\nvar star        = qmark + '*?';\nvar nodot       = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles    = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';\n\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);\n}\n\nfunction globstar(dotfile) {\n  if (dotfile) { return twoStarDot; }\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}\n","'use strict';\n\nvar win32 = process && process.platform === 'win32';\nvar path = require('path');\nvar fileRe = require('filename-regex');\nvar utils = module.exports;\n\n/**\n * Module dependencies\n */\n\nutils.diff = require('arr-diff');\nutils.unique = require('array-unique');\nutils.braces = require('braces');\nutils.brackets = require('expand-brackets');\nutils.extglob = require('extglob');\nutils.isExtglob = require('is-extglob');\nutils.isGlob = require('is-glob');\nutils.typeOf = require('kind-of');\nutils.normalize = require('normalize-path');\nutils.omit = require('object.omit');\nutils.parseGlob = require('parse-glob');\nutils.cache = require('regex-cache');\n\n/**\n * Get the filename of a filepath\n *\n * @param {String} `string`\n * @return {String}\n */\n\nutils.filename = function filename(fp) {\n  var seg = fp.match(fileRe());\n  return seg && seg[0];\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.isPath = function isPath(pattern, opts) {\n  opts = opts || {};\n  return function(fp) {\n    var unixified = utils.unixify(fp, opts);\n    if(opts.nocase){\n      return pattern.toLowerCase() === unixified.toLowerCase();\n    }\n    return pattern === unixified;\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.hasPath = function hasPath(pattern, opts) {\n  return function(fp) {\n    return utils.unixify(pattern, opts).indexOf(fp) !== -1;\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function matchPath(pattern, opts) {\n  var fn = (opts && opts.contains)\n    ? utils.hasPath(pattern, opts)\n    : utils.isPath(pattern, opts);\n  return fn;\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re`\n * @return {Boolean}\n */\n\nutils.hasFilename = function hasFilename(re) {\n  return function(fp) {\n    var name = utils.filename(fp);\n    return name && re.test(name);\n  };\n};\n\n/**\n * Coerce `val` to an array\n *\n * @param  {*} val\n * @return {Array}\n */\n\nutils.arrayify = function arrayify(val) {\n  return !Array.isArray(val)\n    ? [val]\n    : val;\n};\n\n/**\n * Normalize all slashes in a file path or glob pattern to\n * forward slashes.\n */\n\nutils.unixify = function unixify(fp, opts) {\n  if (opts && opts.unixify === false) return fp;\n  if (opts && opts.unixify === true || win32 || path.sep === '\\\\') {\n    return utils.normalize(fp, false);\n  }\n  if (opts && opts.unescape === true) {\n    return fp ? fp.toString().replace(/\\\\(\\w)/g, '$1') : '';\n  }\n  return fp;\n};\n\n/**\n * Escape/unescape utils\n */\n\nutils.escapePath = function escapePath(fp) {\n  return fp.replace(/[\\\\.]/g, '\\\\$&');\n};\n\nutils.unescapeGlob = function unescapeGlob(fp) {\n  return fp.replace(/[\\\\\"']/g, '');\n};\n\nutils.escapeRe = function escapeRe(str) {\n  return str.replace(/[-[\\\\$*+?.#^\\s{}(|)\\]]/g, '\\\\$&');\n};\n\n/**\n * Expose `utils`\n */\n\nmodule.exports = utils;\n","/*!\n * filename-regex <https://github.com/regexps/filename-regex>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert\n * Licensed under the MIT license.\n */\n\nmodule.exports = function filenameRegex() {\n  return /([^\\\\\\/]+)$/;\n};\n","/*!\n * arr-diff <https://github.com/jonschlinkert/arr-diff>\n *\n * Copyright (c) 2014 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\nvar flatten = require('arr-flatten');\nvar slice = [].slice;\n\n/**\n * Return the difference between the first array and\n * additional arrays.\n *\n * ```js\n * var diff = require('{%= name %}');\n *\n * var a = ['a', 'b', 'c', 'd'];\n * var b = ['b', 'c'];\n *\n * console.log(diff(a, b))\n * //=> ['a', 'd']\n * ```\n *\n * @param  {Array} `a`\n * @param  {Array} `b`\n * @return {Array}\n * @api public\n */\n\nfunction diff(arr, arrays) {\n  var argsLen = arguments.length;\n  var len = arr.length, i = -1;\n  var res = [], arrays;\n\n  if (argsLen === 1) {\n    return arr;\n  }\n\n  if (argsLen > 2) {\n    arrays = flatten(slice.call(arguments, 1));\n  }\n\n  while (++i < len) {\n    if (!~arrays.indexOf(arr[i])) {\n      res.push(arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Expose `diff`\n */\n\nmodule.exports = diff;\n","/*!\n * arr-flatten <https://github.com/jonschlinkert/arr-flatten>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function (arr) {\n  return flat(arr, []);\n};\n\nfunction flat(arr, res) {\n  var i = 0, cur;\n  var len = arr.length;\n  for (; i < len; i++) {\n    cur = arr[i];\n    Array.isArray(cur) ? flat(cur, res) : res.push(cur);\n  }\n  return res;\n}\n","/*!\n * array-unique <https://github.com/jonschlinkert/array-unique>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function unique(arr) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('array-unique expects an array.');\n  }\n\n  var len = arr.length;\n  var i = -1;\n\n  while (i++ < len) {\n    var j = i + 1;\n\n    for (; j < arr.length; ++j) {\n      if (arr[i] === arr[j]) {\n        arr.splice(j--, 1);\n      }\n    }\n  }\n  return arr;\n};\n","/*!\n * braces <https://github.com/jonschlinkert/braces>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar expand = require('expand-range');\nvar repeat = require('repeat-element');\nvar tokens = require('preserve');\n\n/**\n * Expose `braces`\n */\n\nmodule.exports = function(str, options) {\n  if (typeof str !== 'string') {\n    throw new Error('braces expects a string');\n  }\n  return braces(str, options);\n};\n\n/**\n * Expand `{foo,bar}` or `{1..5}` braces in the\n * given `string`.\n *\n * @param  {String} `str`\n * @param  {Array} `arr`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction braces(str, arr, options) {\n  if (str === '') {\n    return [];\n  }\n\n  if (!Array.isArray(arr)) {\n    options = arr;\n    arr = [];\n  }\n\n  var opts = options || {};\n  arr = arr || [];\n\n  if (typeof opts.nodupes === 'undefined') {\n    opts.nodupes = true;\n  }\n\n  var fn = opts.fn;\n  var es6;\n\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = {};\n  }\n\n  if (!(patternRe instanceof RegExp)) {\n    patternRe = patternRegex();\n  }\n\n  var matches = str.match(patternRe) || [];\n  var m = matches[0];\n\n  switch(m) {\n    case '\\\\,':\n      return escapeCommas(str, arr, opts);\n    case '\\\\.':\n      return escapeDots(str, arr, opts);\n    case '\\/.':\n      return escapePaths(str, arr, opts);\n    case ' ':\n      return splitWhitespace(str);\n    case '{,}':\n      return exponential(str, opts, braces);\n    case '{}':\n      return emptyBraces(str, arr, opts);\n    case '\\\\{':\n    case '\\\\}':\n      return escapeBraces(str, arr, opts);\n    case '${':\n      if (!/\\{[^{]+\\{/.test(str)) {\n        return arr.concat(str);\n      } else {\n        es6 = true;\n        str = tokens.before(str, es6Regex());\n      }\n  }\n\n  if (!(braceRe instanceof RegExp)) {\n    braceRe = braceRegex();\n  }\n\n  var match = braceRe.exec(str);\n  if (match == null) {\n    return [str];\n  }\n\n  var outter = match[1];\n  var inner = match[2];\n  if (inner === '') { return [str]; }\n\n  var segs, segsLength;\n\n  if (inner.indexOf('..') !== -1) {\n    segs = expand(inner, opts, fn) || inner.split(',');\n    segsLength = segs.length;\n\n  } else if (inner[0] === '\"' || inner[0] === '\\'') {\n    return arr.concat(str.split(/['\"]/).join(''));\n\n  } else {\n    segs = inner.split(',');\n    if (opts.makeRe) {\n      return braces(str.replace(outter, wrap(segs, '|')), opts);\n    }\n\n    segsLength = segs.length;\n    if (segsLength === 1 && opts.bash) {\n      segs[0] = wrap(segs[0], '\\\\');\n    }\n  }\n\n  var len = segs.length;\n  var i = 0, val;\n\n  while (len--) {\n    var path = segs[i++];\n\n    if (/(\\.[^.\\/])/.test(path)) {\n      if (segsLength > 1) {\n        return segs;\n      } else {\n        return [str];\n      }\n    }\n\n    val = splice(str, outter, path);\n\n    if (/\\{[^{}]+?\\}/.test(val)) {\n      arr = braces(val, arr, opts);\n    } else if (val !== '') {\n      if (opts.nodupes && arr.indexOf(val) !== -1) { continue; }\n      arr.push(es6 ? tokens.after(val) : val);\n    }\n  }\n\n  if (opts.strict) { return filter(arr, filterEmpty); }\n  return arr;\n}\n\n/**\n * Expand exponential ranges\n *\n *   `a{,}{,}` => ['a', 'a', 'a', 'a']\n */\n\nfunction exponential(str, options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = null;\n  }\n\n  var opts = options || {};\n  var esc = '__ESC_EXP__';\n  var exp = 0;\n  var res;\n\n  var parts = str.split('{,}');\n  if (opts.nodupes) {\n    return fn(parts.join(''), opts);\n  }\n\n  exp = parts.length - 1;\n  res = fn(parts.join(esc), opts);\n  var len = res.length;\n  var arr = [];\n  var i = 0;\n\n  while (len--) {\n    var ele = res[i++];\n    var idx = ele.indexOf(esc);\n\n    if (idx === -1) {\n      arr.push(ele);\n\n    } else {\n      ele = ele.split('__ESC_EXP__').join('');\n      if (!!ele && opts.nodupes !== false) {\n        arr.push(ele);\n\n      } else {\n        var num = Math.pow(2, exp);\n        arr.push.apply(arr, repeat(ele, num));\n      }\n    }\n  }\n  return arr;\n}\n\n/**\n * Wrap a value with parens, brackets or braces,\n * based on the given character/separator.\n *\n * @param  {String|Array} `val`\n * @param  {String} `ch`\n * @return {String}\n */\n\nfunction wrap(val, ch) {\n  if (ch === '|') {\n    return '(' + val.join(ch) + ')';\n  }\n  if (ch === ',') {\n    return '{' + val.join(ch) + '}';\n  }\n  if (ch === '-') {\n    return '[' + val.join(ch) + ']';\n  }\n  if (ch === '\\\\') {\n    return '\\\\{' + val + '\\\\}';\n  }\n}\n\n/**\n * Handle empty braces: `{}`\n */\n\nfunction emptyBraces(str, arr, opts) {\n  return braces(str.split('{}').join('\\\\{\\\\}'), arr, opts);\n}\n\n/**\n * Filter out empty-ish values\n */\n\nfunction filterEmpty(ele) {\n  return !!ele && ele !== '\\\\';\n}\n\n/**\n * Handle patterns with whitespace\n */\n\nfunction splitWhitespace(str) {\n  var segs = str.split(' ');\n  var len = segs.length;\n  var res = [];\n  var i = 0;\n\n  while (len--) {\n    res.push.apply(res, braces(segs[i++]));\n  }\n  return res;\n}\n\n/**\n * Handle escaped braces: `\\\\{foo,bar}`\n */\n\nfunction escapeBraces(str, arr, opts) {\n  if (!/\\{[^{]+\\{/.test(str)) {\n    return arr.concat(str.split('\\\\').join(''));\n  } else {\n    str = str.split('\\\\{').join('__LT_BRACE__');\n    str = str.split('\\\\}').join('__RT_BRACE__');\n    return map(braces(str, arr, opts), function(ele) {\n      ele = ele.split('__LT_BRACE__').join('{');\n      return ele.split('__RT_BRACE__').join('}');\n    });\n  }\n}\n\n/**\n * Handle escaped dots: `{1\\\\.2}`\n */\n\nfunction escapeDots(str, arr, opts) {\n  if (!/[^\\\\]\\..+\\\\\\./.test(str)) {\n    return arr.concat(str.split('\\\\').join(''));\n  } else {\n    str = str.split('\\\\.').join('__ESC_DOT__');\n    return map(braces(str, arr, opts), function(ele) {\n      return ele.split('__ESC_DOT__').join('.');\n    });\n  }\n}\n\n/**\n * Handle escaped dots: `{1\\\\.2}`\n */\n\nfunction escapePaths(str, arr, opts) {\n  str = str.split('\\/.').join('__ESC_PATH__');\n  return map(braces(str, arr, opts), function(ele) {\n    return ele.split('__ESC_PATH__').join('\\/.');\n  });\n}\n\n/**\n * Handle escaped commas: `{a\\\\,b}`\n */\n\nfunction escapeCommas(str, arr, opts) {\n  if (!/\\w,/.test(str)) {\n    return arr.concat(str.split('\\\\').join(''));\n  } else {\n    str = str.split('\\\\,').join('__ESC_COMMA__');\n    return map(braces(str, arr, opts), function(ele) {\n      return ele.split('__ESC_COMMA__').join(',');\n    });\n  }\n}\n\n/**\n * Regex for common patterns\n */\n\nfunction patternRegex() {\n  return /\\${|( (?=[{,}])|(?=[{,}]) )|{}|{,}|\\\\,(?=.*[{}])|\\/\\.(?=.*[{}])|\\\\\\.(?={)|\\\\{|\\\\}/;\n}\n\n/**\n * Braces regex.\n */\n\nfunction braceRegex() {\n  return /.*(\\\\?\\{([^}]+)\\})/;\n}\n\n/**\n * es6 delimiter regex.\n */\n\nfunction es6Regex() {\n  return /\\$\\{([^}]+)\\}/;\n}\n\nvar braceRe;\nvar patternRe;\n\n/**\n * Faster alternative to `String.replace()` when the\n * index of the token to be replaces can't be supplied\n */\n\nfunction splice(str, token, replacement) {\n  var i = str.indexOf(token);\n  return str.substr(0, i) + replacement\n    + str.substr(i + token.length);\n}\n\n/**\n * Fast array map\n */\n\nfunction map(arr, fn) {\n  if (arr == null) {\n    return [];\n  }\n\n  var len = arr.length;\n  var res = new Array(len);\n  var i = -1;\n\n  while (++i < len) {\n    res[i] = fn(arr[i], i, arr);\n  }\n\n  return res;\n}\n\n/**\n * Fast array filter\n */\n\nfunction filter(arr, cb) {\n  if (arr == null) return [];\n  if (typeof cb !== 'function') {\n    throw new TypeError('braces: filter expects a callback function.');\n  }\n\n  var len = arr.length;\n  var res = arr.slice();\n  var i = 0;\n\n  while (len--) {\n    if (!cb(arr[len], i++)) {\n      res.splice(len, 1);\n    }\n  }\n  return res;\n}\n","/*!\n * expand-range <https://github.com/jonschlinkert/expand-range>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nvar fill = require('fill-range');\n\nmodule.exports = function expandRange(str, options, fn) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expand-range expects a string.');\n  }\n\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n\n  if (typeof options === 'boolean') {\n    options = {};\n    options.makeRe = true;\n  }\n\n  // create arguments to pass to fill-range\n  var opts = options || {};\n  var args = str.split('..');\n  var len = args.length;\n  if (len > 3) { return str; }\n\n  // if only one argument, it can't expand so return it\n  if (len === 1) { return args; }\n\n  // if `true`, tell fill-range to regexify the string\n  if (typeof fn === 'boolean' && fn === true) {\n    opts.makeRe = true;\n  }\n\n  args.push(opts);\n  return fill.apply(null, args.concat(fn));\n};\n","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\nvar isNumber = require('is-number');\nvar randomize = require('randomatic');\nvar repeatStr = require('repeat-string');\nvar repeat = require('repeat-element');\n\n/**\n * Expose `fillRange`\n */\n\nmodule.exports = fillRange;\n\n/**\n * Return a range of numbers or letters.\n *\n * @param  {String} `a` Start of the range\n * @param  {String} `b` End of the range\n * @param  {String} `step` Increment or decrement to use.\n * @param  {Function} `fn` Custom function to modify each element in the range.\n * @return {Array}\n */\n\nfunction fillRange(a, b, step, options, fn) {\n  if (a == null || b == null) {\n    throw new Error('fill-range expects the first and second args to be strings.');\n  }\n\n  if (typeof step === 'function') {\n    fn = step; options = {}; step = null;\n  }\n\n  if (typeof options === 'function') {\n    fn = options; options = {};\n  }\n\n  if (isObject(step)) {\n    options = step; step = '';\n  }\n\n  var expand, regex = false, sep = '';\n  var opts = options || {};\n\n  if (typeof opts.silent === 'undefined') {\n    opts.silent = true;\n  }\n\n  step = step || opts.step;\n\n  // store a ref to unmodified arg\n  var origA = a, origB = b;\n\n  b = (b.toString() === '-0') ? 0 : b;\n\n  if (opts.optimize || opts.makeRe) {\n    step = step ? (step += '~') : step;\n    expand = true;\n    regex = true;\n    sep = '~';\n  }\n\n  // handle special step characters\n  if (typeof step === 'string') {\n    var match = stepRe().exec(step);\n\n    if (match) {\n      var i = match.index;\n      var m = match[0];\n\n      // repeat string\n      if (m === '+') {\n        return repeat(a, b);\n\n      // randomize a, `b` times\n      } else if (m === '?') {\n        return [randomize(a, b)];\n\n      // expand right, no regex reduction\n      } else if (m === '>') {\n        step = step.substr(0, i) + step.substr(i + 1);\n        expand = true;\n\n      // expand to an array, or if valid create a reduced\n      // string for a regex logic `or`\n      } else if (m === '|') {\n        step = step.substr(0, i) + step.substr(i + 1);\n        expand = true;\n        regex = true;\n        sep = m;\n\n      // expand to an array, or if valid create a reduced\n      // string for a regex range\n      } else if (m === '~') {\n        step = step.substr(0, i) + step.substr(i + 1);\n        expand = true;\n        regex = true;\n        sep = m;\n      }\n    } else if (!isNumber(step)) {\n      if (!opts.silent) {\n        throw new TypeError('fill-range: invalid step.');\n      }\n      return null;\n    }\n  }\n\n  if (/[.&*()[\\]^%$#@!]/.test(a) || /[.&*()[\\]^%$#@!]/.test(b)) {\n    if (!opts.silent) {\n      throw new RangeError('fill-range: invalid range arguments.');\n    }\n    return null;\n  }\n\n  // has neither a letter nor number, or has both letters and numbers\n  // this needs to be after the step logic\n  if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) {\n    if (!opts.silent) {\n      throw new RangeError('fill-range: invalid range arguments.');\n    }\n    return null;\n  }\n\n  // validate arguments\n  var isNumA = isNumber(zeros(a));\n  var isNumB = isNumber(zeros(b));\n\n  if ((!isNumA && isNumB) || (isNumA && !isNumB)) {\n    if (!opts.silent) {\n      throw new TypeError('fill-range: first range argument is incompatible with second.');\n    }\n    return null;\n  }\n\n  // by this point both are the same, so we\n  // can use A to check going forward.\n  var isNum = isNumA;\n  var num = formatStep(step);\n\n  // is the range alphabetical? or numeric?\n  if (isNum) {\n    // if numeric, coerce to an integer\n    a = +a; b = +b;\n  } else {\n    // otherwise, get the charCode to expand alpha ranges\n    a = a.charCodeAt(0);\n    b = b.charCodeAt(0);\n  }\n\n  // is the pattern descending?\n  var isDescending = a > b;\n\n  // don't create a character class if the args are < 0\n  if (a < 0 || b < 0) {\n    expand = false;\n    regex = false;\n  }\n\n  // detect padding\n  var padding = isPadded(origA, origB);\n  var res, pad, arr = [];\n  var ii = 0;\n\n  // character classes, ranges and logical `or`\n  if (regex) {\n    if (shouldExpand(a, b, num, isNum, padding, opts)) {\n      // make sure the correct separator is used\n      if (sep === '|' || sep === '~') {\n        sep = detectSeparator(a, b, num, isNum, isDescending);\n      }\n      return wrap([origA, origB], sep, opts);\n    }\n  }\n\n  while (isDescending ? (a >= b) : (a <= b)) {\n    if (padding && isNum) {\n      pad = padding(a);\n    }\n\n    // custom function\n    if (typeof fn === 'function') {\n      res = fn(a, isNum, pad, ii++);\n\n    // letters\n    } else if (!isNum) {\n      if (regex && isInvalidChar(a)) {\n        res = null;\n      } else {\n        res = String.fromCharCode(a);\n      }\n\n    // numbers\n    } else {\n      res = formatPadding(a, pad);\n    }\n\n    // add result to the array, filtering any nulled values\n    if (res !== null) arr.push(res);\n\n    // increment or decrement\n    if (isDescending) {\n      a -= num;\n    } else {\n      a += num;\n    }\n  }\n\n  // now that the array is expanded, we need to handle regex\n  // character classes, ranges or logical `or` that wasn't\n  // already handled before the loop\n  if ((regex || expand) && !opts.noexpand) {\n    // make sure the correct separator is used\n    if (sep === '|' || sep === '~') {\n      sep = detectSeparator(a, b, num, isNum, isDescending);\n    }\n    if (arr.length === 1 || a < 0 || b < 0) { return arr; }\n    return wrap(arr, sep, opts);\n  }\n\n  return arr;\n}\n\n/**\n * Wrap the string with the correct regex\n * syntax.\n */\n\nfunction wrap(arr, sep, opts) {\n  if (sep === '~') { sep = '-'; }\n  var str = arr.join(sep);\n  var pre = opts && opts.regexPrefix;\n\n  // regex logical `or`\n  if (sep === '|') {\n    str = pre ? pre + str : str;\n    str = '(' + str + ')';\n  }\n\n  // regex character class\n  if (sep === '-') {\n    str = (pre && pre === '^')\n      ? pre + str\n      : str;\n    str = '[' + str + ']';\n  }\n  return [str];\n}\n\n/**\n * Check for invalid characters\n */\n\nfunction isCharClass(a, b, step, isNum, isDescending) {\n  if (isDescending) { return false; }\n  if (isNum) { return a <= 9 && b <= 9; }\n  if (a < b) { return step === 1; }\n  return false;\n}\n\n/**\n * Detect the correct separator to use\n */\n\nfunction shouldExpand(a, b, num, isNum, padding, opts) {\n  if (isNum && (a > 9 || b > 9)) { return false; }\n  return !padding && num === 1 && a < b;\n}\n\n/**\n * Detect the correct separator to use\n */\n\nfunction detectSeparator(a, b, step, isNum, isDescending) {\n  var isChar = isCharClass(a, b, step, isNum, isDescending);\n  if (!isChar) {\n    return '|';\n  }\n  return '~';\n}\n\n/**\n * Correctly format the step based on type\n */\n\nfunction formatStep(step) {\n  return Math.abs(step >> 0) || 1;\n}\n\n/**\n * Format padding, taking leading `-` into account\n */\n\nfunction formatPadding(ch, pad) {\n  var res = pad ? pad + ch : ch;\n  if (pad && ch.toString().charAt(0) === '-') {\n    res = '-' + pad + ch.toString().substr(1);\n  }\n  return res.toString();\n}\n\n/**\n * Check for invalid characters\n */\n\nfunction isInvalidChar(str) {\n  var ch = toStr(str);\n  return ch === '\\\\'\n    || ch === '['\n    || ch === ']'\n    || ch === '^'\n    || ch === '('\n    || ch === ')'\n    || ch === '`';\n}\n\n/**\n * Convert to a string from a charCode\n */\n\nfunction toStr(ch) {\n  return String.fromCharCode(ch);\n}\n\n\n/**\n * Step regex\n */\n\nfunction stepRe() {\n  return /\\?|>|\\||\\+|\\~/g;\n}\n\n/**\n * Return true if `val` has either a letter\n * or a number\n */\n\nfunction noAlphaNum(val) {\n  return /[a-z0-9]/i.test(val);\n}\n\n/**\n * Return true if `val` has both a letter and\n * a number (invalid)\n */\n\nfunction hasBoth(val) {\n  return /[a-z][0-9]|[0-9][a-z]/i.test(val);\n}\n\n/**\n * Normalize zeros for checks\n */\n\nfunction zeros(val) {\n  if (/^-*0+$/.test(val.toString())) {\n    return '0';\n  }\n  return val;\n}\n\n/**\n * Return true if `val` has leading zeros,\n * or a similar valid pattern.\n */\n\nfunction hasZeros(val) {\n  return /[^.]\\.|^-*0+[0-9]/.test(val);\n}\n\n/**\n * If the string is padded, returns a curried function with\n * the a cached padding string, or `false` if no padding.\n *\n * @param  {*} `origA` String or number.\n * @return {String|Boolean}\n */\n\nfunction isPadded(origA, origB) {\n  if (hasZeros(origA) || hasZeros(origB)) {\n    var alen = length(origA);\n    var blen = length(origB);\n\n    var len = alen >= blen\n      ? alen\n      : blen;\n\n    return function (a) {\n      return repeatStr('0', len - length(a));\n    };\n  }\n  return false;\n}\n\n/**\n * Get the string length of `val`\n */\n\nfunction length(val) {\n  return val.toString().length;\n}\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isArray = require('isarray');\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && isArray(val) === false;\n};\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar typeOf = require('kind-of');\n\nmodule.exports = function isNumber(num) {\n  var type = typeOf(num);\n  if (type !== 'number' && type !== 'string') {\n    return false;\n  }\n  var n = +num;\n  return (n - n + 1) >= 0 && num !== '';\n};\n","var isBuffer = require('is-buffer');\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === 'undefined') {\n    return 'undefined';\n  }\n  if (val === null) {\n    return 'null';\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return 'boolean';\n  }\n  if (typeof val === 'string' || val instanceof String) {\n    return 'string';\n  }\n  if (typeof val === 'number' || val instanceof Number) {\n    return 'number';\n  }\n\n  // functions\n  if (typeof val === 'function' || val instanceof Function) {\n    return 'function';\n  }\n\n  // array\n  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {\n    return 'array';\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return 'regexp';\n  }\n  if (val instanceof Date) {\n    return 'date';\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === '[object RegExp]') {\n    return 'regexp';\n  }\n  if (type === '[object Date]') {\n    return 'date';\n  }\n  if (type === '[object Arguments]') {\n    return 'arguments';\n  }\n  if (type === '[object Error]') {\n    return 'error';\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return 'buffer';\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === '[object Set]') {\n    return 'set';\n  }\n  if (type === '[object WeakSet]') {\n    return 'weakset';\n  }\n  if (type === '[object Map]') {\n    return 'map';\n  }\n  if (type === '[object WeakMap]') {\n    return 'weakmap';\n  }\n  if (type === '[object Symbol]') {\n    return 'symbol';\n  }\n\n  // typed arrays\n  if (type === '[object Int8Array]') {\n    return 'int8array';\n  }\n  if (type === '[object Uint8Array]') {\n    return 'uint8array';\n  }\n  if (type === '[object Uint8ClampedArray]') {\n    return 'uint8clampedarray';\n  }\n  if (type === '[object Int16Array]') {\n    return 'int16array';\n  }\n  if (type === '[object Uint16Array]') {\n    return 'uint16array';\n  }\n  if (type === '[object Int32Array]') {\n    return 'int32array';\n  }\n  if (type === '[object Uint32Array]') {\n    return 'uint32array';\n  }\n  if (type === '[object Float32Array]') {\n    return 'float32array';\n  }\n  if (type === '[object Float64Array]') {\n    return 'float64array';\n  }\n\n  // must be a plain object\n  return 'object';\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","/*!\n * randomatic <https://github.com/jonschlinkert/randomatic>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isNumber = require('is-number');\nvar typeOf = require('kind-of');\nvar mathRandom = require('math-random');\n\n/**\n * Expose `randomatic`\n */\n\nmodule.exports = randomatic;\nmodule.exports.isCrypto = !!mathRandom.cryptographic;\n\n/**\n * Available mask characters\n */\n\nvar type = {\n  lower: 'abcdefghijklmnopqrstuvwxyz',\n  upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  number: '0123456789',\n  special: '~!@#$%^&()_+-={}[];\\',.'\n};\n\ntype.all = type.lower + type.upper + type.number + type.special;\n\n/**\n * Generate random character sequences of a specified `length`,\n * based on the given `pattern`.\n *\n * @param {String} `pattern` The pattern to use for generating the random string.\n * @param {String} `length` The length of the string to generate.\n * @param {String} `options`\n * @return {String}\n * @api public\n */\n\nfunction randomatic(pattern, length, options) {\n  if (typeof pattern === 'undefined') {\n    throw new Error('randomatic expects a string or number.');\n  }\n\n  var custom = false;\n  if (arguments.length === 1) {\n    if (typeof pattern === 'string') {\n      length = pattern.length;\n\n    } else if (isNumber(pattern)) {\n      options = {};\n      length = pattern;\n      pattern = '*';\n    }\n  }\n\n  if (typeOf(length) === 'object' && length.hasOwnProperty('chars')) {\n    options = length;\n    pattern = options.chars;\n    length = pattern.length;\n    custom = true;\n  }\n\n  var opts = options || {};\n  var mask = '';\n  var res = '';\n\n  // Characters to be used\n  if (pattern.indexOf('?') !== -1) mask += opts.chars;\n  if (pattern.indexOf('a') !== -1) mask += type.lower;\n  if (pattern.indexOf('A') !== -1) mask += type.upper;\n  if (pattern.indexOf('0') !== -1) mask += type.number;\n  if (pattern.indexOf('!') !== -1) mask += type.special;\n  if (pattern.indexOf('*') !== -1) mask += type.all;\n  if (custom) mask += pattern;\n\n  // Characters to exclude\n  if (opts.exclude) {\n    var exclude = typeOf(opts.exclude) === 'string' ? opts.exclude : opts.exclude.join('');\n    exclude = exclude.replace(new RegExp('[\\\\]]+', 'g'), '');\n    mask = mask.replace(new RegExp('[' + exclude + ']+', 'g'), '');\n    \n    if(opts.exclude.indexOf(']') !== -1) mask = mask.replace(new RegExp('[\\\\]]+', 'g'), '');\n  }\n\n  while (length--) {\n    res += mask.charAt(parseInt(mathRandom() * mask.length, 10));\n  }\n  return res;\n};\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isNumber(num) {\n  var type = typeof num;\n\n  if (type === 'string' || num instanceof String) {\n    // an empty string would be coerced to true with the below logic\n    if (!num.trim()) return false;\n  } else if (type !== 'number' && !(num instanceof Number)) {\n    return false;\n  }\n\n  return (num - num + 1) >= 0;\n};\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","var crypto = require('crypto')\nvar max = Math.pow(2, 32)\n\nmodule.exports = random\nmodule.exports.cryptographic = true\n\nfunction random () {\n  var buf = crypto\n    .randomBytes(4)\n    .readUInt32BE(0)\n\n  return buf / max\n}\n","/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n","/*!\n * repeat-element <https://github.com/jonschlinkert/repeat-element>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nmodule.exports = function repeat(ele, num) {\n  var arr = new Array(num);\n\n  for (var i = 0; i < num; i++) {\n    arr[i] = ele;\n  }\n\n  return arr;\n};\n","/*!\n * preserve <https://github.com/jonschlinkert/preserve>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n'use strict';\n\n/**\n * Replace tokens in `str` with a temporary, heuristic placeholder.\n *\n * ```js\n * tokens.before('{a\\\\,b}');\n * //=> '{__ID1__}'\n * ```\n *\n * @param  {String} `str`\n * @return {String} String with placeholders.\n * @api public\n */\n\nexports.before = function before(str, re) {\n  return str.replace(re, function (match) {\n    var id = randomize();\n    cache[id] = match;\n    return '__ID' + id + '__';\n  });\n};\n\n/**\n * Replace placeholders in `str` with original tokens.\n *\n * ```js\n * tokens.after('{__ID1__}');\n * //=> '{a\\\\,b}'\n * ```\n *\n * @param  {String} `str` String with placeholders\n * @return {String} `str` String with original tokens.\n * @api public\n */\n\nexports.after = function after(str) {\n  return str.replace(/__ID(.{5})__/g, function (_, id) {\n    return cache[id];\n  });\n};\n\nfunction randomize() {\n  return Math.random().toString().slice(2, 7);\n}\n\nvar cache = {};","/*!\n * expand-brackets <https://github.com/jonschlinkert/expand-brackets>\n *\n * Copyright (c) 2015 Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nvar isPosixBracket = require('is-posix-bracket');\n\n/**\n * POSIX character classes\n */\n\nvar POSIX = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E',\n  punct: '-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word:  'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9',\n};\n\n/**\n * Expose `brackets`\n */\n\nmodule.exports = brackets;\n\nfunction brackets(str) {\n  if (!isPosixBracket(str)) {\n    return str;\n  }\n\n  var negated = false;\n  if (str.indexOf('[^') !== -1) {\n    negated = true;\n    str = str.split('[^').join('[');\n  }\n  if (str.indexOf('[!') !== -1) {\n    negated = true;\n    str = str.split('[!').join('[');\n  }\n\n  var a = str.split('[');\n  var b = str.split(']');\n  var imbalanced = a.length !== b.length;\n\n  var parts = str.split(/(?::\\]\\[:|\\[?\\[:|:\\]\\]?)/);\n  var len = parts.length, i = 0;\n  var end = '', beg = '';\n  var res = [];\n\n  // start at the end (innermost) first\n  while (len--) {\n    var inner = parts[i++];\n    if (inner === '^[!' || inner === '[!') {\n      inner = '';\n      negated = true;\n    }\n\n    var prefix = negated ? '^' : '';\n    var ch = POSIX[inner];\n\n    if (ch) {\n      res.push('[' + prefix + ch + ']');\n    } else if (inner) {\n      if (/^\\[?\\w-\\w\\]?$/.test(inner)) {\n        if (i === parts.length) {\n          res.push('[' + prefix + inner);\n        } else if (i === 1) {\n          res.push(prefix + inner + ']');\n        } else {\n          res.push(prefix + inner);\n        }\n      } else {\n        if (i === 1) {\n          beg += inner;\n        } else if (i === parts.length) {\n          end += inner;\n        } else {\n          res.push('[' + prefix + inner + ']');\n        }\n      }\n    }\n  }\n\n  var result = res.join('|');\n  var rlen = res.length || 1;\n  if (rlen > 1) {\n    result = '(?:' + result + ')';\n    rlen = 1;\n  }\n  if (beg) {\n    rlen++;\n    if (beg.charAt(0) === '[') {\n      if (imbalanced) {\n        beg = '\\\\[' + beg.slice(1);\n      } else {\n        beg += ']';\n      }\n    }\n    result = beg + result;\n  }\n  if (end) {\n    rlen++;\n    if (end.slice(-1) === ']') {\n      if (imbalanced) {\n        end = end.slice(0, end.length - 1) + '\\\\]';\n      } else {\n        end = '[' + end;\n      }\n    }\n    result += end;\n  }\n\n  if (rlen > 1) {\n    result = result.split('][').join(']|[');\n    if (result.indexOf('|') !== -1 && !/\\(\\?/.test(result)) {\n      result = '(?:' + result + ')';\n    }\n  }\n\n  result = result.replace(/\\[+=|=\\]+/g, '\\\\b');\n  return result;\n}\n\nbrackets.makeRe = function(pattern) {\n  try {\n    return new RegExp(brackets(pattern));\n  } catch (err) {}\n};\n\nbrackets.isMatch = function(str, pattern) {\n  try {\n    return brackets.makeRe(pattern).test(str);\n  } catch (err) {\n    return false;\n  }\n};\n\nbrackets.match = function(arr, pattern) {\n  var len = arr.length, i = 0;\n  var res = arr.slice();\n\n  var re = brackets.makeRe(pattern);\n  while (i < len) {\n    var ele = arr[i++];\n    if (!re.test(ele)) {\n      continue;\n    }\n    res.splice(i, 1);\n  }\n  return res;\n};\n","/*!\n * is-posix-bracket <https://github.com/jonschlinkert/is-posix-bracket>\n *\n * Copyright (c) 2015-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isPosixBracket(str) {\n  return typeof str === 'string' && /\\[([:.=+])(?:[^\\[\\]]|)+\\1\\]/.test(str);\n};\n","/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\nvar re, cache = {};\n\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}\n\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n    case '@':\n      return '(?:' + inner + ')';\n    case '+':\n      return '(?:' + inner + ')+';\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*')\n    case '?':\n      return '(?:' + inner + '|)';\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n\n/**\n * extglob regex.\n */\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n\n/**\n * Negation regex\n */\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = ('(?:' + pattern + ')' + after);\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n  return new RegExp(prefix + pattern);\n}\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  return typeof str === 'string'\n    && /[@?!+*]\\(/.test(str);\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\n\nmodule.exports = function isGlob(str) {\n  return typeof str === 'string'\n    && (/[*!?{}(|)[\\]]/.test(str)\n     || isExtglob(str));\n};","/*!\n * object.omit <https://github.com/jonschlinkert/object.omit>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('is-extendable');\nvar forOwn = require('for-own');\n\nmodule.exports = function omit(obj, keys) {\n  if (!isObject(obj)) return {};\n\n  keys = [].concat.apply([], [].slice.call(arguments, 1));\n  var last = keys[keys.length - 1];\n  var res = {}, fn;\n\n  if (typeof last === 'function') {\n    fn = keys.pop();\n  }\n\n  var isFunction = typeof fn === 'function';\n  if (!keys.length && !isFunction) {\n    return obj;\n  }\n\n  forOwn(obj, function(value, key) {\n    if (keys.indexOf(key) === -1) {\n\n      if (!isFunction) {\n        res[key] = value;\n      } else if (fn(value, key, obj)) {\n        res[key] = value;\n      }\n    }\n  });\n  return res;\n};\n","/*!\n * is-extendable <https://github.com/jonschlinkert/is-extendable>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isExtendable(val) {\n  return typeof val !== 'undefined' && val !== null\n    && (typeof val === 'object' || typeof val === 'function');\n};\n","/*!\n * for-own <https://github.com/jonschlinkert/for-own>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar forIn = require('for-in');\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function forOwn(obj, fn, thisArg) {\n  forIn(obj, function(val, key) {\n    if (hasOwn.call(obj, key)) {\n      return fn.call(thisArg, obj[key], key, obj);\n    }\n  });\n};\n","/*!\n * for-in <https://github.com/jonschlinkert/for-in>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function forIn(obj, fn, thisArg) {\n  for (var key in obj) {\n    if (fn.call(thisArg, obj[key], key, obj) === false) {\n      break;\n    }\n  }\n};\n","/*!\n * parse-glob <https://github.com/jonschlinkert/parse-glob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isGlob = require('is-glob');\nvar findBase = require('glob-base');\nvar extglob = require('is-extglob');\nvar dotfile = require('is-dotfile');\n\n/**\n * Expose `cache`\n */\n\nvar cache = module.exports.cache = {};\n\n/**\n * Parse a glob pattern into tokens.\n *\n * When no paths or '**' are in the glob, we use a\n * different strategy for parsing the filename, since\n * file names can contain braces and other difficult\n * patterns. such as:\n *\n *  - `*.{a,b}`\n *  - `(**|*.js)`\n */\n\nmodule.exports = function parseGlob(glob) {\n  if (cache.hasOwnProperty(glob)) {\n    return cache[glob];\n  }\n\n  var tok = {};\n  tok.orig = glob;\n  tok.is = {};\n\n  // unescape dots and slashes in braces/brackets\n  glob = escape(glob);\n\n  var parsed = findBase(glob);\n  tok.is.glob = parsed.isGlob;\n\n  tok.glob = parsed.glob;\n  tok.base = parsed.base;\n  var segs = /([^\\/]*)$/.exec(glob);\n\n  tok.path = {};\n  tok.path.dirname = '';\n  tok.path.basename = segs[1] || '';\n  tok.path.dirname = glob.split(tok.path.basename).join('') || '';\n  var basename = (tok.path.basename || '').split('.') || '';\n  tok.path.filename = basename[0] || '';\n  tok.path.extname = basename.slice(1).join('.') || '';\n  tok.path.ext = '';\n\n  if (isGlob(tok.path.dirname) && !tok.path.basename) {\n    if (!/\\/$/.test(tok.glob)) {\n      tok.path.basename = tok.glob;\n    }\n    tok.path.dirname = tok.base;\n  }\n\n  if (glob.indexOf('/') === -1 && !tok.is.globstar) {\n    tok.path.dirname = '';\n    tok.path.basename = tok.orig;\n  }\n\n  var dot = tok.path.basename.indexOf('.');\n  if (dot !== -1) {\n    tok.path.filename = tok.path.basename.slice(0, dot);\n    tok.path.extname = tok.path.basename.slice(dot);\n  }\n\n  if (tok.path.extname.charAt(0) === '.') {\n    var exts = tok.path.extname.split('.');\n    tok.path.ext = exts[exts.length - 1];\n  }\n\n  // unescape dots and slashes in braces/brackets\n  tok.glob = unescape(tok.glob);\n  tok.path.dirname = unescape(tok.path.dirname);\n  tok.path.basename = unescape(tok.path.basename);\n  tok.path.filename = unescape(tok.path.filename);\n  tok.path.extname = unescape(tok.path.extname);\n\n  // Booleans\n  var is = (glob && tok.is.glob);\n  tok.is.negated  = glob && glob.charAt(0) === '!';\n  tok.is.extglob  = glob && extglob(glob);\n  tok.is.braces   = has(is, glob, '{');\n  tok.is.brackets = has(is, glob, '[:');\n  tok.is.globstar = has(is, glob, '**');\n  tok.is.dotfile  = dotfile(tok.path.basename) || dotfile(tok.path.filename);\n  tok.is.dotdir   = dotdir(tok.path.dirname);\n  return (cache[glob] = tok);\n}\n\n/**\n * Returns true if the glob matches dot-directories.\n *\n * @param  {Object} `tok` The tokens object\n * @param  {Object} `path` The path object\n * @return {Object}\n */\n\nfunction dotdir(base) {\n  if (base.indexOf('/.') !== -1) {\n    return true;\n  }\n  if (base.charAt(0) === '.' && base.charAt(1) !== '/') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if the pattern has the given `ch`aracter(s)\n *\n * @param  {Object} `glob` The glob pattern.\n * @param  {Object} `ch` The character to test for\n * @return {Object}\n */\n\nfunction has(is, glob, ch) {\n  return is && glob.indexOf(ch) !== -1;\n}\n\n/**\n * Escape/unescape utils\n */\n\nfunction escape(str) {\n  var re = /\\{([^{}]*?)}|\\(([^()]*?)\\)|\\[([^\\[\\]]*?)\\]/g;\n  return str.replace(re, function (outter, braces, parens, brackets) {\n    var inner = braces || parens || brackets;\n    if (!inner) { return outter; }\n    return outter.split(inner).join(esc(inner));\n  });\n}\n\nfunction esc(str) {\n  str = str.split('/').join('__SLASH__');\n  str = str.split('.').join('__DOT__');\n  return str;\n}\n\nfunction unescape(str) {\n  str = str.split('__SLASH__').join('/');\n  str = str.split('__DOT__').join('.');\n  return str;\n}\n","/*!\n * glob-base <https://github.com/jonschlinkert/glob-base>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar path = require('path');\nvar parent = require('glob-parent');\nvar isGlob = require('is-glob');\n\nmodule.exports = function globBase(pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob-base expects a string.');\n  }\n\n  var res = {};\n  res.base = parent(pattern);\n  res.isGlob = isGlob(pattern);\n\n  if (res.base !== '.') {\n    res.glob = pattern.substr(res.base.length);\n    if (res.glob.charAt(0) === '/') {\n      res.glob = res.glob.substr(1);\n    }\n  } else {\n    res.glob = pattern;\n  }\n\n  if (!res.isGlob) {\n    res.base = dirname(pattern);\n    res.glob = res.base !== '.'\n      ? pattern.substr(res.base.length)\n      : pattern;\n  }\n\n  if (res.glob.substr(0, 2) === './') {\n    res.glob = res.glob.substr(2);\n  }\n  if (res.glob.charAt(0) === '/') {\n    res.glob = res.glob.substr(1);\n  }\n  return res;\n};\n\nfunction dirname(glob) {\n  if (glob.slice(-1) === '/') return glob;\n  return path.dirname(glob);\n}\n","'use strict';\n\nvar path = require('path');\nvar isglob = require('is-glob');\n\nmodule.exports = function globParent(str) {\n\tstr += 'a'; // preserves full path in case of trailing path separator\n\tdo {str = path.dirname(str)} while (isglob(str));\n\treturn str;\n};\n","/*!\n * is-dotfile <https://github.com/jonschlinkert/is-dotfile>\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(str) {\n  if (str.charCodeAt(0) === 46 /* . */ && str.indexOf('/', 1) === -1) {\n    return true;\n  }\n  var slash = str.lastIndexOf('/');\n  return slash !== -1 ? str.charCodeAt(slash + 1) === 46  /* . */ : false;\n};\n","/*!\n * regex-cache <https://github.com/jonschlinkert/regex-cache>\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar equal = require('is-equal-shallow');\nvar basic = {};\nvar cache = {};\n\n/**\n * Expose `regexCache`\n */\n\nmodule.exports = regexCache;\n\n/**\n * Memoize the results of a call to the new RegExp constructor.\n *\n * @param  {Function} fn [description]\n * @param  {String} str [description]\n * @param  {Options} options [description]\n * @param  {Boolean} nocompare [description]\n * @return {RegExp}\n */\n\nfunction regexCache(fn, str, opts) {\n  var key = '_default_', regex, cached;\n\n  if (!str && !opts) {\n    if (typeof fn !== 'function') {\n      return fn;\n    }\n    return basic[key] || (basic[key] = fn(str));\n  }\n\n  var isString = typeof str === 'string';\n  if (isString) {\n    if (!opts) {\n      return basic[str] || (basic[str] = fn(str));\n    }\n    key = str;\n  } else {\n    opts = str;\n  }\n\n  cached = cache[key];\n  if (cached && equal(cached.opts, opts)) {\n    return cached.regex;\n  }\n\n  memo(key, opts, (regex = fn(str, opts)));\n  return regex;\n}\n\nfunction memo(key, opts, regex) {\n  cache[key] = {regex: regex, opts: opts};\n}\n\n/**\n * Expose `cache`\n */\n\nmodule.exports.cache = cache;\nmodule.exports.basic = basic;\n","/*!\n * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isPrimitive = require('is-primitive');\n\nmodule.exports = function isEqual(a, b) {\n  if (!a && !b) { return true; }\n  if (!a && b || a && !b) { return false; }\n\n  var numKeysA = 0, numKeysB = 0, key;\n  for (key in b) {\n    numKeysB++;\n    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {\n      return false;\n    }\n  }\n  for (key in a) {\n    numKeysA++;\n  }\n  return numKeysA === numKeysB;\n};\n","/*!\n * is-primitive <https://github.com/jonschlinkert/is-primitive>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n// see http://jsperf.com/testing-value-is-primitive/7\nmodule.exports = function isPrimitive(value) {\n  return value == null || (typeof value !== 'function' && typeof value !== 'object');\n};\n","'use strict';\n\nvar chars = require('./chars');\nvar utils = require('./utils');\n\n/**\n * Expose `Glob`\n */\n\nvar Glob = module.exports = function Glob(pattern, options) {\n  if (!(this instanceof Glob)) {\n    return new Glob(pattern, options);\n  }\n  this.options = options || {};\n  this.pattern = pattern;\n  this.history = [];\n  this.tokens = {};\n  this.init(pattern);\n};\n\n/**\n * Initialize defaults\n */\n\nGlob.prototype.init = function(pattern) {\n  this.orig = pattern;\n  this.negated = this.isNegated();\n  this.options.track = this.options.track || false;\n  this.options.makeRe = true;\n};\n\n/**\n * Push a change into `glob.history`. Useful\n * for debugging.\n */\n\nGlob.prototype.track = function(msg) {\n  if (this.options.track) {\n    this.history.push({msg: msg, pattern: this.pattern});\n  }\n};\n\n/**\n * Return true if `glob.pattern` was negated\n * with `!`, also remove the `!` from the pattern.\n *\n * @return {Boolean}\n */\n\nGlob.prototype.isNegated = function() {\n  if (this.pattern.charCodeAt(0) === 33 /* '!' */) {\n    this.pattern = this.pattern.slice(1);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Expand braces in the given glob pattern.\n *\n * We only need to use the [braces] lib when\n * patterns are nested.\n */\n\nGlob.prototype.braces = function() {\n  if (this.options.nobraces !== true && this.options.nobrace !== true) {\n    // naive/fast check for imbalanced characters\n    var a = this.pattern.match(/[\\{\\(\\[]/g);\n    var b = this.pattern.match(/[\\}\\)\\]]/g);\n\n    // if imbalanced, don't optimize the pattern\n    if (a && b && (a.length !== b.length)) {\n      this.options.makeRe = false;\n    }\n\n    // expand brace patterns and join the resulting array\n    var expanded = utils.braces(this.pattern, this.options);\n    this.pattern = expanded.join('|');\n  }\n};\n\n/**\n * Expand bracket expressions in `glob.pattern`\n */\n\nGlob.prototype.brackets = function() {\n  if (this.options.nobrackets !== true) {\n    this.pattern = utils.brackets(this.pattern);\n  }\n};\n\n/**\n * Expand bracket expressions in `glob.pattern`\n */\n\nGlob.prototype.extglob = function() {\n  if (this.options.noextglob === true) return;\n\n  if (utils.isExtglob(this.pattern)) {\n    this.pattern = utils.extglob(this.pattern, {escape: true});\n  }\n};\n\n/**\n * Parse the given pattern\n */\n\nGlob.prototype.parse = function(pattern) {\n  this.tokens = utils.parseGlob(pattern || this.pattern, true);\n  return this.tokens;\n};\n\n/**\n * Replace `a` with `b`. Also tracks the change before and\n * after each replacement. This is disabled by default, but\n * can be enabled by setting `options.track` to true.\n *\n * Also, when the pattern is a string, `.split()` is used,\n * because it's much faster than replace.\n *\n * @param  {RegExp|String} `a`\n * @param  {String} `b`\n * @param  {Boolean} `escape` When `true`, escapes `*` and `?` in the replacement.\n * @return {String}\n */\n\nGlob.prototype._replace = function(a, b, escape) {\n  this.track('before (find): \"' + a + '\" (replace with): \"' + b + '\"');\n  if (escape) b = esc(b);\n  if (a && b && typeof a === 'string') {\n    this.pattern = this.pattern.split(a).join(b);\n  } else {\n    this.pattern = this.pattern.replace(a, b);\n  }\n  this.track('after');\n};\n\n/**\n * Escape special characters in the given string.\n *\n * @param  {String} `str` Glob pattern\n * @return {String}\n */\n\nGlob.prototype.escape = function(str) {\n  this.track('before escape: ');\n  var re = /[\"\\\\](['\"]?[^\"'\\\\]['\"]?)/g;\n\n  this.pattern = str.replace(re, function($0, $1) {\n    var o = chars.ESC;\n    var ch = o && o[$1];\n    if (ch) {\n      return ch;\n    }\n    if (/[a-z]/i.test($0)) {\n      return $0.split('\\\\').join('');\n    }\n    return $0;\n  });\n\n  this.track('after escape: ');\n};\n\n/**\n * Unescape special characters in the given string.\n *\n * @param  {String} `str`\n * @return {String}\n */\n\nGlob.prototype.unescape = function(str) {\n  var re = /__([A-Z]+)_([A-Z]+)__/g;\n  this.pattern = str.replace(re, function($0, $1) {\n    return chars[$1][$0];\n  });\n  this.pattern = unesc(this.pattern);\n};\n\n/**\n * Escape/unescape utils\n */\n\nfunction esc(str) {\n  str = str.split('?').join('%~');\n  str = str.split('*').join('%%');\n  return str;\n}\n\nfunction unesc(str) {\n  str = str.split('%~').join('?');\n  str = str.split('%%').join('*');\n  return str;\n}\n","'use strict';\n\nvar chars = {}, unesc, temp;\n\nfunction reverse(object, prepender) {\n  return Object.keys(object).reduce(function(reversed, key) {\n    var newKey = prepender ? prepender + key : key; // Optionally prepend a string to key.\n    reversed[object[key]] = newKey; // Swap key and value.\n    return reversed; // Return the result.\n  }, {});\n}\n\n/**\n * Regex for common characters\n */\n\nchars.escapeRegex = {\n  '?': /\\?/g,\n  '@': /\\@/g,\n  '!': /\\!/g,\n  '+': /\\+/g,\n  '*': /\\*/g,\n  '(': /\\(/g,\n  ')': /\\)/g,\n  '[': /\\[/g,\n  ']': /\\]/g\n};\n\n/**\n * Escape characters\n */\n\nchars.ESC = {\n  '?': '__UNESC_QMRK__',\n  '@': '__UNESC_AMPE__',\n  '!': '__UNESC_EXCL__',\n  '+': '__UNESC_PLUS__',\n  '*': '__UNESC_STAR__',\n  ',': '__UNESC_COMMA__',\n  '(': '__UNESC_LTPAREN__',\n  ')': '__UNESC_RTPAREN__',\n  '[': '__UNESC_LTBRACK__',\n  ']': '__UNESC_RTBRACK__'\n};\n\n/**\n * Unescape characters\n */\n\nchars.UNESC = unesc || (unesc = reverse(chars.ESC, '\\\\'));\n\nchars.ESC_TEMP = {\n  '?': '__TEMP_QMRK__',\n  '@': '__TEMP_AMPE__',\n  '!': '__TEMP_EXCL__',\n  '*': '__TEMP_STAR__',\n  '+': '__TEMP_PLUS__',\n  ',': '__TEMP_COMMA__',\n  '(': '__TEMP_LTPAREN__',\n  ')': '__TEMP_RTPAREN__',\n  '[': '__TEMP_LTBRACK__',\n  ']': '__TEMP_RTBRACK__'\n};\n\nchars.TEMP = temp || (temp = reverse(chars.ESC_TEMP));\n\nmodule.exports = chars;\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","var tick = 1\nvar maxTick = 65535\nvar resolution = 4\nvar timer\nvar inc = function () {\n  tick = (tick + 1) & maxTick\n}\n\n\nmodule.exports = function (seconds) {\n  if (!timer) {\n    timer = setInterval(inc, (1000 / resolution) | 0)\n    if (timer.unref) timer.unref()\n  }\n\n  var size = resolution * (seconds || 5)\n  var buffer = [0]\n  var pointer = 1\n  var last = (tick - 1) & maxTick\n\n  return function (delta) {\n    var dist = (tick - last) & maxTick\n    if (dist > size) dist = size\n    last = tick\n\n    while (dist--) {\n      if (pointer === size) pointer = 0\n      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]\n      pointer++\n    }\n\n    if (delta) buffer[pointer - 1] += delta\n\n    var top = buffer[pointer - 1]\n    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]\n\n    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length\n  }\n}\n","var assert = require('assert')\nvar swarmDefaults = require('dat-swarm-defaults')\nvar disc = require('discovery-swarm')\n\nmodule.exports = function (archive, opts, cb) {\n  assert.ok(archive, 'dat-node: lib/network archive required')\n  assert.ok(opts, 'dat-node: lib/network opts required')\n\n  var DEFAULT_PORT = 3282\n  var swarmOpts = Object.assign({\n    hash: false,\n    stream: opts.stream\n  }, opts)\n  var swarm = disc(swarmDefaults(swarmOpts))\n  swarm.once('error', function () {\n    swarm.listen(0)\n  })\n  swarm.listen(opts.port || DEFAULT_PORT)\n  swarm.join(archive.discoveryKey, { announce: !(opts.upload === false) }, cb)\n  swarm.options = swarm._options\n  return swarm\n}\n","var DAT_DOMAIN = 'dat.local'\nvar DEFAULT_DISCOVERY = [\n  'discovery1.datprotocol.com',\n  'discovery2.datprotocol.com'\n]\nvar DEFAULT_BOOTSTRAP = [\n  'bootstrap1.datprotocol.com:6881',\n  'bootstrap2.datprotocol.com:6881',\n  'bootstrap3.datprotocol.com:6881',\n  'bootstrap4.datprotocol.com:6881'\n]\n\nvar DEFAULT_OPTS = {\n  dns: { server: DEFAULT_DISCOVERY, domain: DAT_DOMAIN },\n  dht: { bootstrap: DEFAULT_BOOTSTRAP }\n}\n\nmodule.exports = function (opts) {\n  return Object.assign({}, DEFAULT_OPTS, opts) // opts takes priority\n}\n","var discovery = require('discovery-channel')\nvar pump = require('pump')\nvar events = require('events')\nvar util = require('util')\nvar net = require('net')\nvar toBuffer = require('to-buffer')\nvar crypto = require('crypto')\nvar lpmessage = require('length-prefixed-message')\nvar connections = require('connections')\nvar debug = require('debug')('discovery-swarm')\n\ntry {\n  var utp = require('utp-native')\n} catch (err) {\n  // do nothing\n}\n\nvar PEER_SEEN = 1\nvar PEER_BANNED = 2\n\nvar HANDSHAKE_TIMEOUT = 5000\nvar CONNECTION_TIMEOUT = 3000\nvar RECONNECT_WAIT = [1000, 1000, 5000, 15000]\n// var DEFAULT_SIZE = 100 // TODO enable max connections\n\nmodule.exports = Swarm\n\nfunction Swarm (opts) {\n  if (!(this instanceof Swarm)) return new Swarm(opts)\n  if (!opts) opts = {}\n  events.EventEmitter.call(this)\n\n  var self = this\n\n  this.maxConnections = opts.maxConnections || 0\n  this.totalConnections = 0\n\n  this.connections = []\n  this.id = opts.id || crypto.randomBytes(32)\n  this.destroyed = false\n\n  this._stream = opts.stream\n  this._options = opts || {}\n  this._whitelist = opts.whitelist || []\n  this._discovery = null\n  this._tcp = opts.tcp === false ? null : net.createServer().on('connection', onconnection)\n  this._utp = opts.utp === false || !utp ? null : utp().on('connection', onconnection)\n  this._tcpConnections = this._tcp && connections(this._tcp)\n  this._adding = null\n  this._listening = false\n\n  this._peersIds = {}\n  this._peersSeen = {}\n  this._peersQueued = []\n\n  if (this._options.discovery !== false) {\n    this.on('listening', this._ondiscover)\n  }\n\n  function onconnection (connection) {\n    var type = this === self._tcp ? 'tcp' : 'utp'\n    debug('inbound connection type=%s ip=%s:%d', type, connection.remoteAddress, connection.remotePort)\n    connection.on('error', onerror)\n    self.totalConnections++\n    self._onconnection(connection, type, null)\n  }\n}\n\nutil.inherits(Swarm, events.EventEmitter)\n\nSwarm.prototype.close =\nSwarm.prototype.destroy = function (onclose) {\n  if (this.destroyed) return process.nextTick(onclose || noop)\n  if (onclose) this.once('close', onclose)\n  if (this._listening && this._adding) return this.once('listening', this.destroy)\n\n  this.destroyed = true\n  if (this._discovery) this._discovery.destroy()\n\n  var self = this\n  var missing = 0\n\n  if (this._utp) {\n    missing++\n    for (var i = 0; i < this._utp.connections.length; i++) {\n      this._utp.connections[i].destroy()\n    }\n  }\n\n  if (this._tcp) {\n    missing++\n    this._tcpConnections.destroy()\n  }\n\n  if (this._listening) {\n    if (this._tcp) this._tcp.close(onserverclose)\n    if (this._utp) this._utp.close(onserverclose)\n  } else {\n    this.emit('close')\n  }\n\n  function onserverclose () {\n    if (!--missing) self.emit('close')\n  }\n}\n\nSwarm.prototype.__defineGetter__('queued', function () {\n  return this._peersQueued.length\n})\n\nSwarm.prototype.__defineGetter__('connecting', function () {\n  return this.totalConnections - this.connections.length\n})\n\nSwarm.prototype.__defineGetter__('connected', function () {\n  return this.connections.length\n})\n\nSwarm.prototype.join = function (name, opts, cb) {\n  if (typeof opts === 'function') return this.join(name, {}, opts)\n  name = toBuffer(name)\n  if (!opts) opts = {}\n  if (typeof opts.announce === 'undefined') opts.announce = true\n\n  if (!this._listening && !this._adding) this._listenNext()\n\n  if (this._adding) {\n    this._adding.push({ name: name, opts: opts, cb: cb })\n  } else {\n    var port\n    if (opts.announce) port = this.address().port\n    this._discovery.join(name, port, { impliedPort: opts.announce && !!this._utp }, cb)\n  }\n}\n\nSwarm.prototype.leave = function (name) {\n  name = toBuffer(name)\n\n  if (this._adding) {\n    for (var i = 0; i < this._adding.length; i++) {\n      if (name.equals(this._adding[i].name)) {\n        this._adding.splice(i, 1)\n        return\n      }\n    }\n  } else {\n    this._discovery.leave(name, this.address() ? this.address().port : 0)\n  }\n}\n\nSwarm.prototype.addPeer = function (name, peer) {\n  peer = peerify(peer, toBuffer(name))\n  if (this._peersSeen[peer.id]) return\n  if (this._whitelist.length && this._whitelist.indexOf(peer.host) === -1) return\n  this._peersSeen[peer.id] = PEER_SEEN\n  this._peersQueued.push(peer)\n  this.emit('peer', peer)\n  this._kick()\n}\n\nSwarm.prototype.removePeer = function (name, peer) {\n  peer = peerify(peer, toBuffer(name))\n  this._peersSeen[peer.id] = PEER_BANNED\n  this.emit('peer-banned', peer, { reason: 'application' })\n}\n\nSwarm.prototype._dropPeer = function (peer) {\n  delete this._peersSeen[peer.id]\n  this.emit('drop', peer)\n}\n\nSwarm.prototype.address = function () {\n  return this._tcp ? this._tcp.address() : this._utp.address()\n}\n\nSwarm.prototype._ondiscover = function () {\n  var self = this\n  var joins = this._adding\n\n  if (this._options.dns !== false) {\n    if (!this._options.dns || this._options.dns === true) this._options.dns = {}\n    this._options.dns.socket = this._utp\n  }\n\n  if (this._options.dht !== false) {\n    if (!this._options.dht || this._options.dht === true) this._options.dht = {}\n    this._options.dht.socket = this._utp\n  }\n  this._discovery = discovery(this._options)\n  this._discovery.on('peer', onpeer)\n  this._discovery.on('whoami', onwhoami)\n  this._adding = null\n\n  if (!joins) return\n  for (var i = 0; i < joins.length; i++) this.join(joins[i].name, joins[i].opts, joins[i].cb)\n\n  function onwhoami (me) {\n    self._peersSeen[me.host + ':' + me.port] = PEER_BANNED\n  }\n\n  function onpeer (channel, peer) {\n    var id = peer.host + ':' + peer.port\n    var longId = id + '@' + (channel ? channel.toString('hex') : '')\n    if (self._whitelist.length && self._whitelist.indexOf(peer.host) === -1) {\n      self.emit('peer-rejected', peer, { reason: 'whitelist' })\n      return\n    }\n    var peerSeen = self._peersSeen[id] || self._peersSeen[longId]\n    if (peerSeen) {\n      self.emit('peer-rejected', peer, { reason: (peerSeen === PEER_BANNED) ? 'banned' : 'duplicate' })\n      return\n    }\n    self._peersSeen[longId] = PEER_SEEN\n    self._peersQueued.push(peerify(peer, channel))\n    self.emit('peer', peer)\n    self._kick()\n  }\n}\n\nSwarm.prototype._kick = function () {\n  if (this.maxConnections && this.totalConnections >= this.maxConnections) return\n  if (this.destroyed) return\n\n  var self = this\n  var connected = false\n  var didTimeOut = false\n  var next = this._peersQueued.shift()\n  while (next && this._peersSeen[next.id] === PEER_BANNED) {\n    next = this._peersQueued.shift()\n  }\n\n  if (!next) return\n\n  this.totalConnections++\n  this.emit('connecting', next)\n  debug('connecting %s retries=%d', next.id, next.retries)\n\n  var tcpSocket = null\n  var utpSocket = null\n  var tcpClosed = true\n  var utpClosed = true\n\n  if (this._tcp) {\n    tcpClosed = false\n    tcpSocket = net.connect(next.port, next.host)\n    tcpSocket.on('connect', onconnect)\n    tcpSocket.on('error', onerror)\n    tcpSocket.on('close', onclose)\n    this._tcpConnections.add(tcpSocket)\n  }\n\n  if (this._utp) {\n    utpClosed = false\n    utpSocket = this._utp.connect(next.port, next.host)\n    utpSocket.on('connect', ondeferredconnect)\n    utpSocket.on('error', onerror)\n    utpSocket.on('close', onclose)\n  }\n\n  var timeout = setTimeoutUnref(ontimeout, CONNECTION_TIMEOUT)\n\n  function ondeferredconnect () {\n    if (!self._tcp || tcpClosed) return onconnect.call(utpSocket)\n    setTimeout(function () {\n      if (!utpClosed && !connected) onconnect.call(utpSocket)\n    }, 500)\n  }\n\n  function ontimeout () {\n    debug('timeout %s', next.id)\n    didTimeOut = true\n    if (utpSocket) utpSocket.destroy()\n    if (tcpSocket) tcpSocket.destroy()\n  }\n\n  function cleanup () {\n    clearTimeout(timeout)\n    if (utpSocket) utpSocket.removeListener('close', onclose)\n    if (tcpSocket) tcpSocket.removeListener('close', onclose)\n  }\n\n  function onclose () {\n    if (this === utpSocket) utpClosed = true\n    if (this === tcpSocket) tcpClosed = true\n    if (tcpClosed && utpClosed) {\n      debug('onclose utp+tcp %s will-requeue=%d', next.id, !connected)\n      cleanup()\n      if (!connected) {\n        self.totalConnections--\n        self.emit('connect-failed', next, { timedout: didTimeOut })\n        self._requeue(next)\n      }\n    }\n  }\n\n  function onconnect () {\n    connected = true\n    cleanup()\n\n    var type = this === utpSocket ? 'utp' : 'tcp'\n    debug('onconnect %s type=%s', next.id, type)\n    if (type === 'utp' && tcpSocket) tcpSocket.destroy()\n    if (type === 'tcp' && utpSocket) utpSocket.destroy()\n\n    self._onconnection(this, type, next)\n  }\n}\n\nSwarm.prototype._requeue = function (peer) {\n  if (this.destroyed) return\n\n  var self = this\n  var wait = peer.retries >= RECONNECT_WAIT.length ? 0 : RECONNECT_WAIT[peer.retries++]\n  if (wait) setTimeoutUnref(requeue, wait)\n  else this._dropPeer(peer)\n\n  function requeue () {\n    self._peersQueued.push(peer)\n    self._kick()\n  }\n}\n\nvar connectionDebugIdCounter = 0\nSwarm.prototype._onconnection = function (connection, type, peer) {\n  var self = this\n  var idHex = this.id.toString('hex')\n  var remoteIdHex\n\n  // internal variables used for debugging\n  connection._debugId = ++connectionDebugIdCounter\n  connection._debugStartTime = Date.now()\n\n  var info = {\n    type: type,\n    initiator: !!peer,\n    id: null,\n    host: peer ? peer.host : connection.remoteAddress,\n    port: peer ? peer.port : connection.remotePort,\n    channel: peer ? peer.channel : null\n  }\n  this.emit('handshaking', connection, info)\n\n  connection.on('close', onclose)\n\n  if (this._stream) {\n    var wire = connection\n    connection = this._stream(info)\n    connection._debugId = wire._debugId\n    connection._debugStartTime = wire._debugStartTime\n    if (connection.id) idHex = connection.id.toString('hex')\n    connection.on('handshake', onhandshake)\n    if (this._options.connect) this._options.connect(connection, wire)\n    else pump(wire, connection, wire)\n  } else {\n    handshake(connection, this.id, onhandshake)\n  }\n\n  var wrap = {\n    info: info,\n    connection: connection\n  }\n\n  var timeout = setTimeoutUnref(ontimeout, HANDSHAKE_TIMEOUT)\n  if (this.destroyed) connection.destroy()\n\n  function ontimeout () {\n    self.emit('handshake-timeout', connection, info)\n    connection.destroy()\n  }\n\n  function onclose () {\n    clearTimeout(timeout)\n    self.totalConnections--\n    self.emit('connection-closed', connection, info)\n\n    var i = self.connections.indexOf(connection)\n    if (i > -1) {\n      var last = self.connections.pop()\n      if (last !== connection) self.connections[i] = last\n    }\n\n    if (remoteIdHex && self._peersIds[remoteIdHex] && self._peersIds[remoteIdHex].connection === connection) {\n      delete self._peersIds[remoteIdHex]\n      if (peer) self._requeue(peer)\n    }\n  }\n\n  function onhandshake (remoteId) {\n    if (!remoteId) remoteId = connection.remoteId\n    clearTimeout(timeout)\n    remoteIdHex = remoteId.toString('hex')\n\n    if (Buffer.isBuffer(connection.discoveryKey) || Buffer.isBuffer(connection.channel)) {\n      var suffix = '@' + (connection.discoveryKey || connection.channel).toString('hex')\n      remoteIdHex += suffix\n      idHex += suffix\n    }\n\n    if (peer) peer.retries = 0\n\n    if (idHex === remoteIdHex) {\n      if (peer) {\n        self._peersSeen[peer.id] = PEER_BANNED\n        self.emit('peer-banned', { peer: peer, reason: 'detected-self' })\n      }\n      connection.destroy()\n      return\n    }\n\n    var oldWrap = self._peersIds[remoteIdHex]\n    var old = oldWrap && oldWrap.connection\n    var oldType = oldWrap && oldWrap.info.type\n\n    if (old) {\n      debug('duplicate connections detected in handshake, dropping one')\n      if (!(oldType === 'utp' && type === 'tcp')) {\n        if ((peer && remoteIdHex < idHex) || (!peer && remoteIdHex > idHex) || (type === 'utp' && oldType === 'tcp')) {\n          self.emit('redundant-connection', connection, info)\n          connection.destroy()\n          return\n        }\n      }\n      self.emit('redundant-connection', old, info)\n      delete self._peersIds[remoteIdHex] // delete to not trigger re-queue\n      old.destroy()\n      old = null // help gc\n    }\n\n    self._peersIds[remoteIdHex] = wrap\n    self.connections.push(connection)\n    info.id = remoteId\n    self.emit('connection', connection, info)\n  }\n}\n\nSwarm.prototype._listenNext = function () {\n  var self = this\n  if (!this._adding) this._adding = []\n  process.nextTick(function () {\n    if (!self._listening) self.listen()\n  })\n}\n\nSwarm.prototype.listen = function (port, onlistening) {\n  if (this.destroyed) return\n  if (this._tcp && this._utp) return this._listenBoth(port, onlistening)\n  if (!port) port = 0\n  if (onlistening) this.once('listening', onlistening)\n\n  var self = this\n  var server = this._tcp || this._utp\n\n  if (!this._listening) {\n    this._listening = true\n    server.on('error', onerror)\n    server.on('listening', onlisten)\n  }\n\n  if (!this._adding) this._adding = []\n  server.listen(port)\n\n  function onerror (err) {\n    self.emit('error', err)\n  }\n\n  function onlisten () {\n    self.emit('listening')\n  }\n}\n\nSwarm.prototype._listenBoth = function (port, onlistening) {\n  if (typeof port === 'function') return this.listen(0, port)\n  if (!port) port = 0\n  if (onlistening) this.once('listening', onlistening)\n\n  var self = this\n\n  if (!this._adding) this._adding = []\n  this._listening = true\n\n  this._utp.on('error', onerror)\n  this._utp.on('listening', onutplisten)\n  this._tcp.on('listening', ontcplisten)\n  this._tcp.on('error', onerror)\n  this._tcp.listen(port)\n\n  function cleanup () {\n    self._utp.removeListener('error', onerror)\n    self._tcp.removeListener('error', onerror)\n    self._utp.removeListener('listening', onutplisten)\n    self._tcp.removeListener('listening', ontcplisten)\n  }\n\n  function onerror (err) {\n    cleanup()\n    self._tcp.close(function () {\n      if (!port) return self.listen() // retry\n      self.emit('error', err)\n    })\n  }\n\n  function onutplisten () {\n    cleanup()\n    self._utp.on('error', forward)\n    self._tcp.on('error', forward)\n    self.emit('listening')\n  }\n\n  function ontcplisten () {\n    self._utp.listen(this.address().port)\n  }\n\n  function forward (err) {\n    self.emit('error', err)\n  }\n}\n\nfunction handshake (socket, id, cb) {\n  lpmessage.write(socket, id)\n  lpmessage.read(socket, cb)\n}\n\nfunction onerror () {\n  this.destroy()\n}\n\nfunction peerify (peer, channel) {\n  if (typeof peer === 'number') peer = { port: peer }\n  if (!peer.host) peer.host = '127.0.0.1'\n  peer.id = peer.host + ':' + peer.port + '@' + (channel ? channel.toString('hex') : '')\n  peer.retries = 0\n  peer.channel = channel\n  return peer\n}\n\nfunction setTimeoutUnref (fn, time) {\n  var timeout = setTimeout(fn, time)\n  if (timeout.unref) timeout.unref()\n  return timeout\n}\n\nfunction noop () {}\n","var dns = require('dns-discovery')\nvar dht = require('bittorrent-dht')\nvar thunky = require('thunky')\nvar crypto = require('crypto')\nvar events = require('events')\nvar util = require('util')\nvar debug = require('debug')('discovery-channel')\nvar prettyHash = require('pretty-hash')\nvar bufferFrom = require('buffer-from')\n\nmodule.exports = Discovery\n\nfunction Discovery (opts) {\n  if (!(this instanceof Discovery)) return new Discovery(opts)\n  if (!opts) opts = {}\n\n  var self = this\n\n  this.dht = opts.dht === false ? null : dht(opts.dht)\n  this.dns = opts.dns === false ? null : dns(opts.dns)\n  if (this.dns) {\n    this.dns.on('peer', ondnspeer)\n    this.dns.on('error', onwarn) // warn for dns errors as they are non critical\n    this.dns.on('warn', onwarn)\n  }\n  if (this.dht) {\n    this.dht.on('peer', ondhtpeer)\n    this.dht.on('error', onerror)\n    this.dht.on('warn', onwarn)\n  }\n  this.destroyed = false\n  this.me = {host: null, port: 0}\n\n  this._hash = opts.hash || (opts.hash === false ? noHash : sha1) // bt dht uses sha1 so we'll default to that\n  this._dhtInterval = opts.dht && opts.dht.interval\n  this._dnsInterval = opts.dns && opts.dns.interval\n  this._announcing = {}\n  this._unhash = {}\n  this._whoami = this.dns && this.dns.whoami && thunky(whoami)\n  if (this._whoami) {\n    this._whoami()\n  } else {\n    debug('not running a whoami() - dns discovery was not enabled')\n  }\n\n  events.EventEmitter.call(this)\n\n  function whoami (cb) {\n    debug('whoami() started')\n    self.dns.whoami(function (_, me) {\n      if (me) {\n        debug('whoami() succeeded, I am:', me)\n        self.me = me\n        self.emit('whoami', me)\n      } else {\n        debug('whoami() failed')\n      }\n      cb()\n    })\n  }\n\n  function ondhtpeer (peer, infoHash, via) {\n    if (self.destroyed) return\n    var id = self._unhash[infoHash.toString('hex')]\n    if (via) debug('chan=%s dht discovery peer=%s:%s via=%s:%s', prettyHash(id), peer.host, peer.port, via.host || via.address, via.port)\n    else debug('chan=%s dht discovery peer=%s:%s', prettyHash(id), peer.host, peer.port)\n    if (id) self.emit('peer', id, peer, 'dht')\n  }\n\n  function ondnspeer (name, peer) {\n    if (self.destroyed) return\n    var id = self._unhash[name]\n    debug('chan=%s dns discovery peer=%s:%s', prettyHash(id), peer.host, peer.port)\n    if (id) self.emit('peer', id, peer, 'dns')\n  }\n\n  function onwarn (err) {\n    self.emit('warn', err)\n  }\n\n  function onerror (err) {\n    self.emit('error', err)\n  }\n}\n\nutil.inherits(Discovery, events.EventEmitter)\n\nDiscovery.prototype.join = function (id, port, opts, cb) {\n  if (this.destroyed) return\n  if (typeof id === 'string') id = bufferFrom(id)\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!opts) opts = {}\n  if (!cb) cb = function () {}\n\n  var announcing = typeof port === 'number'\n  if (!port) port = 0\n\n  var self = this\n  var name = id.toString('hex')\n  var key = name + ':' + port\n  var hash = this._hash(id)\n  if (hash.length > 20) hash = hash.slice(0, 20) // truncate hash so it fits in the dht\n  var hashHex = hash.toString('hex')\n  var dnsTimeout = null\n  var dhtTimeout = null\n  var destroyed = false\n  var publicPort = 0\n  var skipMulticast = false\n\n  if (this._announcing[key]) return\n\n  debug('chan=%s join()', prettyHash(id))\n\n  this._unhash[hashHex] = id\n  this._announcing[key] = {\n    id: id,\n    port: port,\n    destroy: destroy\n  }\n\n  var pending = 0\n  var firstQueryDone = false\n  var error = null\n  var succeded = false\n\n  if (!opts.impliedPort || !this._whoami) return ready()\n\n  // do a multicast only query immediately.\n  // multicast has no way to know if there will definitively be no replies\n  // so you can assume if you get no mdns responses by the time the first\n  // dns/dht responses come back then there are probably no mdns peers online\n  if (this.dns) {\n    if (announcing) this.dns.announce(hashHex, port, {server: false})\n    else this.dns.lookup(hashHex, {server: false})\n  }\n\n  this._whoami(function () {\n    if (destroyed) return\n    if (self.me && self.me.port) publicPort = self.me.port\n    // since we already did it, skip multicast on the first call\n    skipMulticast = true\n    ready()\n  })\n\n  function queryDone (err) {\n    if (firstQueryDone) return\n    if (err) error = err\n    else succeded = true\n    if (--pending > 0) return\n    firstQueryDone = true\n    self.emit('query-done', true)\n    cb(succeded ? null : error)\n  }\n\n  function ready () {\n    if (self.dns) {\n      pending++\n      dns()\n    }\n    if (self.dht) {\n      pending++\n      dht()\n    }\n  }\n\n  function destroy () {\n    destroyed = true\n    clearTimeout(dnsTimeout)\n    clearTimeout(dhtTimeout)\n    delete self._unhash[hashHex]\n    if (self.dns) self.dns.unannounce(hashHex, port)\n  }\n\n  function dns () {\n    if (announcing) {\n      debug('chan=%s dns %s', prettyHash(id), 'announce', {port: port, publicPort: publicPort, multicast: !skipMulticast})\n      self.dns.announce(hashHex, port, {publicPort: publicPort, multicast: !skipMulticast}, queryDone)\n    } else {\n      debug('chan=%s dns %s', prettyHash(id), 'lookup')\n      self.dns.lookup(hashHex, {multicast: !skipMulticast}, queryDone)\n    }\n    skipMulticast = false\n    dnsTimeout = setTimeout(dns, self._dnsInterval || (60 * 1000 + (Math.random() * 10 * 1000) | 0))\n  }\n\n  function dht () {\n    debug('chan=%s dht %s', prettyHash(id), announcing ? 'announce' : 'lookup')\n    if (announcing) self.dht.announce(hash, publicPort || port, queryDone)\n    else self.dht.lookup(hash, queryDone)\n    dhtTimeout = setTimeout(dht, self._dhtInterval || (10 * 60 * 1000 + (Math.random() * 5 * 60 * 1000) | 0))\n  }\n}\n\nDiscovery.prototype.leave = function (id, port) {\n  if (this.destroyed) return\n  if (!port) port = 0\n  if (typeof id === 'string') id = bufferFrom(id)\n  var key = id.toString('hex') + ':' + port\n  if (!this._announcing[key]) return\n  debug('chan=%s leave()', prettyHash(id))\n  this._announcing[key].destroy()\n  delete this._announcing[key]\n}\n\nDiscovery.prototype.update = function () {\n  var all = this.list()\n  for (var i = 0; i < all.length; i++) {\n    all[i].destroy()\n    this.leave(all[i].id, all[i].port)\n    this.join(all[i].id, all[i].port)\n  }\n}\n\nDiscovery.prototype.list = function () {\n  var keys = Object.keys(this._announcing)\n  var all = new Array(keys.length)\n  for (var i = 0; i < keys.length; i++) {\n    var ann = this._announcing[keys[i]]\n    all[i] = {id: ann.id, port: ann.port}\n  }\n  return all\n}\n\nDiscovery.prototype.destroy = function (cb) {\n  if (this.destroyed) {\n    if (cb) process.nextTick(cb)\n    return\n  }\n  this.destroyed = true\n  var keys = Object.keys(this._announcing)\n  for (var i = 0; i < keys.length; i++) this._announcing[keys[i]].destroy()\n  this._announcing = {}\n  if (cb) this.once('close', cb)\n  var self = this\n\n  if (!this.dht) ondhtdestroy()\n  else this.dht.destroy(ondhtdestroy)\n\n  function ondhtdestroy () {\n    if (!self.dns) ondnsdestroy()\n    else self.dns.destroy(ondnsdestroy)\n  }\n\n  function ondnsdestroy () {\n    self.emit('close')\n  }\n}\n\nfunction sha1 (id) {\n  return crypto.createHash('sha1').update(id).digest()\n}\n\nfunction noHash (id) {\n  if (typeof id === 'string') return bufferFrom(id)\n  return id\n}\n","var dns = require('dns-socket')\nvar events = require('events')\nvar util = require('util')\nvar crypto = require('crypto')\nvar network = require('network-address')\nvar multicast = require('multicast-dns')\nvar debug = require('debug')('dns-discovery')\nvar store = require('./store')\n\nvar IPv4 = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.\\d{1,3}$/\nvar PORT = /^\\d{1,5}$/\n\nconst TYPE_LOOKUP = 1\nconst TYPE_ANNOUNCE = 2\nconst TYPE_UNANNOUNCE = 3\n\nmodule.exports = DNSDiscovery\n\nfunction DNSDiscovery (opts) {\n  if (!(this instanceof DNSDiscovery)) return new DNSDiscovery(opts)\n  if (!opts) opts = {}\n\n  events.EventEmitter.call(this)\n\n  var self = this\n\n  this.socket = dns(opts)\n  this.servers = [].concat(opts.servers || opts.server || []).map(parseAddr)\n\n  this._sockets = []\n  this._onsocket(this.socket)\n\n  this.multicast = opts.multicast !== false ? (isMulticaster(opts.multicast) ? opts.multicast : multicast()) : null\n  if (this.multicast) {\n    this.multicast.on('query', onmulticastquery)\n    this.multicast.on('response', onmulticastresponse)\n    this.multicast.on('error', onerror)\n  }\n\n  this._loopback = !!opts.loopback\n  this._listening = false\n  this._id = crypto.randomBytes(32).toString('base64')\n  this._domain = opts.domain || 'dns-discovery.local'\n  this._pushDomain = 'push.' + this._domain\n  this._tokens = new Array(this.servers.length)\n  this._tokensAge = []\n  this._secrets = [\n    crypto.randomBytes(32),\n    crypto.randomBytes(32)\n  ]\n\n  while (this._tokensAge.length < this._tokens.length) this._tokensAge.push(0)\n\n  this._interval = setInterval(rotateSecrets, 5 * 60 * 1000)\n  if (this._interval.unref) this._interval.unref()\n\n  this._ttl = opts.ttl || 0\n  this._tick = 1\n\n  var push = opts.push || {}\n  if (!push.ttl) push.ttl = opts.ttl || 60\n  if (!push.limit) push.limit = opts.limit\n\n  this._domainStore = store(opts)\n  this._pushStore = store(push)\n\n  function rotateSecrets () {\n    self._rotateSecrets()\n  }\n\n  function onerror (err) {\n    debug('Error', err)\n    self.emit('error', err)\n  }\n\n  function onmulticastquery (message, rinfo) {\n    debug(\n      'MDNS query %s:%s %dQ %dA +%d',\n      rinfo.address, rinfo.port,\n      message.questions.length,\n      message.answers.length,\n      message.additionals.length\n    )\n    self.emit('traffic', 'in:multicastquery', {message: message, peer: rinfo})\n    self._onmulticastquery(message, rinfo.port, rinfo.address)\n  }\n\n  function onmulticastresponse (message, rinfo) {\n    debug(\n      'MDNS response %s:%s %dA +%d',\n      rinfo.address, rinfo.port,\n      message.answers.length,\n      message.additionals.length\n    )\n    self.emit('traffic', 'in:multicastresponse', {message: message, peer: rinfo})\n    self._onmulticastresponse(message, rinfo.port, rinfo.address)\n  }\n}\n\nutil.inherits(DNSDiscovery, events.EventEmitter)\n\nDNSDiscovery.prototype.toJSON = function () {\n  return this._domainStore.toJSON()\n}\n\nDNSDiscovery.prototype._onsocket = function (socket) {\n  var self = this\n\n  this._sockets.push(socket)\n  socket.on('query', onquery)\n  socket.on('error', onerror)\n\n  function onerror (err) {\n    debug('Error', err)\n    self.emit('error', err)\n  }\n\n  function onquery (message, port, host) {\n    debug(\n      'DNS query %s:%s %dQ %dA +%d',\n      host, port,\n      message.questions.length,\n      message.answers.length,\n      message.additionals.length\n    )\n    self.emit('traffic', 'in:query', {message: message, peer: {port: port, host: host}})\n    self._onquery(message, port, host, socket)\n  }\n}\n\nDNSDiscovery.prototype._rotateSecrets = function () {\n  if (this._listening) {\n    debug('Rotating secrets')\n    this._secrets.shift()\n    this._secrets.push(crypto.randomBytes(32))\n  }\n\n  for (var i = 0; i < this._tokensAge.length; i++) {\n    if (this._tokensAge[i] < this._tick) {\n      this._tokens[i] = null\n      this._tokensAge[i] = 0\n    }\n  }\n\n  this.emit('secrets-rotated')\n  this._tick++\n}\n\nDNSDiscovery.prototype._onmulticastquery = function (query, port, host) {\n  var reply = {questions: query.questions, answers: []}\n  var i = 0\n\n  for (i = 0; i < query.questions.length; i++) {\n    this._onquestion(query.questions[i], port, host, reply.answers, true)\n  }\n  for (i = 0; i < query.answers.length; i++) {\n    this._onanswer(query.answers[i], port, host, null)\n  }\n  for (i = 0; i < query.additionals.length; i++) {\n    this._onanswer(query.additionals[i], port, host, null)\n  }\n\n  if (reply.answers.length) {\n    this.emit('traffic', 'out:multicastresponse', {message: reply})\n    this.multicast.response(reply, {port: port})\n  }\n}\n\nDNSDiscovery.prototype._onmulticastresponse = function (response, port, host) {\n  var i = 0\n\n  for (i = 0; i < response.answers.length; i++) {\n    this._onanswer(response.answers[i], port, host, null)\n  }\n  for (i = 0; i < response.additionals.length; i++) {\n    this._onanswer(response.additionals[i], port, host, null)\n  }\n}\n\nDNSDiscovery.prototype._onanswer = function (answer, port, host, socket) {\n  var domain = parseDomain(answer.name)\n  var id = parseId(answer.name, domain)\n  if (!id) {\n    debug('Invalid ID in answer, discarding', { name: answer.name, domain: domain, host: host, port: port })\n    return\n  }\n\n  if (answer.type === 'SRV') {\n    if (!IPv4.test(answer.data.target)) return\n    var peer = {\n      port: answer.data.port || port,\n      host: answer.data.target === '0.0.0.0' ? host : answer.data.target\n    }\n    debug('Announce received via SRV', id, peer.host + ':' + 'peer.port')\n    this.emit('peer', id, peer)\n    return\n  }\n\n  if (answer.type === 'TXT') {\n    try {\n      var data = decodeTxt(answer.data)\n    } catch (err) {\n      return\n    }\n\n    var tokenMatch = data.token === hash(this._secrets[1], host)\n\n    if (!tokenMatch || this._loopback) {\n      // not an echo\n      this._parsePeers(id, data, host)\n    }\n\n    if (!this._listening) {\n      return\n    }\n\n    // We are in server mode now. Add the record to the cache\n\n    if (!tokenMatch) {\n      // check if old token matches\n      if (data.token !== hash(this._secrets[0], host)) {\n        debug('Invalid token in TXT answer, discarding')\n        return\n      }\n    }\n\n    if (PORT.test(data.announce)) {\n      var announce = Number(data.announce) || port\n      debug('Announce received via TXT', id, host + ':' + announce)\n      this.emit('peer', id, {port: announce, host: host})\n      if (this._domainStore.add(id, announce, host) && socket) {\n        this._push(id, announce, host, socket)\n      }\n    }\n\n    if (PORT.test(data.unannounce)) {\n      var unannounce = Number(data.unannounce) || port\n      this._domainStore.remove(id, unannounce, host)\n      debug('Un-announce received via TXT', id, host + ':' + unannounce)\n    }\n\n    if (data.subscribe) {\n      debug('Subscribe-to-push received via TXT', id, host + ':' + port)\n      this._pushStore.add(id, port, host)\n    } else {\n      debug('Unsubscribe-from-push received via TXT', id, host + ':' + port)\n      this._pushStore.remove(id, port, host)\n    }\n  }\n}\n\nDNSDiscovery.prototype._push = function (id, port, host, socket) {\n  var subs = this._pushStore.get(id, 16)\n  var query = {\n    additionals: [{\n      type: 'SRV',\n      name: id + '.' + this._domain,\n      ttl: this._ttl,\n      data: {\n        port: port,\n        target: host\n      }\n    }]\n  }\n\n  if (subs.length) debug('Pushing announcement to', subs.length, 'subscribers')\n  for (var i = 0; i < subs.length; i++) {\n    var peer = subs[i]\n    var tid = socket.query(query, peer.port, peer.host)\n    socket.setRetries(tid, 2)\n  }\n}\n\nDNSDiscovery.prototype._onquestion = function (query, port, host, answers, multicast) {\n  var domain = parseDomain(query.name)\n\n  if (domain !== this._domain) return\n\n  if (query.type === 'TXT' && domain === query.name) {\n    debug('Replying state-info via TXT to %s:%s', host, port)\n    answers.push({\n      type: 'TXT',\n      name: query.name,\n      ttl: this._ttl,\n      data: encodeTxt({\n        token: hash(this._secrets[1], host),\n        host: host,\n        port: '' + port\n      })\n    })\n    return\n  }\n\n  var id = parseId(query.name, domain)\n  if (!id) {\n    debug('Invalid ID in question, discarding', { name: query.name, domain: domain, host: host, port: port })\n    return\n  }\n\n  if (query.type === 'TXT') {\n    var buf = toBuffer(this._domainStore.get(id, 100))\n    var token = hash(this._secrets[1], host)\n    if (multicast && !buf.length) return // just an optimization\n    debug('Replying known peers via TXT to', host + ':' + port)\n    answers.push({\n      type: 'TXT',\n      name: query.name,\n      ttl: this._ttl,\n      data: encodeTxt(buf.length ? {\n        token: token,\n        peers: buf.toString('base64')\n      } : {\n        token: token\n      })\n    })\n    return\n  }\n\n  var peers = this._domainStore.get(id, 10)\n  debug('Replying announce via', query.type, ' to', host + ':' + port)\n\n  for (var i = 0; i < peers.length; i++) {\n    var peer = peers[i]\n\n    if (query.type === 'A') {\n      answers.push({\n        type: 'A',\n        name: query.name,\n        ttl: this._ttl,\n        data: peer.host === '0.0.0.0' ? network() : peer.host\n      })\n    }\n    if (query.type === 'SRV') {\n      answers.push({\n        type: 'SRV',\n        name: query.name,\n        ttl: this._ttl,\n        data: {\n          port: peer.port,\n          target: peer.host\n        }\n      })\n    }\n  }\n}\n\nDNSDiscovery.prototype._onquery = function (query, port, host, socket) {\n  var reply = {questions: query.questions, answers: []}\n  var i = 0\n\n  for (i = 0; i < query.questions.length; i++) {\n    this._onquestion(query.questions[i], port, host, reply.answers)\n  }\n  for (i = 0; i < query.answers.length; i++) {\n    this._onanswer(query.answers[i], port, host, socket)\n  }\n  for (i = 0; i < query.additionals.length; i++) {\n    this._onanswer(query.additionals[i], port, host, socket)\n  }\n  socket.response(query, reply, port, host)\n  // note: emit 'traffic' after calling .response() because socket.response() modifies `reply`\n  this.emit('traffic', 'out:response', {message: reply, peer: {port: port, host: host}})\n}\n\nDNSDiscovery.prototype._probeAndSend = function (type, i, id, port, cb) {\n  var self = this\n  this._probe(i, 0, function (err) {\n    if (err) return cb(err)\n    self._send(type, i, id, port, cb)\n  })\n}\n\nDNSDiscovery.prototype._send = function (type, i, id, port, cb) {\n  var s = this.servers[i]\n  var token = this._tokens[i]\n  var data = null\n\n  switch (type) {\n    case TYPE_LOOKUP:\n      data = {subscribe: true, token: token}\n      break\n\n    case TYPE_ANNOUNCE:\n      data = {subscribe: true, token: token, announce: '' + port}\n      break\n\n    case TYPE_UNANNOUNCE:\n      data = {token: token, unannounce: '' + port}\n      break\n  }\n\n  var query = {\n    index: i,\n    questions: [{\n      type: 'TXT',\n      name: id + '.' + this._domain\n    }],\n    additionals: [{\n      type: 'TXT',\n      name: id + '.' + this._domain,\n      ttl: this._ttl,\n      data: encodeTxt(data)\n    }]\n  }\n\n  this.socket.query(query, s.port, s.host, cb)\n  this.emit('traffic', 'out:query', {message: query, peer: s})\n}\n\nDNSDiscovery.prototype.lookup = function (id, opts, cb) {\n  debug('lookup()', id)\n  this._visit(TYPE_LOOKUP, id, 0, opts, cb)\n}\n\nDNSDiscovery.prototype.announce = function (id, port, opts, cb) {\n  debug('announce()', id)\n  this._visit(TYPE_ANNOUNCE, id, port, opts, cb)\n}\n\nDNSDiscovery.prototype.unannounce = function (id, port, opts, cb) {\n  debug('unannounce()', id)\n  this._visit(TYPE_UNANNOUNCE, id, port, opts, cb)\n}\n\nDNSDiscovery.prototype._visit = function (type, id, port, opts, cb) {\n  if (typeof opts === 'function') return this._visit(type, id, port, null, opts)\n  if (typeof port === 'function') return this._visit(type, id, 0, port)\n  if (!cb) cb = noop\n  if (Buffer.isBuffer(id)) id = id.toString('hex')\n  if (!opts) opts = {}\n\n  var self = this\n  var missing = this.servers.length\n  var success = false\n\n  if (opts.server !== false) {\n    var publicPort = opts.publicPort || (opts.impliedPort ? 0 : port)\n    for (var i = 0; i < this.servers.length; i++) {\n      if (this._tokens[i]) this._send(type, i, id, publicPort, done)\n      else this._probeAndSend(type, i, id, publicPort, done)\n    }\n  }\n\n  if (type === TYPE_ANNOUNCE) this._domainStore.add(id, port, '0.0.0.0')\n  if (type === TYPE_UNANNOUNCE) this._domainStore.remove(id, port, '0.0.0.0')\n\n  if (opts.multicast !== false && this.multicast) {\n    if (type !== TYPE_UNANNOUNCE) {\n      missing++\n      var message = {\n        questions: [{\n          type: 'TXT',\n          name: id + '.' + this._domain\n        }]\n      }\n      this.multicast.query(message, done)\n      this.emit('traffic', 'out:multicastquery', {message: message})\n    }\n  }\n\n  if (!missing) {\n    missing++\n    process.nextTick(done)\n  }\n\n  function done (_, res, q, _port, _host) {\n    if (res) {\n      success = true\n      self.emit('traffic', 'in:response', {message: res, peer: {host: _host, port: _port}})\n      try {\n        var data = res.answers.length && decodeTxt(res.answers[0].data)\n      } catch (err) {\n        // do nothing\n      }\n      if (data) self._parseData(id, data, q.index, _host)\n      if (type === TYPE_ANNOUNCE) self.emit('announced', id, {port: port})\n      if (type === TYPE_UNANNOUNCE) self.emit('unannounced', id, {port: port})\n    }\n\n    if (!--missing) cb(success ? null : new Error('Query failed'))\n  }\n}\n\nDNSDiscovery.prototype._parsePeers = function (id, data, host) {\n  try {\n    var buf = Buffer.from(data.peers, 'base64')\n  } catch (err) {\n    return\n  }\n\n  for (var i = 0; i < buf.length; i += 6) {\n    var peer = decodePeer(buf, i)\n    if (!peer) continue\n    if (peer.host === '0.0.0.0') peer.host = host\n    this.emit('peer', id, peer)\n  }\n}\n\nDNSDiscovery.prototype._parseData = function (id, data, index, host) {\n  if (data.token) {\n    this._tokens[index] = data.token\n    this._tokensAge[index] = this._tick\n  }\n  if (data && data.peers && id) this._parsePeers(id, data, host)\n}\n\nDNSDiscovery.prototype.whoami = function (cb) {\n  var missing = this.servers.length\n  var prevData = null\n  var prevHost = null\n  var called = false\n\n  if (this.servers.length) {\n    for (var i = 0; i < this.servers.length; i++) this._probe(i, 2, done)\n  } else {\n    debug('whoami() failed - no servers to ping')\n    missing = 1\n    process.nextTick(done)\n  }\n\n  function done (_, data, port, host) {\n    if (data) {\n      if (!called && IPv4.test(data.host) && PORT.test(data.port)) {\n        if (prevHost && prevHost !== host) {\n          called = true\n          if (prevData.host === data.host && prevData.port === data.port) {\n            cb(null, {port: Number(data.port), host: data.host})\n          } else if (prevData.host === data.host) {\n            cb(null, {port: 0, host: data.host})\n          } else {\n            cb(new Error('Inconsistent remote port/host'))\n          }\n        }\n        prevData = data\n        prevHost = host\n      }\n    }\n\n    if (--missing || called) {\n      if (!called) {\n        debug('whoami() probe got response; waiting for a confirmation from %d other(s)', missing)\n      }\n      return\n    }\n    if (data) cb(null, {port: 0, host: data.host})\n    else cb(new Error('Probe failed'))\n  }\n}\n\nDNSDiscovery.prototype._probe = function (i, retries, cb) {\n  var self = this\n  var s = this.servers[i]\n  var q = {\n    questions: [{\n      type: 'TXT',\n      name: this._domain\n    }]\n  }\n  debug('probing %s:%d', s.host, s.port)\n\n  var first = true\n  var result = null\n  var id = this.socket.query(q, s.port, s.host, done)\n\n  if (retries) this.socket.setRetries(id, retries)\n\n  function done (_, res, query, port, host) {\n    if (res) {\n      self.emit('traffic', 'in:response', {message: res, peer: {host: host, port: port}})\n      try {\n        var data = res.answers.length && decodeTxt(res.answers[0].data)\n      } catch (err) {\n        // do nothing\n      }\n      if (data && data.token) {\n        self._parseData(null, data, i, host)\n        result = data\n      }\n    }\n\n    if (result) {\n      if (!first) {\n        s.port = port\n        s.secondaryPort = 0\n      } else {\n        s.secondaryPort = 0\n      }\n\n      debug('probe of %s:%d succeeded', host, port)\n      return cb(null, result, port, host)\n    }\n\n    if (!first || !s.secondaryPort) {\n      debug('probe of %s:%d failed', host, port)\n      return cb(new Error('Probe failed'))\n    }\n\n    first = false\n    debug('retrying probe of %s at secondary port %d', host, s.secondaryPort)\n    id = self.socket.query(q, s.secondaryPort, s.host, done)\n    if (retries) self.socket.setRetries(id, retries)\n  }\n}\n\nDNSDiscovery.prototype.destroy = function (onclose) {\n  debug('destroy()')\n  if (onclose) this.once('close', onclose)\n\n  var self = this\n  var missing = this._sockets.length\n  clearInterval(this._interval)\n\n  if (this.multicast) this.multicast.destroy(onmulticastclose)\n  else onmulticastclose()\n\n  function onmulticastclose () {\n    for (var i = 0; i < self._sockets.length; i++) {\n      self._sockets[i].destroy(onsocketclose)\n    }\n  }\n\n  function onsocketclose () {\n    if (!--missing) self.emit('close')\n  }\n}\n\nDNSDiscovery.prototype.listen = function (ports, onlistening) {\n  if (onlistening) this.once('listening', onlistening)\n  if (this._listening) throw new Error('Server is already listening')\n  this._listening = true\n\n  if (!ports) ports = [53, 5300]\n  if (!Array.isArray(ports)) ports = [ports]\n\n  debug('Listening on port(s)', ports.join(', '))\n\n  var self = this\n  var missing = ports.length\n\n  for (var i = 0; i < ports.length; i++) {\n    var socket = dns()\n    socket.bind(ports[i], onbind)\n    this._onsocket(socket)\n  }\n\n  function onbind () {\n    if (!--missing) self.emit('listening')\n  }\n}\n\nfunction noop () {}\n\nfunction parseAddr (addr) {\n  if (addr.indexOf(':') === -1) addr += ':5300,53'\n  var match = addr.match(/^([^:]+)(?::(\\d{1,5})(?:,(\\d{1,5}))?)?$/)\n  if (!match) throw new Error('Could not parse ' + addr)\n\n  return {\n    port: Number(match[2] || 53),\n    secondaryPort: Number(match[3] || 0),\n    host: match[1]\n  }\n}\n\nfunction hash (secret, host) {\n  return crypto.createHash('sha256').update(secret).update(host).digest('base64')\n}\n\nfunction parseId (name, domain) {\n  if (!domain || name.length === domain.length) return null\n  return name.slice(0, -domain.length - 1)\n}\n\nfunction parseDomain (name) {\n  var i = name.lastIndexOf('.')\n  if (i === -1) return null\n  i = name.lastIndexOf('.', i - 1)\n  return i === -1 ? name : name.slice(i + 1)\n}\n\nfunction toBuffer (peers) {\n  var buf = Buffer.alloc(peers.length * 6)\n  for (var i = 0; i < peers.length; i++) {\n    if (!peers[i].buffer) peers[i].buffer = encodePeer(peers[i])\n    peers[i].buffer.copy(buf, i * 6)\n  }\n  return buf\n}\n\nfunction encodePeer (peer) {\n  var buf = Buffer.alloc(6)\n  var parts = peer.host.split('.')\n  buf[0] = Number(parts[0] || 0)\n  buf[1] = Number(parts[1] || 0)\n  buf[2] = Number(parts[2] || 0)\n  buf[3] = Number(parts[3] || 0)\n  buf.writeUInt16BE(peer.port || 0, 4)\n  return buf\n}\n\nfunction decodePeer (buf, offset) {\n  if (buf.length - offset < 6) return null\n  var host = buf[offset++] + '.' + buf[offset++] + '.' + buf[offset++] + '.' + buf[offset++]\n  var port = buf.readUInt16BE(offset)\n  offset += 2\n  return {port: port, host: host}\n}\n\nfunction decodeTxt (bufs) {\n  var data = {}\n\n  for (var i = 0; i < bufs.length; i++) {\n    var buf = bufs[i]\n    var j = buf.indexOf(61) // '='\n    if (j === -1) data[buf.toString()] = true\n    else data[buf.slice(0, j).toString()] = buf.slice(j + 1).toString()\n  }\n\n  return data\n}\n\nfunction encodeTxt (data) {\n  var keys = Object.keys(data)\n  var bufs = []\n\n  for (var i = 0; i < keys.length; i++) {\n    bufs.push(Buffer.from(keys[i] + '=' + data[keys[i]]))\n  }\n\n  return bufs\n}\n\nfunction isMulticaster (m) {\n  return typeof m === 'object' && m && typeof m.query === 'function'\n}\n","'use strict'\n\nconst dgram = require('dgram')\nconst util = require('util')\nconst packet = require('dns-packet')\nconst events = require('events')\n\nmodule.exports = DNS\n\nfunction DNS (opts) {\n  if (!(this instanceof DNS)) return new DNS(opts)\n  if (!opts) opts = {}\n\n  events.EventEmitter.call(this)\n\n  const self = this\n\n  this.retries = opts.retries || 5\n  this.timeout = opts.timeout || 7500\n  this.destroyed = false\n  this.inflight = 0\n  this.socket = opts.socket || dgram.createSocket('udp4')\n  this._id = Math.ceil(Math.random() * 65535)\n  this._ids = []\n  this._queries = []\n  this._interval = null\n  this._triesArray = getTriesArray(this.retries) // default: [2, 4, 8, 16] = .5s, 1s, 2s, 4s\n\n  this.socket.on('error', onerror)\n  this.socket.on('message', onmessage)\n  if (isListening(this.socket)) onlistening()\n  else this.socket.on('listening', onlistening)\n  this.socket.on('close', onclose)\n\n  function onerror (err) {\n    if (err.code === 'EACCES' || err.code === 'EADDRINUSE') self.emit('error', err)\n    else self.emit('warning', err)\n  }\n\n  function onmessage (message, rinfo) {\n    self._onmessage(message, rinfo)\n  }\n\n  function onlistening () {\n    const timeSlices = self._triesArray.reduce(add, 0)\n    self._interval = setInterval(ontimeout, Math.round(self.timeout / timeSlices))\n    self.emit('listening')\n  }\n\n  function onclose () {\n    self.emit('close')\n  }\n\n  function ontimeout () {\n    self._ontimeout()\n  }\n}\n\nutil.inherits(DNS, events.EventEmitter)\n\nDNS.RECURSION_DESIRED = DNS.prototype.RECURSION_DESIRED = packet.RECURSION_DESIRED\nDNS.RECURSION_AVAILABLE = DNS.prototype.RECURSION_AVAILABLE = packet.RECURSION_AVAILABLE\nDNS.TRUNCATED_RESPONSE = DNS.prototype.TRUNCATED_RESPONSE = packet.TRUNCATED_RESPONSE\nDNS.AUTHORITATIVE_ANSWER = DNS.prototype.AUTHORITATIVE_ANSWER = packet.AUTHORITATIVE_ANSWER\nDNS.AUTHENTIC_DATA = DNS.prototype.AUTHENTIC_DATA = packet.AUTHENTIC_DATA\nDNS.CHECKING_DISABLED = DNS.prototype.CHECKING_DISABLED = packet.CHECKING_DISABLED\n\nDNS.prototype.address = function () {\n  return this.socket.address()\n}\n\nDNS.prototype.bind = function (port, onlistening) {\n  if (onlistening) this.once('listening', onlistening)\n  this.socket.bind(port)\n}\n\nDNS.prototype.destroy = function (onclose) {\n  if (onclose) this.once('close', onclose)\n  if (this.destroyed) return\n  this.destroyed = true\n  clearInterval(this._interval)\n  this.socket.close()\n  for (let i = 0; i < this._queries.length; i++) {\n    const q = this._queries[i]\n    if (q) q.callback(new Error('Socket destroyed'))\n  }\n  this._queries = []\n  this._ids = []\n  this.inflight = 0\n}\n\nDNS.prototype._ontimeout = function () {\n  for (let i = 0; i < this._queries.length; i++) {\n    const q = this._queries[i]\n    if (!q) continue\n    if (!q.tries.length) {\n      this._queries[i] = null\n      this._ids[i] = 0\n      this.inflight--\n      this.emit('timeout', q.query, q.port, q.host)\n      q.callback(new Error('Query timed out'))\n      continue\n    }\n    if (--q.tries[0]) continue\n    q.tries.shift()\n    this.socket.send(q.buffer, 0, q.buffer.length, q.port, q.host)\n  }\n  this._trim()\n}\n\nDNS.prototype._onmessage = function (buffer, rinfo) {\n  let message\n\n  try {\n    message = packet.decode(buffer)\n  } catch (err) {\n    this.emit('warning', err)\n    return\n  }\n\n  if (message.type === 'response' && message.id) {\n    const i = this._ids.indexOf(message.id)\n    const q = i > -1 ? this._queries[i] : null\n    if (q) {\n      this.inflight--\n      this._ids[i] = 0\n      this._queries[i] = null\n      this._trim()\n      q.callback(null, message, q.query, rinfo.port, rinfo.address)\n    }\n  }\n\n  this.emit(message.type, message, rinfo.port, rinfo.address)\n}\n\nDNS.prototype._trim = function () {\n  while (this._ids.length && !this._ids[this._ids.length - 1]) {\n    this._ids.pop()\n    this._queries.pop()\n  }\n}\n\nDNS.prototype.unref = function () {\n  this.socket.unref()\n}\n\nDNS.prototype.ref = function () {\n  this.socket.ref()\n}\n\nDNS.prototype.response = function (query, response, port, host) {\n  if (this.destroyed) return\n\n  response.type = 'response'\n  response.id = query.id\n\n  const buffer = packet.encode(response)\n  this.socket.send(buffer, 0, buffer.length, port, host || '127.0.0.1')\n}\n\nDNS.prototype.cancel = function (id) {\n  const i = this._ids.indexOf(id)\n  const q = this._queries[i]\n  if (!q) return\n\n  this._queries[i] = null\n  this._ids[i] = 0\n  this.inflight--\n  q.callback(new Error('Query cancelled'))\n}\n\nDNS.prototype.setRetries = function (id, retries) {\n  const i = this._ids.indexOf(id)\n  const q = this._queries[i]\n  if (!q) return\n\n  while (q.tries.length < retries) {\n    q.tries.push(q.tries.length ? 2 * q.tries[q.tries.length - 1] : 4)\n  }\n  if (q.tries.length > retries) {\n    q.tries = q.tries.slice(0, retries)\n  }\n}\n\nDNS.prototype.query = function (query, port, host, cb) {\n  if (typeof host === 'function') return this.query(query, port, null, host)\n  if (!cb) cb = noop\n\n  if (this.destroyed) {\n    nextTick(cb, new Error('Socket destroyed'))\n    return 0\n  }\n\n  this.inflight++\n  query.type = 'query'\n  query.flags = typeof query.flags === 'number' ? query.flags : DNS.RECURSION_DESIRED\n  const id = query.id = this._id++\n  if (this._id === 65535) this._id = 1\n\n  let i = this._ids.indexOf(0)\n  if (i === -1) i = this._ids.push(0) - 1\n  if (this._queries.length === i) this._queries.push(null)\n\n  const buffer = packet.encode(query)\n  const tries = this._triesArray.slice(0)\n\n  this._ids[i] = id\n  this._queries[i] = {\n    callback: cb,\n    tries: tries,\n    query: query,\n    buffer: buffer,\n    port: port,\n    host: host\n  }\n\n  this.socket.send(buffer, 0, buffer.length, port, host || '127.0.0.1')\n  return id\n}\n\nfunction noop () {}\n\nfunction nextTick (cb, err) {\n  process.nextTick(function () {\n    cb(err)\n  })\n}\n\nfunction add (a, b) {\n  return a + b\n}\n\nfunction getTriesArray (retries) {\n  const ret = []\n  if (retries <= 1) return ret\n  for (let i = 1; i <= retries - 1; i++) {\n    ret.push(Math.pow(2, i))\n  }\n  return ret\n}\n\nfunction isListening (socket) {\n  try {\n    return socket.address().port !== 0\n  } catch (err) {\n    return false\n  }\n}\n","module.exports = require(\"dgram\");","'use strict'\n\nconst types = require('./types')\nconst rcodes = require('./rcodes')\nconst opcodes = require('./opcodes')\nconst classes = require('./classes')\nconst ip = require('ip')\nconst Buffer = require('safe-buffer').Buffer\n\nconst QUERY_FLAG = 0\nconst RESPONSE_FLAG = 1 << 15\nconst FLUSH_MASK = 1 << 15\nconst NOT_FLUSH_MASK = ~FLUSH_MASK\nconst QU_MASK = 1 << 15\nconst NOT_QU_MASK = ~QU_MASK\n\nconst name = exports.txt = exports.name = {}\n\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(name.encodingLength(str))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  // strip leading and trailing .\n  const n = str.replace(/^\\.|\\.$/gm, '')\n  if (n.length) {\n    const list = n.split('.')\n\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1)\n      buf[offset] = len\n      offset += len + 1\n    }\n  }\n\n  buf[offset++] = 0\n\n  name.encode.bytes = offset - oldOffset\n  return buf\n}\n\nname.encode.bytes = 0\n\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const list = []\n  const oldOffset = offset\n  let len = buf[offset++]\n\n  if (len === 0) {\n    name.decode.bytes = 1\n    return '.'\n  }\n  if (len >= 0xc0) {\n    const res = name.decode(buf, buf.readUInt16BE(offset - 1) - 0xc000)\n    name.decode.bytes = 2\n    return res\n  }\n\n  while (len) {\n    if (len >= 0xc0) {\n      list.push(name.decode(buf, buf.readUInt16BE(offset - 1) - 0xc000))\n      offset++\n      break\n    }\n\n    list.push(buf.toString('utf-8', offset, offset + len))\n    offset += len\n    len = buf[offset++]\n  }\n\n  name.decode.bytes = offset - oldOffset\n  return list.join('.')\n}\n\nname.decode.bytes = 0\n\nname.encodingLength = function (n) {\n  if (n === '.') return 1\n  return Buffer.byteLength(n) + 2\n}\n\nconst string = {}\n\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(string.encodingLength(s))\n  if (!offset) offset = 0\n\n  const len = buf.write(s, offset + 1)\n  buf[offset] = len\n  string.encode.bytes = len + 1\n  return buf\n}\n\nstring.encode.bytes = 0\n\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf[offset]\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len)\n  string.decode.bytes = len + 1\n  return s\n}\n\nstring.decode.bytes = 0\n\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1\n}\n\nconst header = {}\n\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h)\n  if (!offset) offset = 0\n\n  const flags = (h.flags || 0) & 32767\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG\n\n  buf.writeUInt16BE(h.id || 0, offset)\n  buf.writeUInt16BE(flags | type, offset + 2)\n  buf.writeUInt16BE(h.questions.length, offset + 4)\n  buf.writeUInt16BE(h.answers.length, offset + 6)\n  buf.writeUInt16BE(h.authorities.length, offset + 8)\n  buf.writeUInt16BE(h.additionals.length, offset + 10)\n\n  return buf\n}\n\nheader.encode.bytes = 12\n\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  if (buf.length < 12) throw new Error('Header must be 12 bytes')\n  const flags = buf.readUInt16BE(offset + 2)\n\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: ((flags >> 15) & 0x1) === 1,\n    opcode: opcodes.toString((flags >> 11) & 0xf),\n    flag_aa: ((flags >> 10) & 0x1) === 1,\n    flag_tc: ((flags >> 9) & 0x1) === 1,\n    flag_rd: ((flags >> 8) & 0x1) === 1,\n    flag_ra: ((flags >> 7) & 0x1) === 1,\n    flag_z: ((flags >> 6) & 0x1) === 1,\n    flag_ad: ((flags >> 5) & 0x1) === 1,\n    flag_cd: ((flags >> 4) & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  }\n}\n\nheader.decode.bytes = 12\n\nheader.encodingLength = function () {\n  return 12\n}\n\nconst runknown = exports.unknown = {}\n\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(runknown.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.length, offset)\n  data.copy(buf, offset + 2)\n\n  runknown.encode.bytes = data.length + 2\n  return buf\n}\n\nrunknown.encode.bytes = 0\n\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const data = buf.slice(offset + 2, offset + 2 + len)\n  runknown.decode.bytes = len + 2\n  return data\n}\n\nrunknown.decode.bytes = 0\n\nrunknown.encodingLength = function (data) {\n  return data.length + 2\n}\n\nconst rns = exports.ns = {}\n\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rns.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rns.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrns.encode.bytes = 0\n\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const dd = name.decode(buf, offset + 2)\n\n  rns.decode.bytes = len + 2\n  return dd\n}\n\nrns.decode.bytes = 0\n\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsoa = exports.soa = {}\n\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rsoa.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  name.encode(data.mname, buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.rname, buf, offset)\n  offset += name.encode.bytes\n  buf.writeUInt32BE(data.serial || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.refresh || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.retry || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.expire || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.minimum || 0, offset)\n  offset += 4\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rsoa.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrsoa.encode.bytes = 0\n\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.rname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.serial = buf.readUInt32BE(offset)\n  offset += 4\n  data.refresh = buf.readUInt32BE(offset)\n  offset += 4\n  data.retry = buf.readUInt32BE(offset)\n  offset += 4\n  data.expire = buf.readUInt32BE(offset)\n  offset += 4\n  data.minimum = buf.readUInt32BE(offset)\n  offset += 4\n\n  rsoa.decode.bytes = offset - oldOffset\n  return data\n}\n\nrsoa.decode.bytes = 0\n\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname)\n}\n\nconst rtxt = exports.txt = {}\n\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data]\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i])\n    }\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer')\n    }\n  }\n\n  if (!buf) buf = Buffer.allocUnsafe(rtxt.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n\n  data.forEach(function (d) {\n    buf[offset++] = d.length\n    d.copy(buf, offset, 0, d.length)\n    offset += d.length\n  })\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rtxt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrtxt.encode.bytes = 0\n\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  let remaining = buf.readUInt16BE(offset)\n  offset += 2\n\n  let data = []\n  while (remaining > 0) {\n    const len = buf[offset++]\n    --remaining\n    if (remaining < len) {\n      throw new Error('Buffer overflow')\n    }\n    data.push(buf.slice(offset, offset + len))\n    offset += len\n    remaining -= len\n  }\n\n  rtxt.decode.bytes = offset - oldOffset\n  return data\n}\n\nrtxt.decode.bytes = 0\n\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data]\n  let length = 2\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1\n    } else {\n      length += buf.length + 1\n    }\n  })\n  return length\n}\n\nconst rnull = exports.null = {}\n\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rnull.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (typeof data === 'string') data = Buffer.from(data)\n  if (!data) data = Buffer.allocUnsafe(0)\n\n  const oldOffset = offset\n  offset += 2\n\n  const len = data.length\n  data.copy(buf, offset, 0, len)\n  offset += len\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rnull.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrnull.encode.bytes = 0\n\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  const len = buf.readUInt16BE(offset)\n\n  offset += 2\n\n  const data = buf.slice(offset, offset + len)\n  offset += len\n\n  rnull.decode.bytes = offset - oldOffset\n  return data\n}\n\nrnull.decode.bytes = 0\n\nrnull.encodingLength = function (data) {\n  if (!data) return 2\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2\n}\n\nconst rhinfo = exports.hinfo = {}\n\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rhinfo.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  string.encode(data.cpu, buf, offset)\n  offset += string.encode.bytes\n  string.encode(data.os, buf, offset)\n  offset += string.encode.bytes\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rhinfo.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrhinfo.encode.bytes = 0\n\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.cpu = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.os = string.decode(buf, offset)\n  offset += string.decode.bytes\n  rhinfo.decode.bytes = offset - oldOffset\n  return data\n}\n\nrhinfo.decode.bytes = 0\n\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2\n}\n\nconst rptr = exports.ptr = {}\nconst rcname = exports.cname = rptr\nconst rdname = exports.dname = rptr\n\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rptr.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rptr.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrptr.encode.bytes = 0\n\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const data = name.decode(buf, offset + 2)\n  rptr.decode.bytes = name.decode.bytes + 2\n  return data\n}\n\nrptr.decode.bytes = 0\n\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsrv = exports.srv = {}\n\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rsrv.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.priority || 0, offset + 2)\n  buf.writeUInt16BE(data.weight || 0, offset + 4)\n  buf.writeUInt16BE(data.port || 0, offset + 6)\n  name.encode(data.target, buf, offset + 8)\n\n  const len = name.encode.bytes + 6\n  buf.writeUInt16BE(len, offset)\n\n  rsrv.encode.bytes = len + 2\n  return buf\n}\n\nrsrv.encode.bytes = 0\n\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n\n  const data = {}\n  data.priority = buf.readUInt16BE(offset + 2)\n  data.weight = buf.readUInt16BE(offset + 4)\n  data.port = buf.readUInt16BE(offset + 6)\n  data.target = name.decode(buf, offset + 8)\n\n  rsrv.decode.bytes = len + 2\n  return data\n}\n\nrsrv.decode.bytes = 0\n\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target)\n}\n\nconst rcaa = exports.caa = {}\n\nrcaa.ISSUER_CRITICAL = 1 << 7\n\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data)\n\n  if (!buf) buf = Buffer.allocUnsafe(rcaa.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL\n  }\n\n  buf.writeUInt16BE(len - 2, offset)\n  offset += 2\n  buf.writeUInt8(data.flags || 0, offset)\n  offset += 1\n  string.encode(data.tag, buf, offset)\n  offset += string.encode.bytes\n  buf.write(data.value, offset)\n  offset += Buffer.byteLength(data.value)\n\n  rcaa.encode.bytes = len\n  return buf\n}\n\nrcaa.encode.bytes = 0\n\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n\n  const oldOffset = offset\n  const data = {}\n  data.flags = buf.readUInt8(offset)\n  offset += 1\n  data.tag = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.value = buf.toString('utf-8', offset, oldOffset + len)\n\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL)\n\n  rcaa.decode.bytes = len + 2\n\n  return data\n}\n\nrcaa.decode.bytes = 0\n\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2\n}\n\nconst rmx = exports.mx = {}\n\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(rmx.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  buf.writeUInt16BE(data.preference || 0, offset)\n  offset += 2\n  name.encode(data.exchange, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rmx.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrmx.encode.bytes = 0\n\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.preference = buf.readUInt16BE(offset)\n  offset += 2\n  data.exchange = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  rmx.decode.bytes = offset - oldOffset\n  return data\n}\n\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange)\n}\n\nconst ra = exports.a = {}\n\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(ra.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(4, offset)\n  offset += 2\n  ip.toBuffer(host, buf, offset)\n  ra.encode.bytes = 6\n  return buf\n}\n\nra.encode.bytes = 0\n\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.toString(buf, offset, 4)\n  ra.decode.bytes = 6\n  return host\n}\n\nra.decode.bytes = 0\n\nra.encodingLength = function () {\n  return 6\n}\n\nconst raaaa = exports.aaaa = {}\n\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(raaaa.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(16, offset)\n  offset += 2\n  ip.toBuffer(host, buf, offset)\n  raaaa.encode.bytes = 18\n  return buf\n}\n\nraaaa.encode.bytes = 0\n\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.toString(buf, offset, 16)\n  raaaa.decode.bytes = 18\n  return host\n}\n\nraaaa.decode.bytes = 0\n\nraaaa.encodingLength = function () {\n  return 18\n}\n\nconst roption = exports.option = {}\n\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(roption.encodingLength(option))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  buf.writeUInt16BE(option.code, offset)\n  offset += 2\n  buf.writeUInt16BE(option.data.length, offset)\n  offset += 2\n  option.data.copy(buf, offset)\n  offset += option.data.length\n\n  roption.encode.bytes = offset - oldOffset\n  return buf\n}\n\nroption.encode.bytes = 0\n\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const option = {}\n\n  option.code = buf.readUInt16BE(offset)\n  const len = buf.readUInt16BE(offset + 2)\n  option.data = buf.slice(offset + 4, offset + 4 + len)\n\n  roption.decode.bytes = len + 4\n  return option\n}\n\nroption.decode.bytes = 0\n\nroption.encodingLength = function (option) {\n  return option.data.length + 4\n}\n\nconst ropt = exports.opt = {}\n\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(ropt.encodingLength(options))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const rdlen = encodingLengthList(options, roption)\n  buf.writeUInt16BE(rdlen, offset)\n  offset = encodeList(options, roption, buf, offset + 2)\n\n  ropt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nropt.encode.bytes = 0\n\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const options = []\n  let rdlen = buf.readUInt16BE(offset)\n  offset += 2\n  let o = 0\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset)\n    offset += roption.decode.bytes\n    rdlen -= roption.decode.bytes\n  }\n  ropt.decode.bytes = offset - oldOffset\n  return options\n}\n\nropt.decode.bytes = 0\n\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption)\n}\n\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A': return ra\n    case 'PTR': return rptr\n    case 'CNAME': return rcname\n    case 'DNAME': return rdname\n    case 'TXT': return rtxt\n    case 'NULL': return rnull\n    case 'AAAA': return raaaa\n    case 'SRV': return rsrv\n    case 'HINFO': return rhinfo\n    case 'CAA': return rcaa\n    case 'NS': return rns\n    case 'SOA': return rsoa\n    case 'MX': return rmx\n    case 'OPT': return ropt\n  }\n  return runknown\n}\n\nconst answer = exports.answer = {}\n\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(answer.encodingLength(a))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(a.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(a.type), offset)\n\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.')\n    }\n    buf.writeUInt16BE(a.updPayloadSize || 4096, offset + 2)\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4)\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5)\n    buf.writeUInt16BE(a.flags || 0, offset + 6)\n\n    offset += 8\n    ropt.encode(a.options || [], buf, offset)\n    offset += ropt.encode.bytes\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class)\n    if (a.flush) klass |= FLUSH_MASK // the 1st bit of the class is the flush bit\n    buf.writeUInt16BE(klass, offset + 2)\n    buf.writeUInt32BE(a.ttl || 0, offset + 4)\n\n    offset += 8\n    const enc = renc(a.type)\n    enc.encode(a.data, buf, offset)\n    offset += enc.encode.bytes\n  }\n\n  answer.encode.bytes = offset - oldOffset\n  return buf\n}\n\nanswer.encode.bytes = 0\n\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const a = {}\n  const oldOffset = offset\n\n  a.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n  a.type = types.toString(buf.readUInt16BE(offset))\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2)\n    a.extendedRcode = buf.readUInt8(offset + 4)\n    a.ednsVersion = buf.readUInt8(offset + 5)\n    a.flags = buf.readUInt16BE(offset + 6)\n    a.flag_do = ((a.flags >> 15) & 0x1) === 1\n    a.options = ropt.decode(buf, offset + 8)\n    offset += 8 + ropt.decode.bytes\n  } else {\n    const klass = buf.readUInt16BE(offset + 2)\n    a.ttl = buf.readUInt32BE(offset + 4)\n\n    a.class = classes.toString(klass & NOT_FLUSH_MASK)\n    a.flush = !!(klass & FLUSH_MASK)\n\n    const enc = renc(a.type)\n    a.data = enc.decode(buf, offset + 8)\n    offset += 8 + enc.decode.bytes\n  }\n\n  answer.decode.bytes = offset - oldOffset\n  return a\n}\n\nanswer.decode.bytes = 0\n\nanswer.encodingLength = function (a) {\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(a.data || a.options)\n}\n\nconst question = exports.question = {}\n\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(question.encodingLength(q))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(q.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(q.type), offset)\n  offset += 2\n\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset)\n  offset += 2\n\n  question.encode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.encode.bytes = 0\n\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const q = {}\n\n  q.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  q.type = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  q.class = classes.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  const qu = !!(q.class & QU_MASK)\n  if (qu) q.class &= NOT_QU_MASK\n\n  question.decode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.decode.bytes = 0\n\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4\n}\n\nexports.AUTHORITATIVE_ANSWER = 1 << 10\nexports.TRUNCATED_RESPONSE = 1 << 9\nexports.RECURSION_DESIRED = 1 << 8\nexports.RECURSION_AVAILABLE = 1 << 7\nexports.AUTHENTIC_DATA = 1 << 5\nexports.CHECKING_DISABLED = 1 << 4\nexports.DNSSEC_OK = 1 << 15\n\nexports.encode = function (result, buf, offset) {\n  if (!buf) buf = Buffer.allocUnsafe(exports.encodingLength(result))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  if (!result.questions) result.questions = []\n  if (!result.answers) result.answers = []\n  if (!result.authorities) result.authorities = []\n  if (!result.additionals) result.additionals = []\n\n  header.encode(result, buf, offset)\n  offset += header.encode.bytes\n\n  offset = encodeList(result.questions, question, buf, offset)\n  offset = encodeList(result.answers, answer, buf, offset)\n  offset = encodeList(result.authorities, answer, buf, offset)\n  offset = encodeList(result.additionals, answer, buf, offset)\n\n  exports.encode.bytes = offset - oldOffset\n\n  return buf\n}\n\nexports.encode.bytes = 0\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const result = header.decode(buf, offset)\n  offset += header.decode.bytes\n\n  offset = decodeList(result.questions, question, buf, offset)\n  offset = decodeList(result.answers, answer, buf, offset)\n  offset = decodeList(result.authorities, answer, buf, offset)\n  offset = decodeList(result.additionals, answer, buf, offset)\n\n  exports.decode.bytes = offset - oldOffset\n\n  return result\n}\n\nexports.decode.bytes = 0\n\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) +\n    encodingLengthList(result.questions || [], question) +\n    encodingLengthList(result.answers || [], answer) +\n    encodingLengthList(result.authorities || [], answer) +\n    encodingLengthList(result.additionals || [], answer)\n}\n\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result)\n  const sbuf = Buffer.allocUnsafe(2)\n  sbuf.writeUInt16BE(buf.byteLength)\n  const combine = Buffer.concat([sbuf, buf])\n  exports.streamEncode.bytes = combine.byteLength\n  return combine\n}\n\nexports.streamEncode.bytes = 0\n\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0)\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null\n  }\n  const result = exports.decode(sbuf.slice(2))\n  exports.streamDecode.bytes = exports.decode.bytes\n  return result\n}\n\nexports.streamDecode.bytes = 0\n\nfunction encodingLengthList (list, enc) {\n  let len = 0\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i])\n  return len\n}\n\nfunction encodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset)\n    offset += enc.encode.bytes\n  }\n  return offset\n}\n\nfunction decodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset)\n    offset += enc.decode.bytes\n  }\n  return offset\n}\n","'use strict'\n\nexports.toString = function (type) {\n  switch (type) {\n    case 1: return 'A'\n    case 10: return 'NULL'\n    case 28: return 'AAAA'\n    case 18: return 'AFSDB'\n    case 42: return 'APL'\n    case 257: return 'CAA'\n    case 60: return 'CDNSKEY'\n    case 59: return 'CDS'\n    case 37: return 'CERT'\n    case 5: return 'CNAME'\n    case 49: return 'DHCID'\n    case 32769: return 'DLV'\n    case 39: return 'DNAME'\n    case 48: return 'DNSKEY'\n    case 43: return 'DS'\n    case 55: return 'HIP'\n    case 13: return 'HINFO'\n    case 45: return 'IPSECKEY'\n    case 25: return 'KEY'\n    case 36: return 'KX'\n    case 29: return 'LOC'\n    case 15: return 'MX'\n    case 35: return 'NAPTR'\n    case 2: return 'NS'\n    case 47: return 'NSEC'\n    case 50: return 'NSEC3'\n    case 51: return 'NSEC3PARAM'\n    case 12: return 'PTR'\n    case 46: return 'RRSIG'\n    case 17: return 'RP'\n    case 24: return 'SIG'\n    case 6: return 'SOA'\n    case 99: return 'SPF'\n    case 33: return 'SRV'\n    case 44: return 'SSHFP'\n    case 32768: return 'TA'\n    case 249: return 'TKEY'\n    case 52: return 'TLSA'\n    case 250: return 'TSIG'\n    case 16: return 'TXT'\n    case 252: return 'AXFR'\n    case 251: return 'IXFR'\n    case 41: return 'OPT'\n    case 255: return 'ANY'\n  }\n  return 'UNKNOWN_' + type\n}\n\nexports.toType = function (name) {\n  switch (name.toUpperCase()) {\n    case 'A': return 1\n    case 'NULL': return 10\n    case 'AAAA': return 28\n    case 'AFSDB': return 18\n    case 'APL': return 42\n    case 'CAA': return 257\n    case 'CDNSKEY': return 60\n    case 'CDS': return 59\n    case 'CERT': return 37\n    case 'CNAME': return 5\n    case 'DHCID': return 49\n    case 'DLV': return 32769\n    case 'DNAME': return 39\n    case 'DNSKEY': return 48\n    case 'DS': return 43\n    case 'HIP': return 55\n    case 'HINFO': return 13\n    case 'IPSECKEY': return 45\n    case 'KEY': return 25\n    case 'KX': return 36\n    case 'LOC': return 29\n    case 'MX': return 15\n    case 'NAPTR': return 35\n    case 'NS': return 2\n    case 'NSEC': return 47\n    case 'NSEC3': return 50\n    case 'NSEC3PARAM': return 51\n    case 'PTR': return 12\n    case 'RRSIG': return 46\n    case 'RP': return 17\n    case 'SIG': return 24\n    case 'SOA': return 6\n    case 'SPF': return 99\n    case 'SRV': return 33\n    case 'SSHFP': return 44\n    case 'TA': return 32768\n    case 'TKEY': return 249\n    case 'TLSA': return 52\n    case 'TSIG': return 250\n    case 'TXT': return 16\n    case 'AXFR': return 252\n    case 'IXFR': return 251\n    case 'OPT': return 41\n    case 'ANY': return 255\n    case '*': return 255\n  }\n  return 0\n}\n","'use strict'\n\n/*\n * Traditional DNS header RCODEs (4-bits) defined by IANA in\n * https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml\n */\n\nexports.toString = function (rcode) {\n  switch (rcode) {\n    case 0: return 'NOERROR'\n    case 1: return 'FORMERR'\n    case 2: return 'SERVFAIL'\n    case 3: return 'NXDOMAIN'\n    case 4: return 'NOTIMP'\n    case 5: return 'REFUSED'\n    case 6: return 'YXDOMAIN'\n    case 7: return 'YXRRSET'\n    case 8: return 'NXRRSET'\n    case 9: return 'NOTAUTH'\n    case 10: return 'NOTZONE'\n    case 11: return 'RCODE_11'\n    case 12: return 'RCODE_12'\n    case 13: return 'RCODE_13'\n    case 14: return 'RCODE_14'\n    case 15: return 'RCODE_15'\n  }\n  return 'RCODE_' + rcode\n}\n\nexports.toRcode = function (code) {\n  switch (code.toUpperCase()) {\n    case 'NOERROR': return 0\n    case 'FORMERR': return 1\n    case 'SERVFAIL': return 2\n    case 'NXDOMAIN': return 3\n    case 'NOTIMP': return 4\n    case 'REFUSED': return 5\n    case 'YXDOMAIN': return 6\n    case 'YXRRSET': return 7\n    case 'NXRRSET': return 8\n    case 'NOTAUTH': return 9\n    case 'NOTZONE': return 10\n    case 'RCODE_11': return 11\n    case 'RCODE_12': return 12\n    case 'RCODE_13': return 13\n    case 'RCODE_14': return 14\n    case 'RCODE_15': return 15\n  }\n  return 0\n}\n","'use strict'\n\n/*\n * Traditional DNS header OPCODEs (4-bits) defined by IANA in\n * https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-5\n */\n\nexports.toString = function (opcode) {\n  switch (opcode) {\n    case 0: return 'QUERY'\n    case 1: return 'IQUERY'\n    case 2: return 'STATUS'\n    case 3: return 'OPCODE_3'\n    case 4: return 'NOTIFY'\n    case 5: return 'UPDATE'\n    case 6: return 'OPCODE_6'\n    case 7: return 'OPCODE_7'\n    case 8: return 'OPCODE_8'\n    case 9: return 'OPCODE_9'\n    case 10: return 'OPCODE_10'\n    case 11: return 'OPCODE_11'\n    case 12: return 'OPCODE_12'\n    case 13: return 'OPCODE_13'\n    case 14: return 'OPCODE_14'\n    case 15: return 'OPCODE_15'\n  }\n  return 'OPCODE_' + opcode\n}\n\nexports.toOpcode = function (code) {\n  switch (code.toUpperCase()) {\n    case 'QUERY': return 0\n    case 'IQUERY': return 1\n    case 'STATUS': return 2\n    case 'OPCODE_3': return 3\n    case 'NOTIFY': return 4\n    case 'UPDATE': return 5\n    case 'OPCODE_6': return 6\n    case 'OPCODE_7': return 7\n    case 'OPCODE_8': return 8\n    case 'OPCODE_9': return 9\n    case 'OPCODE_10': return 10\n    case 'OPCODE_11': return 11\n    case 'OPCODE_12': return 12\n    case 'OPCODE_13': return 13\n    case 'OPCODE_14': return 14\n    case 'OPCODE_15': return 15\n  }\n  return 0\n}\n","'use strict'\n\nexports.toString = function (klass) {\n  switch (klass) {\n    case 1: return 'IN'\n    case 2: return 'CS'\n    case 3: return 'CH'\n    case 4: return 'HS'\n    case 255: return 'ANY'\n  }\n  return 'UNKNOWN_' + klass\n}\n\nexports.toClass = function (name) {\n  switch (name.toUpperCase()) {\n    case 'IN': return 1\n    case 'CS': return 2\n    case 'CH': return 3\n    case 'HS': return 4\n    case 'ANY': return 255\n  }\n  return 0\n}\n","'use strict';\n\nvar ip = exports;\nvar Buffer = require('buffer').Buffer;\nvar os = require('os');\n\nip.toBuffer = function(ip, buff, offset) {\n  offset = ~~offset;\n\n  var result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || new Buffer(offset + 4);\n    ip.split(/\\./g).map(function(byte) {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    var sections = ip.split(':', 8);\n\n    var i;\n    for (i = 0; i < sections.length; i++) {\n      var isv4 = this.isV4Format(sections[i]);\n      var v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      var argv = [ i, 1 ];\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n      sections.splice.apply(sections, argv);\n    }\n\n    result = buff || new Buffer(offset + 16);\n    for (i = 0; i < sections.length; i++) {\n      var word = parseInt(sections[i], 16);\n      result[offset++] = (word >> 8) & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error('Invalid ip address: ' + ip);\n  }\n\n  return result;\n};\n\nip.toString = function(buff, offset, length) {\n  offset = ~~offset;\n  length = length || (buff.length - offset);\n\n  var result = [];\n  if (length === 4) {\n    // IPv4\n    for (var i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (var i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nvar ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nvar ipv6Regex =\n    /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function(ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function(ip) {\n  return ipv6Regex.test(ip);\n};\nfunction _normalizeFamily(family) {\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function(prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  var len = 4;\n  if (family === 'ipv6') {\n    len = 16;\n  }\n  var buff = new Buffer(len);\n\n  for (var i = 0, n = buff.length; i < n; ++i) {\n    var bits = 8;\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n    prefixlen -= bits;\n\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function(addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n\n  var result = new Buffer(Math.max(addr.length, mask.length));\n\n  var i = 0;\n  // Same protocol - do bitwise and\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4  + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (var i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    }\n\n    // ::ffff:ipv4\n    result[10] = 0xff;\n    result[11] = 0xff;\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n    i = i + 12;\n  }\n  for (; i < result.length; i++)\n    result[i] = 0;\n\n  return ip.toString(result);\n};\n\nip.cidr = function(cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2)\n    throw new Error('invalid CIDR subnet: ' + addr);\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function(addr, mask) {\n  var networkAddress = ip.toLong(ip.mask(addr, mask));\n\n  // Calculate the mask's length.\n  var maskBuffer = ip.toBuffer(mask);\n  var maskLength = 0;\n\n  for (var i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      var octet = maskBuffer[i] & 0xff;\n      while (octet) {\n        octet = (octet << 1) & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  var numberOfAddresses = Math.pow(2, 32 - maskLength);\n\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2 ?\n                    ip.fromLong(networkAddress) :\n                    ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2 ?\n                    ip.fromLong(networkAddress + numberOfAddresses - 1) :\n                    ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2 ?\n                numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n    contains: function(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    }\n  };\n};\n\nip.cidrSubnet = function(cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2)\n    throw new Error('invalid CIDR subnet: ' + addr);\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.subnet(addr, mask);\n};\n\nip.not = function(addr) {\n  var buff = ip.toBuffer(addr);\n  for (var i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n  return ip.toString(buff);\n};\n\nip.or = function(a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // same protocol\n  if (a.length === b.length) {\n    for (var i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n    return ip.toString(a);\n\n  // mixed protocols\n  } else {\n    var buff = a;\n    var other = b;\n    if (b.length > a.length) {\n      buff = b;\n      other = a;\n    }\n\n    var offset = buff.length - other.length;\n    for (var i = offset; i < buff.length; ++i) {\n      buff[i] |= other[i - offset];\n    }\n\n    return ip.toString(buff);\n  }\n};\n\nip.isEqual = function(a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // Same protocol\n  if (a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  // Swap\n  if (b.length === 4) {\n    var t = b;\n    b = a;\n    a = t;\n  }\n\n  // a - IPv4, b - IPv6\n  for (var i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  var word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (var i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function(addr) {\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr) ||\n    /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr) ||\n    /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^f[cd][0-9a-f]{2}:/i.test(addr) ||\n    /^fe80:/i.test(addr) ||\n    /^::1$/.test(addr) ||\n    /^::$/.test(addr);\n};\n\nip.isPublic = function(addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function(addr) {\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/\n      .test(addr) ||\n    /^fe80::1$/.test(addr) ||\n    /^::1$/.test(addr) ||\n    /^::$/.test(addr);\n};\n\nip.loopback = function(family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n};\n\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function(name, family) {\n  var interfaces = os.networkInterfaces();\n  var all;\n\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n  if (name && name !== 'private' && name !== 'public') {\n    var res = interfaces[name].filter(function(details) {\n      var itemFamily = details.family.toLowerCase();\n      return itemFamily === family;\n    });\n    if (res.length === 0)\n      return undefined;\n    return res[0].address;\n  }\n\n  var all = Object.keys(interfaces).map(function (nic) {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    var addresses = interfaces[nic].filter(function (details) {\n      details.family = details.family.toLowerCase();\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      } else if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address) :\n          ip.isPublic(details.address);\n    });\n\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function(ip) {\n  var ipl = 0;\n  ip.split('.').forEach(function(octet) {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return(ipl >>> 0);\n};\n\nip.fromLong = function(ipl) {\n  return ((ipl >>> 24) + '.' +\n      (ipl >> 16 & 255) + '.' +\n      (ipl >> 8 & 255) + '.' +\n      (ipl & 255) );\n};\n","var os = require('os')\n\nfunction pickInterface (interfaces, family) {\n  for (var i in interfaces) {\n    for (var j = interfaces[i].length - 1; j >= 0; j--) {\n      var face = interfaces[i][j]\n      var reachable = family === 'IPv4' || face.scopeid === 0\n      if (!face.internal && face.family === family && reachable) return face.address\n    }\n  }\n  return family === 'IPv4' ? '127.0.0.1' : '::1'\n}\n\nfunction reduceInterfaces (interfaces, iface) {\n  var ifaces = {}\n  for (var i in interfaces) {\n    if (i === iface) ifaces[i] = interfaces[i]\n  }\n  return ifaces\n}\n\nfunction ipv4 (iface) {\n  var interfaces = os.networkInterfaces()\n  if (iface) interfaces = reduceInterfaces(interfaces, iface)\n  return pickInterface(interfaces, 'IPv4')\n}\n\nfunction ipv6 (iface) {\n  var interfaces = os.networkInterfaces()\n  if (iface) interfaces = reduceInterfaces(interfaces, iface)\n  return pickInterface(interfaces, 'IPv6')\n}\n\nipv4.ipv4 = ipv4\nipv4.ipv6 = ipv6\n\nmodule.exports = ipv4\n","var packet = require('dns-packet')\nvar dgram = require('dgram')\nvar thunky = require('thunky')\nvar events = require('events')\nvar os = require('os')\n\nvar noop = function () {}\n\nmodule.exports = function (opts) {\n  if (!opts) opts = {}\n\n  var that = new events.EventEmitter()\n  var port = typeof opts.port === 'number' ? opts.port : 5353\n  var type = opts.type || 'udp4'\n  var ip = opts.ip || opts.host || (type === 'udp4' ? '224.0.0.251' : null)\n  var me = {address: ip, port: port}\n  var memberships = {}\n  var destroyed = false\n  var interval = null\n\n  if (type === 'udp6' && (!ip || !opts.interface)) {\n    throw new Error('For IPv6 multicast you must specify `ip` and `interface`')\n  }\n\n  var socket = opts.socket || dgram.createSocket({\n    type: type,\n    reuseAddr: opts.reuseAddr !== false,\n    toString: function () {\n      return type\n    }\n  })\n\n  socket.on('error', function (err) {\n    if (err.code === 'EACCES' || err.code === 'EADDRINUSE') that.emit('error', err)\n    else that.emit('warning', err)\n  })\n\n  socket.on('message', function (message, rinfo) {\n    try {\n      message = packet.decode(message)\n    } catch (err) {\n      that.emit('warning', err)\n      return\n    }\n\n    that.emit('packet', message, rinfo)\n\n    if (message.type === 'query') that.emit('query', message, rinfo)\n    if (message.type === 'response') that.emit('response', message, rinfo)\n  })\n\n  socket.on('listening', function () {\n    if (!port) port = me.port = socket.address().port\n    if (opts.multicast !== false) {\n      that.update()\n      interval = setInterval(that.update, 5000)\n      socket.setMulticastTTL(opts.ttl || 255)\n      socket.setMulticastLoopback(opts.loopback !== false)\n    }\n  })\n\n  var bind = thunky(function (cb) {\n    if (!port || opts.bind === false) return cb(null)\n    socket.once('error', cb)\n    socket.bind(port, opts.interface, function () {\n      socket.removeListener('error', cb)\n      cb(null)\n    })\n  })\n\n  bind(function (err) {\n    if (err) return that.emit('error', err)\n    that.emit('ready')\n  })\n\n  that.send = function (value, rinfo, cb) {\n    if (typeof rinfo === 'function') return that.send(value, null, rinfo)\n    if (!cb) cb = noop\n    if (!rinfo) rinfo = me\n    else if (!rinfo.host && !rinfo.address) rinfo.address = me.address\n\n    bind(onbind)\n\n    function onbind (err) {\n      if (destroyed) return cb()\n      if (err) return cb(err)\n      var message = packet.encode(value)\n      socket.send(message, 0, message.length, rinfo.port, rinfo.address || rinfo.host, cb)\n    }\n  }\n\n  that.response =\n  that.respond = function (res, rinfo, cb) {\n    if (Array.isArray(res)) res = {answers: res}\n\n    res.type = 'response'\n    res.flags = (res.flags || 0) | packet.AUTHORITATIVE_ANSWER\n    that.send(res, rinfo, cb)\n  }\n\n  that.query = function (q, type, rinfo, cb) {\n    if (typeof type === 'function') return that.query(q, null, null, type)\n    if (typeof type === 'object' && type && type.port) return that.query(q, null, type, rinfo)\n    if (typeof rinfo === 'function') return that.query(q, type, null, rinfo)\n    if (!cb) cb = noop\n\n    if (typeof q === 'string') q = [{name: q, type: type || 'ANY'}]\n    if (Array.isArray(q)) q = {type: 'query', questions: q}\n\n    q.type = 'query'\n    that.send(q, rinfo, cb)\n  }\n\n  that.destroy = function (cb) {\n    if (!cb) cb = noop\n    if (destroyed) return process.nextTick(cb)\n    destroyed = true\n    clearInterval(interval)\n    socket.once('close', cb)\n    socket.close()\n  }\n\n  that.update = function () {\n    var ifaces = opts.interface ? [].concat(opts.interface) : allInterfaces()\n    var updated = false\n\n    for (var i = 0; i < ifaces.length; i++) {\n      var addr = ifaces[i]\n\n      if (memberships[addr]) continue\n      memberships[addr] = true\n      updated = true\n\n      try {\n        socket.addMembership(ip, addr)\n      } catch (err) {\n        that.emit('warning', err)\n      }\n    }\n\n    if (!updated || !socket.setMulticastInterface) return\n    socket.setMulticastInterface(opts.interface || defaultInterface())\n  }\n\n  return that\n}\n\nfunction defaultInterface () {\n  var networks = os.networkInterfaces()\n  var names = Object.keys(networks)\n\n  for (var i = 0; i < names.length; i++) {\n    var net = networks[names[i]]\n    for (var j = 0; j < net.length; j++) {\n      var iface = net[j]\n      if (iface.family === 'IPv4' && !iface.internal) return '0.0.0.0'\n    }\n  }\n\n  return '127.0.0.1'\n}\n\nfunction allInterfaces () {\n  var networks = os.networkInterfaces()\n  var names = Object.keys(networks)\n  var res = []\n\n  for (var i = 0; i < names.length; i++) {\n    var net = networks[names[i]]\n    for (var j = 0; j < net.length; j++) {\n      var iface = net[j]\n      if (iface.family === 'IPv4') {\n        res.push(iface.address)\n        // could only addMembership once per interface (https://nodejs.org/api/dgram.html#dgram_socket_addmembership_multicastaddress_multicastinterface)\n        break\n      }\n    }\n  }\n\n  return res\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","var set = require('unordered-set')\nvar lru = require('lru')\n\nmodule.exports = Store\n\nfunction Store (opts) {\n  if (!(this instanceof Store)) return new Store(opts)\n  if (!opts) opts = {}\n\n  this.maxValues = opts.values || Infinity\n  this.maxEntries = opts.records || Infinity\n  this.entries = lru(this.maxEntries)\n  this.limit = opts.limit || 10000\n  this.ttl = (opts.ttl || 0) * 1000\n  this.used = 0\n}\n\nStore.prototype.get = function (name, max) {\n  var entry = this.entries.get(name)\n  var result = []\n\n  if (!entry) return result\n  if (!max) max = entry.values.length\n\n  while (result.length < max) {\n    var i = result.length\n    if (i >= entry.values.length) return result\n\n    var missing = entry.values.length - i\n    var next = i + (Math.random() * missing) | 0\n    var val = entry.values[next]\n\n    if (this.ttl && (Date.now() - val._modified) > this.ttl) {\n      set.remove(entry.values, val)\n      this.used--\n\n      if (!entry.values.length) {\n        this.entries.remove(name)\n        return result\n      }\n    } else {\n      set.swap(entry.values, entry.values[i], val)\n      result.push(val)\n    }\n  }\n\n  return result\n}\n\nStore.prototype.remove = function (name, port, host) {\n  var address = host + ':' + port\n  var entry = this.entries.peek(name)\n  if (!entry) return\n\n  var peer = entry.byAddr.remove(address)\n  if (!peer) return\n\n  set.remove(entry.values, peer)\n  this.used--\n  if (!entry.values.length) this.entries.remove(name)\n}\n\nStore.prototype.add = function (name, port, host) {\n  var peer = new Peer(port, host)\n\n  if (this.used >= this.limit) this.evict()\n\n  var entry = this.entries.get(name)\n\n  if (!entry) {\n    entry = this.entries.set(name, new Record(name, this.maxValues))\n  }\n\n  var prev = entry.byAddr.get(peer.address)\n  var old = !!prev\n  if (!old) {\n    prev = peer\n    set.add(entry.values, peer)\n    entry.byAddr.set(peer.address, peer)\n    this.used++\n  }\n  if (this.ttl) prev._modified = Date.now()\n\n  return !old\n}\n\nStore.prototype.evict = function () {\n  var oldest = this.entries.tail && this.entries.peek(this.entries.tail)\n  if (!oldest) return\n\n  var oldestPeer = oldest.byAddr.tail && oldest.byAddr.remove(oldest.byAddr.tail)\n  if (!oldestPeer) return\n\n  set.remove(oldest.values, oldestPeer)\n  this.used--\n\n  if (!oldest.values.length) {\n    this.entries.remove(this.entries.tail)\n  }\n}\n\nStore.prototype.toJSON = function () {\n  var entries = []\n  var keys = Object.keys(this.entries.cache)\n  for (var i = 0; i < keys.length; i++) {\n    entries.push({\n      name: keys[i],\n      records: this.entries.peek(keys[i]).values\n    })\n  }\n  return entries\n}\n\nStore.prototype.getTopKeyStats = function (n) {\n  n = n || 10\n  var entries = []\n  var keys = Object.keys(this.entries.cache)\n  for (var i = 0; i < keys.length; i++) {\n    entries.push({\n      name: keys[i],\n      numRecords: this.entries.peek(keys[i]).values.length\n    })\n  }\n  entries.sort(function (a, b) {\n    return b.numRecords - a.numRecords\n  })\n  return entries.slice(0, n)\n}\n\nfunction Peer (port, host) {\n  this.host = host || '127.0.0.1'\n  this.port = port\n  this.address = this.host + ':' + this.port\n  this.buffer = null\n\n  this._modified = 0\n  this._index = 0\n}\n\nfunction Record (name, limit) {\n  this.name = name\n  this.values = []\n  this.byAddr = lru(limit || Infinity)\n}\n","exports.add = add\nexports.has = has\nexports.remove = remove\nexports.swap = swap\n\nfunction add (list, item) {\n  if (has(list, item)) return item\n  item._index = list.length\n  list.push(item)\n  return item\n}\n\nfunction has (list, item) {\n  return list[item._index] === item\n}\n\nfunction remove (list, item) {\n  if (!has(list, item)) return item\n\n  var last = list.pop()\n  if (last !== item) {\n    list[item._index] = last\n    last._index = item._index\n  }\n\n  return item\n}\n\nfunction swap (list, a, b) {\n  if (!has(list, a) || !has(list, b)) return\n  var tmp = a._index\n  a._index = b._index\n  list[a._index] = a\n  b._index = tmp\n  list[b._index] = b\n}\n","var events = require('events')\nvar inherits = require('inherits')\n\nmodule.exports = LRU\n\nfunction LRU (opts) {\n  if (!(this instanceof LRU)) return new LRU(opts)\n  if (typeof opts === 'number') opts = {max: opts}\n  if (!opts) opts = {}\n  events.EventEmitter.call(this)\n  this.cache = {}\n  this.head = this.tail = null\n  this.length = 0\n  this.max = opts.max || 1000\n  this.maxAge = opts.maxAge || 0\n}\n\ninherits(LRU, events.EventEmitter)\n\nLRU.prototype.remove = function (key) {\n  if (typeof key !== 'string') key = '' + key\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n  delete this.cache[key]\n  this._unlink(key, element.prev, element.next)\n  return element.value\n}\n\nLRU.prototype._unlink = function (key, prev, next) {\n  this.length--\n\n  if (this.length === 0) {\n    this.head = this.tail = null\n  } else {\n    if (this.head === key) {\n      this.head = prev\n      this.cache[this.head].next = null\n    } else if (this.tail === key) {\n      this.tail = next\n      this.cache[this.tail].prev = null\n    } else {\n      this.cache[prev].next = next\n      this.cache[next].prev = prev\n    }\n  }\n}\n\nLRU.prototype.peek = function (key) {\n  return this.cache.hasOwnProperty(key) ? this.cache[key].value : null\n}\n\nLRU.prototype.set = function (key, value) {\n  if (typeof key !== 'string') key = '' + key\n\n  var element\n\n  if (this.cache.hasOwnProperty(key)) {\n    element = this.cache[key]\n    element.value = value\n    if (this.maxAge) element.modified = Date.now()\n\n    // If it's already the head, there's nothing more to do:\n    if (key === this.head) return value\n    this._unlink(key, element.prev, element.next)\n  } else {\n    element = {value: value, modified: 0, next: null, prev: null}\n    if (this.maxAge) element.modified = Date.now()\n    this.cache[key] = element\n\n    // Eviction is only possible if the key didn't already exist:\n    if (this.length === this.max) this.evict()\n  }\n\n  this.length++\n  element.next = null\n  element.prev = this.head\n\n  if (this.head) this.cache[this.head].next = key\n  this.head = key\n\n  if (!this.tail) this.tail = key\n  return value\n}\n\nLRU.prototype.get = function (key) {\n  if (typeof key !== 'string') key = '' + key\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n\n  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {\n    this.remove(key)\n    this.emit('evict', {key: key, value: element.value})\n    return\n  }\n\n  if (this.head !== key) {\n    if (key === this.tail) {\n      this.tail = element.next\n      this.cache[this.tail].prev = null\n    } else {\n      // Set prev.next -> element.next:\n      this.cache[element.prev].next = element.next\n    }\n\n    // Set element.next.prev -> element.prev:\n    this.cache[element.next].prev = element.prev\n\n    // Element is the new head\n    this.cache[this.head].next = key\n    element.prev = this.head\n    element.next = null\n    this.head = key\n  }\n\n  return element.value\n}\n\nLRU.prototype.evict = function () {\n  if (!this.tail) return\n  var key = this.tail\n  var value = this.remove(this.tail)\n  this.emit('evict', {key: key, value: value})\n}\n","var Client = require('./client')\nvar Server = require('./server')\n\nmodule.exports = Client\nmodule.exports.Client = Client\nmodule.exports.Server = Server\n","module.exports = DHT\n\nvar bencode = require('bencode')\nvar Buffer = require('safe-buffer').Buffer\nvar debug = require('debug')('bittorrent-dht')\nvar equals = require('buffer-equals')\nvar EventEmitter = require('events').EventEmitter\nvar inherits = require('inherits')\nvar KBucket = require('k-bucket')\nvar krpc = require('k-rpc')\nvar LRU = require('lru')\nvar randombytes = require('randombytes')\nvar simpleSha1 = require('simple-sha1')\nvar PeerStore = require('./peer-store')\n\nvar ROTATE_INTERVAL = 5 * 60 * 1000 // rotate secrets every 5 minutes\nvar BUCKET_OUTDATED_TIMESPAN = 15 * 60 * 1000 // check nodes in bucket in 15 minutes old buckets\n\ninherits(DHT, EventEmitter)\n\nfunction DHT (opts) {\n  if (!(this instanceof DHT)) return new DHT(opts)\n  if (!opts) opts = {}\n\n  var self = this\n\n  this._tables = LRU({maxAge: ROTATE_INTERVAL, max: opts.maxTables || 1000})\n  this._values = LRU(opts.maxValues || 1000)\n  this._peers = new PeerStore({\n    maxAge: opts.maxAge || Infinity,\n    max: opts.maxPeers || 10000\n  })\n\n  this._secrets = null\n  this._hash = opts.hash || sha1\n  this._hashLength = this._hash(Buffer.from('')).length\n  this._rpc = opts.krpc || krpc(Object.assign({idLength: this._hashLength}, opts))\n  this._rpc.on('query', onquery)\n  this._rpc.on('node', onnode)\n  this._rpc.on('warning', onwarning)\n  this._rpc.on('error', onerror)\n  this._rpc.on('listening', onlistening)\n  this._rotateSecrets()\n  this._verify = opts.verify || null\n  this._host = opts.host || null\n  this._interval = setInterval(rotateSecrets, ROTATE_INTERVAL)\n  this._runningBucketCheck = false\n  this._bucketCheckTimeout = null\n  this._bucketOutdatedTimeSpan = opts.timeBucketOutdated || BUCKET_OUTDATED_TIMESPAN\n\n  this.listening = false\n  this.destroyed = false\n  this.nodeId = this._rpc.id\n  this.nodes = this._rpc.nodes\n\n  this.nodes.on('ping', function (nodes, contact) {\n    self._debug('received ping', nodes, contact)\n    self._checkAndRemoveNodes(nodes, function (_, removed) {\n      if (removed) {\n        self._debug('added new node:', contact)\n        self.addNode(contact)\n      }\n\n      self._debug('no node added, all other nodes ok')\n    })\n  })\n\n  process.nextTick(bootstrap)\n\n  EventEmitter.call(this)\n  this._debug('new DHT %s', this.nodeId)\n\n  function onlistening () {\n    self.listening = true\n    self._debug('listening %d', self.address().port)\n    self.emit('listening')\n  }\n\n  function onquery (query, peer) {\n    self._onquery(query, peer)\n  }\n\n  function rotateSecrets () {\n    self._rotateSecrets()\n  }\n\n  function bootstrap () {\n    if (!self.destroyed) self._bootstrap(opts.bootstrap !== false)\n  }\n\n  function onwarning (err) {\n    self.emit('warning', err)\n  }\n\n  function onerror (err) {\n    self.emit('error', err)\n  }\n\n  function onnode (node) {\n    self.emit('node', node)\n  }\n}\n\nDHT.prototype._setBucketCheckInterval = function () {\n  var self = this\n  var interval = 1 * 60 * 1000 // check age of bucket every minute\n\n  this._runningBucketCheck = true\n  queueNext()\n\n  function checkBucket () {\n    const diff = Date.now() - self._rpc.nodes.metadata.lastChange\n\n    if (diff < self._bucketOutdatedTimeSpan) return queueNext()\n\n    self._pingAll(function () {\n      if (self.destroyed) return\n\n      if (self.nodes.toArray().length < 1) {\n        // node is currently isolated,\n        // retry with initial bootstrap nodes\n        self._bootstrap(true)\n      }\n\n      queueNext()\n    })\n  }\n\n  function queueNext () {\n    if (!self._runningBucketCheck || self.destroyed) return\n    var nextTimeout = Math.floor(Math.random() * interval + interval / 2)\n    self._bucketCheckTimeout = setTimeout(checkBucket, nextTimeout)\n  }\n}\n\nDHT.prototype._pingAll = function (cb) {\n  this._checkAndRemoveNodes(this.nodes.toArray(), cb)\n}\n\nDHT.prototype.removeBucketCheckInterval = function () {\n  this._runningBucketCheck = false\n  clearTimeout(this._bucketCheckTimeout)\n}\n\nDHT.prototype.updateBucketTimestamp = function () {\n  this._rpc.nodes.metadata.lastChange = Date.now()\n}\n\nDHT.prototype._checkAndRemoveNodes = function (nodes, cb) {\n  var self = this\n\n  this._checkNodes(nodes, function (_, node) {\n    if (node) self.removeNode(node.id)\n    cb(null, node)\n  })\n}\n\nDHT.prototype._checkNodes = function (nodes, cb) {\n  var self = this\n\n  function test (acc) {\n    if (!acc.length) {\n      return cb(null)\n    }\n\n    var current = acc.pop()\n\n    self._sendPing(current, function (err) {\n      if (!err) {\n        self.updateBucketTimestamp()\n        return test(acc)\n      }\n\n      // retry\n      self._sendPing(current, function (er) {\n        if (err) {\n          return cb(null, current)\n        }\n\n        self.updateBucketTimestamp()\n        return test(acc)\n      })\n    })\n  }\n\n  test(nodes)\n}\n\nDHT.prototype.addNode = function (node) {\n  var self = this\n  if (node.id) {\n    node.id = toBuffer(node.id)\n    var old = !!this._rpc.nodes.get(node.id)\n    this._rpc.nodes.add(node)\n    if (!old) {\n      this.emit('node', node)\n      this.updateBucketTimestamp()\n    }\n    return\n  }\n  this._sendPing(node, function (_, node) {\n    if (node) self.addNode(node)\n  })\n}\n\nDHT.prototype.removeNode = function (id) {\n  this._rpc.nodes.remove(toBuffer(id))\n}\n\nDHT.prototype._sendPing = function (node, cb) {\n  var self = this\n  var expectedId = node.id\n  this._rpc.query(node, {q: 'ping'}, function (err, pong, node) {\n    if (err) return cb(err)\n    if (!pong.r || !pong.r.id || !Buffer.isBuffer(pong.r.id) || pong.r.id.length !== self._hashLength) {\n      return cb(new Error('Bad reply'))\n    }\n    if (Buffer.isBuffer(expectedId) && !expectedId.equals(pong.r.id)) {\n      return cb(new Error('Unexpected node id'))\n    }\n\n    self.updateBucketTimestamp()\n    cb(null, {\n      id: pong.r.id,\n      host: node.host || node.address,\n      port: node.port\n    })\n  })\n}\n\nDHT.prototype.toJSON = function () {\n  var self = this\n  var values = {}\n  Object.keys(this._values.cache).forEach(function (key) {\n    var value = self._values.cache[key].value\n    values[key] = {\n      v: value.v.toString('hex'),\n      id: value.id.toString('hex')\n    }\n    if (value.seq != null) values[key].seq = value.seq\n    if (value.sig != null) values[key].sig = value.sig.toString('hex')\n    if (value.k != null) values[key].k = value.k.toString('hex')\n  })\n  return {\n    nodes: this._rpc.nodes.toArray().map(toNode),\n    values: values\n  }\n}\n\nDHT.prototype.put = function (opts, cb) {\n  if (Buffer.isBuffer(opts) || typeof opts === 'string') opts = {v: opts}\n  var isMutable = !!opts.k\n  if (opts.v === undefined) {\n    throw new Error('opts.v not given')\n  }\n  if (opts.v.length >= 1000) {\n    throw new Error('v must be less than 1000 bytes in put()')\n  }\n  if (isMutable && opts.cas !== undefined && typeof opts.cas !== 'number') {\n    throw new Error('opts.cas must be an integer if provided')\n  }\n  if (isMutable && !opts.k) {\n    throw new Error('opts.k ed25519 public key required for mutable put')\n  }\n  if (isMutable && opts.k.length !== 32) {\n    throw new Error('opts.k ed25519 public key must be 32 bytes')\n  }\n  if (isMutable && typeof opts.sign !== 'function' && !Buffer.isBuffer(opts.sig)) {\n    throw new Error('opts.sign function or options.sig signature is required for mutable put')\n  }\n  if (isMutable && opts.salt && opts.salt.length > 64) {\n    throw new Error('opts.salt is > 64 bytes long')\n  }\n  if (isMutable && opts.seq === undefined) {\n    throw new Error('opts.seq not provided for a mutable update')\n  }\n  if (isMutable && typeof opts.seq !== 'number') {\n    throw new Error('opts.seq not an integer')\n  }\n\n  return this._put(opts, cb)\n}\n\nDHT.prototype._put = function (opts, cb) {\n  if (!cb) cb = noop\n\n  var isMutable = !!opts.k\n  var v = typeof opts.v === 'string' ? Buffer.from(opts.v) : opts.v\n  var key = isMutable\n    ? this._hash(opts.salt ? Buffer.concat([opts.k, opts.salt]) : opts.k)\n    : this._hash(bencode.encode(v))\n\n  var table = this._tables.get(key.toString('hex'))\n  if (!table) return this._preput(key, opts, cb)\n\n  var message = {\n    q: 'put',\n    a: {\n      id: this._rpc.id,\n      token: null, // queryAll sets this\n      v: v\n    }\n  }\n\n  if (isMutable) {\n    if (typeof opts.cas === 'number') message.a.cas = opts.cas\n    if (opts.salt) message.a.salt = opts.salt\n    message.a.k = opts.k\n    message.a.seq = opts.seq\n    if (typeof opts.sign === 'function') message.a.sig = opts.sign(encodeSigData(message.a))\n    else if (Buffer.isBuffer(opts.sig)) message.a.sig = opts.sig\n  }\n\n  this._values.set(key.toString('hex'), message.a)\n  this._rpc.queryAll(table.closest(key), message, null, function (err, n) {\n    if (err) return cb(err, key, n)\n    cb(null, key, n)\n  })\n\n  return key\n}\n\nDHT.prototype._preput = function (key, opts, cb) {\n  var self = this\n\n  this._closest(key, {\n    q: 'get',\n    a: {\n      id: this._rpc.id,\n      target: key\n    }\n  }, null, function (err, n) {\n    if (err) return cb(err)\n    self.put(opts, cb)\n  })\n\n  return key\n}\n\nDHT.prototype.get = function (key, opts, cb) {\n  key = toBuffer(key)\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = null\n  }\n\n  if (!opts) opts = {}\n  var verify = opts.verify || this._verify\n  var hash = this._hash\n  var value = this._values.get(key.toString('hex')) || null\n\n  if (value) {\n    value = createGetResponse(this._rpc.id, null, value)\n    return process.nextTick(done)\n  }\n\n  this._closest(key, {\n    q: 'get',\n    a: {\n      id: this._rpc.id,\n      target: key\n    }\n  }, onreply, done)\n\n  function done (err) {\n    if (err) return cb(err)\n    cb(null, value)\n  }\n\n  function onreply (message) {\n    var r = message.r\n    if (!r || !r.v) return true\n\n    var isMutable = r.k || r.sig\n\n    if (isMutable) {\n      if (!verify || !r.sig || !r.k) return true\n      if (!verify(r.sig, encodeSigData(r), r.k)) return true\n      if (equals(hash(r.salt ? Buffer.concat([r.k, r.salt]) : r.k), key)) {\n        value = r\n        return false\n      }\n    } else {\n      if (equals(hash(bencode.encode(r.v)), key)) {\n        value = r\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nDHT.prototype.announce = function (infoHash, port, cb) {\n  if (typeof port === 'function') return this.announce(infoHash, 0, port)\n  infoHash = toBuffer(infoHash)\n  if (!cb) cb = noop\n\n  var table = this._tables.get(infoHash.toString('hex'))\n  if (!table) return this._preannounce(infoHash, port, cb)\n\n  if (this._host) {\n    var dhtPort = this.listening ? this.address().port : 0\n    this._addPeer(\n      {host: this._host, port: port || dhtPort},\n      infoHash,\n      {host: this._host, port: dhtPort}\n    )\n  }\n\n  var message = {\n    q: 'announce_peer',\n    a: {\n      id: this._rpc.id,\n      token: null, // queryAll sets this\n      info_hash: infoHash,\n      port: port,\n      implied_port: port ? 0 : 1\n    }\n  }\n\n  this._debug('announce %s %d', infoHash, port)\n  this._rpc.queryAll(table.closest(infoHash), message, null, cb)\n}\n\nDHT.prototype._preannounce = function (infoHash, port, cb) {\n  var self = this\n\n  this.lookup(infoHash, function (err) {\n    if (self.destroyed) return cb(new Error('dht is destroyed'))\n    if (err) return cb(err)\n    self.announce(infoHash, port, cb)\n  })\n}\n\nDHT.prototype.lookup = function (infoHash, cb) {\n  infoHash = toBuffer(infoHash)\n  if (!cb) cb = noop\n  var self = this\n  var aborted = false\n\n  this._debug('lookup %s', infoHash)\n  process.nextTick(emit)\n  this._closest(infoHash, {\n    q: 'get_peers',\n    a: {\n      id: this._rpc.id,\n      info_hash: infoHash\n    }\n  }, onreply, cb)\n\n  function emit (values, from) {\n    if (!values) values = self._peers.get(infoHash.toString('hex'))\n    var peers = decodePeers(values)\n    for (var i = 0; i < peers.length; i++) {\n      self.emit('peer', peers[i], infoHash, from || null)\n    }\n  }\n\n  function onreply (message, node) {\n    if (aborted) return false\n    if (message.r.values) emit(message.r.values, node)\n  }\n\n  return function abort () { aborted = true }\n}\n\nDHT.prototype.address = function () {\n  return this._rpc.address()\n}\n\n// listen([port], [address], [onlistening])\nDHT.prototype.listen = function () {\n  this._rpc.bind.apply(this._rpc, arguments)\n\n  this.updateBucketTimestamp()\n  this._setBucketCheckInterval()\n}\n\nDHT.prototype.destroy = function (cb) {\n  if (this.destroyed) {\n    if (cb) process.nextTick(cb)\n    return\n  }\n  this.destroyed = true\n  var self = this\n  clearInterval(this._interval)\n  this.removeBucketCheckInterval()\n  this._debug('destroying')\n  this._rpc.destroy(function () {\n    self.emit('close')\n    if (cb) cb()\n  })\n}\n\nDHT.prototype._onquery = function (query, peer) {\n  var q = query.q.toString()\n  this._debug('received %s query from %s:%d', q, peer.address, peer.port)\n  if (!query.a) return\n\n  switch (q) {\n    case 'ping':\n      return this._rpc.response(peer, query, {id: this._rpc.id})\n\n    case 'find_node':\n      return this._onfindnode(query, peer)\n\n    case 'get_peers':\n      return this._ongetpeers(query, peer)\n\n    case 'announce_peer':\n      return this._onannouncepeer(query, peer)\n\n    case 'get':\n      return this._onget(query, peer)\n\n    case 'put':\n      return this._onput(query, peer)\n  }\n}\n\nDHT.prototype._onfindnode = function (query, peer) {\n  var target = query.a.target\n  if (!target) return this._rpc.error(peer, query, [203, '`find_node` missing required `a.target` field'])\n\n  this.emit('find_node', target)\n\n  var nodes = this._rpc.nodes.closest(target)\n  this._rpc.response(peer, query, {id: this._rpc.id}, nodes)\n}\n\nDHT.prototype._ongetpeers = function (query, peer) {\n  var host = peer.address || peer.host\n  var infoHash = query.a.info_hash\n  if (!infoHash) return this._rpc.error(peer, query, [203, '`get_peers` missing required `a.info_hash` field'])\n\n  this.emit('get_peers', infoHash)\n\n  var r = {id: this._rpc.id, token: this._generateToken(host)}\n  var peers = this._peers.get(infoHash.toString('hex'))\n\n  if (peers.length) {\n    r.values = peers\n    this._rpc.response(peer, query, r)\n  } else {\n    this._rpc.response(peer, query, r, this._rpc.nodes.closest(infoHash))\n  }\n}\n\nDHT.prototype._onannouncepeer = function (query, peer) {\n  var host = peer.address || peer.host\n  var port = query.a.implied_port ? peer.port : query.a.port\n  if (!port || typeof port !== 'number' || port <= 0 || port > 65535) return\n  var infoHash = query.a.info_hash\n  var token = query.a.token\n  if (!infoHash || !token) return\n\n  if (!this._validateToken(host, token)) {\n    return this._rpc.error(peer, query, [203, 'cannot `announce_peer` with bad token'])\n  }\n\n  this.emit('announce_peer', infoHash, {host: host, port: peer.port})\n\n  this._addPeer({host: host, port: port}, infoHash, {host: host, port: peer.port})\n  this._rpc.response(peer, query, {id: this._rpc.id})\n}\n\nDHT.prototype._addPeer = function (peer, infoHash, from) {\n  this._peers.add(infoHash.toString('hex'), encodePeer(peer.host, peer.port))\n  this.emit('announce', peer, infoHash, from)\n}\n\nDHT.prototype._onget = function (query, peer) {\n  var host = peer.address || peer.host\n  var target = query.a.target\n  if (!target) return\n  var token = this._generateToken(host)\n  var value = this._values.get(target.toString('hex'))\n\n  this.emit('get', target, value)\n\n  if (!value) {\n    var nodes = this._rpc.nodes.closest(target)\n    this._rpc.response(peer, query, {id: this._rpc.id, token: token}, nodes)\n  } else {\n    this._rpc.response(peer, query, createGetResponse(this._rpc.id, token, value))\n  }\n}\n\nDHT.prototype._onput = function (query, peer) {\n  var host = peer.address || peer.host\n\n  var a = query.a\n  if (!a) return\n  var v = query.a.v\n  if (!v) return\n  var id = query.a.id\n  if (!id) return\n\n  var token = a.token\n  if (!token) return\n\n  if (!this._validateToken(host, token)) {\n    return this._rpc.error(peer, query, [203, 'cannot `put` with bad token'])\n  }\n  if (v.length > 1000) {\n    return this._rpc.error(peer, query, [205, 'data payload too large'])\n  }\n\n  var isMutable = !!(a.k || a.sig)\n  if (isMutable && !a.k && !a.sig) return\n\n  var key = isMutable\n    ? this._hash(a.salt ? Buffer.concat([a.k, a.salt]) : a.k)\n    : this._hash(bencode.encode(v))\n  var keyHex = key.toString('hex')\n\n  this.emit('put', key, v)\n\n  if (isMutable) {\n    if (!this._verify) return this._rpc.error(peer, query, [400, 'verification not supported'])\n    if (!this._verify(a.sig, encodeSigData(a), a.k)) return\n    var prev = this._values.get(keyHex)\n    if (prev && typeof a.cas === 'number' && prev.seq !== a.cas) {\n      return this._rpc.error(peer, query, [301, 'CAS mismatch, re-read and try again'])\n    }\n    if (prev && typeof prev.seq === 'number' && !(a.seq > prev.seq)) {\n      return this._rpc.error(peer, query, [302, 'sequence number less than current'])\n    }\n    this._values.set(keyHex, {v: v, k: a.k, salt: a.salt, sig: a.sig, seq: a.seq, id: id})\n  } else {\n    this._values.set(keyHex, {v: v, id: id})\n  }\n\n  this._rpc.response(peer, query, {id: this._rpc.id})\n}\n\nDHT.prototype._bootstrap = function (populate) {\n  var self = this\n  if (!populate) return process.nextTick(ready)\n\n  this._rpc.populate(self._rpc.id, {\n    q: 'find_node',\n    a: {\n      id: self._rpc.id,\n      target: self._rpc.id\n    }\n  }, ready)\n\n  function ready () {\n    if (self.ready) return\n\n    self._debug('emit ready')\n    self.ready = true\n    self.emit('ready')\n  }\n}\n\nDHT.prototype._closest = function (target, message, onmessage, cb) {\n  var self = this\n\n  var table = new KBucket({\n    localNodeId: target,\n    numberOfNodesPerKBucket: this._rpc.k\n  })\n\n  this._rpc.closest(target, message, onreply, done)\n\n  function done (err, n) {\n    if (err) return cb(err)\n    self._tables.set(target.toString('hex'), table)\n    self._debug('visited %d nodes', n)\n    cb(null, n)\n  }\n\n  function onreply (message, node) {\n    if (!message.r) return true\n\n    if (message.r.token && message.r.id && Buffer.isBuffer(message.r.id) && message.r.id.length === self._hashLength) {\n      self._debug('found node %s (target: %s)', message.r.id, target)\n      table.add({\n        id: message.r.id,\n        host: node.host || node.address,\n        port: node.port,\n        token: message.r.token\n      })\n    }\n\n    if (!onmessage) return true\n    return onmessage(message, node)\n  }\n}\n\nDHT.prototype._debug = function () {\n  if (!debug.enabled) return\n  var args = [].slice.call(arguments)\n  args[0] = '[' + this.nodeId.toString('hex').substring(0, 7) + '] ' + args[0]\n  for (var i = 1; i < args.length; i++) {\n    if (Buffer.isBuffer(args[i])) args[i] = args[i].toString('hex')\n  }\n  debug.apply(null, args)\n}\n\nDHT.prototype._validateToken = function (host, token) {\n  var tokenA = this._generateToken(host, this._secrets[0])\n  var tokenB = this._generateToken(host, this._secrets[1])\n  return equals(token, tokenA) || equals(token, tokenB)\n}\n\nDHT.prototype._generateToken = function (host, secret) {\n  if (!secret) secret = this._secrets[0]\n  return this._hash(Buffer.concat([Buffer.from(host), secret]))\n}\n\nDHT.prototype._rotateSecrets = function () {\n  if (!this._secrets) {\n    this._secrets = [randombytes(this._hashLength), randombytes(this._hashLength)]\n  } else {\n    this._secrets[1] = this._secrets[0]\n    this._secrets[0] = randombytes(this._hashLength)\n  }\n}\n\nfunction noop () {}\n\nfunction sha1 (buf) {\n  return Buffer.from(simpleSha1.sync(buf), 'hex')\n}\n\nfunction createGetResponse (id, token, value) {\n  var r = {id: id, token: token, v: value.v}\n  if (value.sig) {\n    r.sig = value.sig\n    r.k = value.k\n    if (value.salt) r.salt = value.salt\n    if (typeof value.seq === 'number') r.seq = value.seq\n  }\n  return r\n}\n\nfunction encodePeer (host, port) {\n  var buf = Buffer.allocUnsafe(6)\n  var ip = host.split('.')\n  for (var i = 0; i < 4; i++) buf[i] = parseInt(ip[i] || 0, 10)\n  buf.writeUInt16BE(port, 4)\n  return buf\n}\n\nfunction decodePeers (buf) {\n  var peers = []\n\n  try {\n    for (var i = 0; i < buf.length; i++) {\n      var port = buf[i].readUInt16BE(4)\n      if (!port) continue\n      peers.push({\n        host: parseIp(buf[i], 0),\n        port: port\n      })\n    }\n  } catch (err) {\n    // do nothing\n  }\n\n  return peers\n}\n\nfunction parseIp (buf, offset) {\n  return buf[offset++] + '.' + buf[offset++] + '.' + buf[offset++] + '.' + buf[offset++]\n}\n\nfunction encodeSigData (msg) {\n  var ref = { seq: msg.seq || 0, v: msg.v }\n  if (msg.salt) ref.salt = msg.salt\n  return bencode.encode(ref).slice(1, -1)\n}\n\nfunction toNode (node) {\n  return {\n    host: node.host,\n    port: node.port\n  }\n}\n\nfunction toBuffer (str) {\n  if (Buffer.isBuffer(str)) return str\n  if (typeof str === 'string') return Buffer.from(str, 'hex')\n  throw new Error('Pass a buffer or a string')\n}\n","var bencode = module.exports\n\nbencode.encode = require('./encode')\nbencode.decode = require('./decode')\n\n/**\n * Determines the amount of bytes\n * needed to encode the given value\n * @param  {Object|Array|Buffer|String|Number|Boolean} value\n * @return {Number} byteCount\n */\nbencode.byteLength = bencode.encodingLength = function (value) {\n  return bencode.encode(value).length\n}\n","var Buffer = require('safe-buffer').Buffer\n\n/**\n * Encodes data in bencode.\n *\n * @param  {Buffer|Array|String|Object|Number|Boolean} data\n * @return {Buffer}\n */\nfunction encode (data, buffer, offset) {\n  var buffers = []\n  var result = null\n\n  encode._encode(buffers, data)\n  result = Buffer.concat(buffers)\n  encode.bytes = result.length\n\n  if (Buffer.isBuffer(buffer)) {\n    result.copy(buffer, offset)\n    return buffer\n  }\n\n  return result\n}\n\nencode.bytes = -1\nencode._floatConversionDetected = false\n\nencode._encode = function (buffers, data) {\n  if (Buffer.isBuffer(data)) {\n    buffers.push(Buffer.from(data.length + ':'))\n    buffers.push(data)\n    return\n  }\n\n  if (data == null) { return }\n\n  switch (typeof data) {\n    case 'string':\n      encode.buffer(buffers, data)\n      break\n    case 'number':\n      encode.number(buffers, data)\n      break\n    case 'object':\n      data.constructor === Array\n        ? encode.list(buffers, data)\n        : encode.dict(buffers, data)\n      break\n    case 'boolean':\n      encode.number(buffers, data ? 1 : 0)\n      break\n  }\n}\n\nvar buffE = Buffer.from('e')\nvar buffD = Buffer.from('d')\nvar buffL = Buffer.from('l')\n\nencode.buffer = function (buffers, data) {\n  buffers.push(Buffer.from(Buffer.byteLength(data) + ':' + data))\n}\n\nencode.number = function (buffers, data) {\n  var maxLo = 0x80000000\n  var hi = (data / maxLo) << 0\n  var lo = (data % maxLo) << 0\n  var val = hi * maxLo + lo\n\n  buffers.push(Buffer.from('i' + val + 'e'))\n\n  if (val !== data && !encode._floatConversionDetected) {\n    encode._floatConversionDetected = true\n    console.warn(\n      'WARNING: Possible data corruption detected with value \"' + data + '\":',\n      'Bencoding only defines support for integers, value was converted to \"' + val + '\"'\n    )\n    console.trace()\n  }\n}\n\nencode.dict = function (buffers, data) {\n  buffers.push(buffD)\n\n  var j = 0\n  var k\n  // fix for issue #13 - sorted dicts\n  var keys = Object.keys(data).sort()\n  var kl = keys.length\n\n  for (; j < kl; j++) {\n    k = keys[j]\n    if (data[k] == null) continue\n    encode.buffer(buffers, k)\n    encode._encode(buffers, data[k])\n  }\n\n  buffers.push(buffE)\n}\n\nencode.list = function (buffers, data) {\n  var i = 0\n  var c = data.length\n  buffers.push(buffL)\n\n  for (; i < c; i++) {\n    if (data[i] == null) continue\n    encode._encode(buffers, data[i])\n  }\n\n  buffers.push(buffE)\n}\n\nmodule.exports = encode\n","const INTEGER_START = 0x69 // 'i'\nconst STRING_DELIM = 0x3A // ':'\nconst DICTIONARY_START = 0x64 // 'd'\nconst LIST_START = 0x6C // 'l'\nconst END_OF_TYPE = 0x65 // 'e'\n\n/**\n * replaces parseInt(buffer.toString('ascii', start, end)).\n * For strings with less then ~30 charachters, this is actually a lot faster.\n *\n * @param {Buffer} data\n * @param {Number} start\n * @param {Number} end\n * @return {Number} calculated number\n */\nfunction getIntFromBuffer (buffer, start, end) {\n  var sum = 0\n  var sign = 1\n\n  for (var i = start; i < end; i++) {\n    var num = buffer[i]\n\n    if (num < 58 && num >= 48) {\n      sum = sum * 10 + (num - 48)\n      continue\n    }\n\n    if (i === start && num === 43) { // +\n      continue\n    }\n\n    if (i === start && num === 45) { // -\n      sign = -1\n      continue\n    }\n\n    if (num === 46) { // .\n      // its a float. break here.\n      break\n    }\n\n    throw new Error('not a number: buffer[' + i + '] = ' + num)\n  }\n\n  return sum * sign\n}\n\n/**\n * Decodes bencoded data.\n *\n * @param  {Buffer} data\n * @param  {Number} start (optional)\n * @param  {Number} end (optional)\n * @param  {String} encoding (optional)\n * @return {Object|Array|Buffer|String|Number}\n */\nfunction decode (data, start, end, encoding) {\n  if (data == null || data.length === 0) {\n    return null\n  }\n\n  if (typeof start !== 'number' && encoding == null) {\n    encoding = start\n    start = undefined\n  }\n\n  if (typeof end !== 'number' && encoding == null) {\n    encoding = end\n    end = undefined\n  }\n\n  decode.position = 0\n  decode.encoding = encoding || null\n\n  decode.data = !(Buffer.isBuffer(data))\n    ? new Buffer(data)\n    : data.slice(start, end)\n\n  decode.bytes = decode.data.length\n\n  return decode.next()\n}\n\ndecode.bytes = 0\ndecode.position = 0\ndecode.data = null\ndecode.encoding = null\n\ndecode.next = function () {\n  switch (decode.data[decode.position]) {\n    case DICTIONARY_START:\n      return decode.dictionary()\n    case LIST_START:\n      return decode.list()\n    case INTEGER_START:\n      return decode.integer()\n    default:\n      return decode.buffer()\n  }\n}\n\ndecode.find = function (chr) {\n  var i = decode.position\n  var c = decode.data.length\n  var d = decode.data\n\n  while (i < c) {\n    if (d[i] === chr) return i\n    i++\n  }\n\n  throw new Error(\n    'Invalid data: Missing delimiter \"' +\n    String.fromCharCode(chr) + '\" [0x' +\n    chr.toString(16) + ']'\n  )\n}\n\ndecode.dictionary = function () {\n  decode.position++\n\n  var dict = {}\n\n  while (decode.data[decode.position] !== END_OF_TYPE) {\n    dict[decode.buffer()] = decode.next()\n  }\n\n  decode.position++\n\n  return dict\n}\n\ndecode.list = function () {\n  decode.position++\n\n  var lst = []\n\n  while (decode.data[decode.position] !== END_OF_TYPE) {\n    lst.push(decode.next())\n  }\n\n  decode.position++\n\n  return lst\n}\n\ndecode.integer = function () {\n  var end = decode.find(END_OF_TYPE)\n  var number = getIntFromBuffer(decode.data, decode.position + 1, end)\n\n  decode.position += end + 1 - decode.position\n\n  return number\n}\n\ndecode.buffer = function () {\n  var sep = decode.find(STRING_DELIM)\n  var length = getIntFromBuffer(decode.data, decode.position, sep)\n  var end = ++sep + length\n\n  decode.position = end\n\n  return decode.encoding\n    ? decode.data.toString(decode.encoding, sep, end)\n    : decode.data.slice(sep, end)\n}\n\nmodule.exports = decode\n","\"use strict\";\n\n/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n\n","\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = require('./common')(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n","\"use strict\";\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = require('ms');\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n","\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar tty = require('tty');\n\nvar util = require('util');\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var supportsColor = require('supports-color');\n\n  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];\n  }\n} catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // Camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  }); // Coerce string value into JS value\n\n  var val = process.env[key];\n\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true;\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false;\n  } else if (val === 'null') {\n    val = null;\n  } else {\n    val = Number(val);\n  }\n\n  obj[prop] = val;\n  return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var name = this.namespace,\n      useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = \"\\x1B[3\" + (c < 8 ? c : '8;5;' + c);\n    var prefix = \"  \".concat(colorCode, \";1m\").concat(name, \" \\x1B[0m\");\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + \"\\x1B[0m\");\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  }\n\n  return new Date().toISOString() + ' ';\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env.DEBUG = namespaces;\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\nmodule.exports = require('./common')(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts).replace(/\\s*\\n\\s*/g, ' ');\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\n\nformatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n","/*\nindex.js - Kademlia DHT K-bucket implementation as a binary tree.\n\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 Tristan Slominski\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n'use strict'\n\nvar bufferEquals = require('buffer-equals')\nvar randomBytes = require('randombytes')\nvar EventEmitter = require('events').EventEmitter\nvar inherits = require('inherits')\n\nmodule.exports = KBucket\n\nfunction createNode () {\n  return { contacts: [], dontSplit: false, left: null, right: null }\n}\n\n/*\n  * `options`:\n    * `distance`: _Function_\n        `function (firstId, secondId) { return distance }` An optional\n        `distance` function that gets two `id` Buffers\n        and return distance (as number) between them.\n    * `arbiter`: _Function_ _(Default: vectorClock arbiter)_\n        `function (incumbent, candidate) { return contact; }` An optional\n        `arbiter` function that givent two `contact` objects with the same `id`\n        returns the desired object to be used for updating the k-bucket. For\n        more details, see [arbiter function](#arbiter-function).\n    * `localNodeId`: _Buffer_ An optional Buffer representing the local node id.\n        If not provided, a local node id will be created via\n        `crypto.randomBytes(20)`.\n    * `metadata`: _Object_ _(Default: {})_ Optional satellite data to include\n        with the k-bucket. `metadata` property is guaranteed not be altered by,\n        it is provided as an explicit container for users of k-bucket to store\n        implementation-specific data.\n    * `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes\n        that a k-bucket can contain before being full or split.\n    * `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to\n        ping when a bucket that should not be split becomes full. KBucket will\n        emit a `ping` event that contains `numberOfNodesToPing` nodes that have\n        not been contacted the longest.\n*/\nfunction KBucket (options) {\n  EventEmitter.call(this)\n  options = options || {}\n\n  this.localNodeId = options.localNodeId || randomBytes(20)\n  if (!Buffer.isBuffer(this.localNodeId)) throw new TypeError('localNodeId is not a Buffer')\n  this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20\n  this.numberOfNodesToPing = options.numberOfNodesToPing || 3\n  this.distance = options.distance || KBucket.distance\n  // use an arbiter from options or vectorClock arbiter by default\n  this.arbiter = options.arbiter || KBucket.arbiter\n\n  this.root = createNode()\n\n  this.metadata = Object.assign({}, options.metadata)\n}\n\ninherits(KBucket, EventEmitter)\n\nKBucket.arbiter = function (incumbent, candidate) {\n  return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate\n}\n\nKBucket.distance = function (firstId, secondId) {\n  var distance = 0\n  var min = Math.min(firstId.length, secondId.length)\n  var max = Math.max(firstId.length, secondId.length)\n  for (var i = 0; i < min; ++i) distance = distance * 256 + (firstId[i] ^ secondId[i])\n  for (; i < max; ++i) distance = distance * 256 + 255\n  return distance\n}\n\n// contact: *required* the contact object to add\nKBucket.prototype.add = function (contact) {\n  if (!contact || !Buffer.isBuffer(contact.id)) throw new TypeError('contact.id is not a Buffer')\n  var bitIndex = 0\n\n  var node = this.root\n  while (node.contacts === null) {\n    // this is not a leaf node but an inner node with 'low' and 'high'\n    // branches; we will check the appropriate bit of the identifier and\n    // delegate to the appropriate node for further processing\n    node = this._determineNode(node, contact.id, bitIndex++)\n  }\n\n  // check if the contact already exists\n  var index = this._indexOf(node, contact.id)\n  if (index >= 0) {\n    this._update(node, index, contact)\n    return this\n  }\n\n  if (node.contacts.length < this.numberOfNodesPerKBucket) {\n    node.contacts.push(contact)\n    this.emit('added', contact)\n    return this\n  }\n\n  // the bucket is full\n  if (node.dontSplit) {\n    // we are not allowed to split the bucket\n    // we need to ping the first this.numberOfNodesToPing\n    // in order to determine if they are alive\n    // only if one of the pinged nodes does not respond, can the new contact\n    // be added (this prevents DoS flodding with new invalid contacts)\n    this.emit('ping', node.contacts.slice(0, this.numberOfNodesToPing), contact)\n    return this\n  }\n\n  this._split(node, bitIndex)\n  return this.add(contact)\n}\n\n// id: Buffer *required* node id\n// n: Integer (Default: Infinity) maximum number of closest contacts to return\n// Return: Array of maximum of `n` closest contacts to the node id\nKBucket.prototype.closest = function (id, n) {\n  if (!Buffer.isBuffer(id)) throw new TypeError('id is not a Buffer')\n  if (n === undefined) n = Infinity\n  if (typeof n !== 'number' || isNaN(n) || n <= 0) throw new TypeError('n is not positive number')\n  var contacts = []\n\n  for (var nodes = [ this.root ], bitIndex = 0; nodes.length > 0 && contacts.length < n;) {\n    var node = nodes.pop()\n    if (node.contacts === null) {\n      var detNode = this._determineNode(node, id, bitIndex++)\n      nodes.push(node.left === detNode ? node.right : node.left)\n      nodes.push(detNode)\n    } else {\n      contacts = contacts.concat(node.contacts)\n    }\n  }\n\n  var self = this\n  function compare (a, b) {\n    return self.distance(a.id, id) - self.distance(b.id, id)\n  }\n\n  return contacts.sort(compare).slice(0, n)\n}\n\n// Counts the number of contacts recursively.\n// If this is a leaf, just return the number of contacts contained. Otherwise,\n// return the length of the high and low branches combined.\nKBucket.prototype.count = function () {\n  // return this.toArray().length\n  var count = 0\n  for (var nodes = [ this.root ]; nodes.length > 0;) {\n    var node = nodes.pop()\n    if (node.contacts === null) nodes.push(node.right, node.left)\n    else count += node.contacts.length\n  }\n  return count\n}\n\n// Determines whether the id at the bitIndex is 0 or 1.\n// Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise\n// node: internal object that has 2 leafs: left and right\n// id: a Buffer to compare localNodeId with\n// bitIndex: the bitIndex to which bit to check in the id Buffer\nKBucket.prototype._determineNode = function (node, id, bitIndex) {\n  // **NOTE** remember that id is a Buffer and has granularity of\n  // bytes (8 bits), whereas the bitIndex is the _bit_ index (not byte)\n\n  // id's that are too short are put in low bucket (1 byte = 8 bits)\n  // parseInt(bitIndex / 8) finds how many bytes the bitIndex describes\n  // bitIndex % 8 checks if we have extra bits beyond byte multiples\n  // if number of bytes is <= no. of bytes described by bitIndex and there\n  // are extra bits to consider, this means id has less bits than what\n  // bitIndex describes, id therefore is too short, and will be put in low\n  // bucket\n  var bytesDescribedByBitIndex = ~~(bitIndex / 8)\n  var bitIndexWithinByte = bitIndex % 8\n  if ((id.length <= bytesDescribedByBitIndex) && (bitIndexWithinByte !== 0)) return node.left\n\n  var byteUnderConsideration = id[bytesDescribedByBitIndex]\n\n  // byteUnderConsideration is an integer from 0 to 255 represented by 8 bits\n  // where 255 is 11111111 and 0 is 00000000\n  // in order to find out whether the bit at bitIndexWithinByte is set\n  // we construct Math.pow(2, (7 - bitIndexWithinByte)) which will consist\n  // of all bits being 0, with only one bit set to 1\n  // for example, if bitIndexWithinByte is 3, we will construct 00010000 by\n  // Math.pow(2, (7 - 3)) -> Math.pow(2, 4) -> 16\n  if (byteUnderConsideration & Math.pow(2, (7 - bitIndexWithinByte))) return node.right\n\n  return node.left\n}\n\n// Get a contact by its exact ID.\n// If this is a leaf, loop through the bucket contents and return the correct\n// contact if we have it or null if not. If this is an inner node, determine\n// which branch of the tree to traverse and repeat.\n// id: Buffer *required* The ID of the contact to fetch.\nKBucket.prototype.get = function (id) {\n  if (!Buffer.isBuffer(id)) throw new TypeError('id is not a Buffer')\n  var bitIndex = 0\n\n  var node = this.root\n  while (node.contacts === null) {\n    node = this._determineNode(node, id, bitIndex++)\n  }\n\n  var index = this._indexOf(node, id) // index of uses contact id for matching\n  return index >= 0 ? node.contacts[index] : null\n}\n\n// node: internal object that has 2 leafs: left and right\n// id: Buffer Contact node id.\n// Returns the index of the contact with the given id if it exists\nKBucket.prototype._indexOf = function (node, id) {\n  for (var i = 0; i < node.contacts.length; ++i) {\n    if (bufferEquals(node.contacts[i].id, id)) return i\n  }\n\n  return -1\n}\n\n// id: Buffer *required* The ID of the contact to remove.\nKBucket.prototype.remove = function (id) {\n  if (!Buffer.isBuffer(id)) throw new TypeError('id is not a Buffer')\n  var bitIndex = 0\n\n  var node = this.root\n  while (node.contacts === null) {\n    node = this._determineNode(node, id, bitIndex++)\n  }\n\n  var index = this._indexOf(node, id)\n  if (index >= 0) {\n    var contact = node.contacts.splice(index, 1)[0]\n    this.emit('removed', contact)\n  }\n\n  return this\n}\n\n// Splits the node, redistributes contacts to the new nodes, and marks the\n// node that was split as an inner node of the binary tree of nodes by\n// setting this.root.contacts = null\n// node: *required* node for splitting\n// bitIndex: *required* the bitIndex to which byte to check in the Buffer\n//          for navigating the binary tree\nKBucket.prototype._split = function (node, bitIndex) {\n  node.left = createNode()\n  node.right = createNode()\n\n  // redistribute existing contacts amongst the two newly created nodes\n  for (var i = 0; i < node.contacts.length; ++i) {\n    var contact = node.contacts[i]\n    this._determineNode(node, contact.id, bitIndex).contacts.push(contact)\n  }\n  node.contacts = null // mark as inner tree node\n\n  // don't split the \"far away\" node\n  // we check where the local node would end up and mark the other one as\n  // \"dontSplit\" (i.e. \"far away\")\n  var detNode = this._determineNode(node, this.localNodeId, bitIndex)\n  var otherNode = node.left === detNode ? node.right : node.left\n  otherNode.dontSplit = true\n}\n\n// Returns all the contacts contained in the tree as an array.\n// If this is a leaf, return a copy of the bucket. `slice` is used so that we\n// don't accidentally leak an internal reference out that might be accidentally\n// misused. If this is not a leaf, return the union of the low and high\n// branches (themselves also as arrays).\nKBucket.prototype.toArray = function () {\n  var result = []\n  for (var nodes = [ this.root ]; nodes.length > 0;) {\n    var node = nodes.pop()\n    if (node.contacts === null) nodes.push(node.right, node.left)\n    else result = result.concat(node.contacts)\n  }\n  return result\n}\n\n// Updates the contact selected by the arbiter.\n// If the selection is our old contact and the candidate is some new contact\n// then the new contact is abandoned (not added).\n// If the selection is our old contact and the candidate is our old contact\n// then we are refreshing the contact and it is marked as most recently\n// contacted (by being moved to the right/end of the bucket array).\n// If the selection is our new contact, the old contact is removed and the new\n// contact is marked as most recently contacted.\n// node: internal object that has 2 leafs: left and right\n// contact: *required* the contact to update\n// index: *required* the index in the bucket where contact exists\n//        (index has already been computed in a previous calculation)\nKBucket.prototype._update = function (node, index, contact) {\n  // sanity check\n  if (!bufferEquals(node.contacts[index].id, contact.id)) throw new Error('wrong index for _update')\n\n  var incumbent = node.contacts[index]\n  var selection = this.arbiter(incumbent, contact)\n  // if the selection is our old contact and the candidate is some new\n  // contact, then there is nothing to do\n  if (selection === incumbent && incumbent !== contact) return\n\n  node.contacts.splice(index, 1) // remove old contact\n  node.contacts.push(selection) // add more recent contact version\n  this.emit('updated', incumbent, selection)\n}\n","module.exports = require('crypto').randomBytes\n","var socket = require('k-rpc-socket')\nvar KBucket = require('k-bucket')\nvar equals = require('buffer-equals')\nvar events = require('events')\nvar randombytes = require('randombytes')\nvar util = require('util')\nvar Buffer = require('safe-buffer').Buffer\n\nvar K = 20\nvar MAX_CONCURRENCY = 16\nvar BOOTSTRAP_NODES = [\n  {host: 'router.bittorrent.com', port: 6881},\n  {host: 'router.utorrent.com', port: 6881},\n  {host: 'dht.transmissionbt.com', port: 6881}\n]\n\nmodule.exports = RPC\n\nfunction RPC (opts) {\n  if (!(this instanceof RPC)) return new RPC(opts)\n  if (!opts) opts = {}\n\n  var self = this\n\n  this._idLength = opts.idLength || 20\n  this.id = toBuffer(opts.id || opts.nodeId || randombytes(this._idLength))\n  this.socket = opts.krpcSocket || socket(opts)\n  this.bootstrap = toBootstrapArray(opts.nodes || opts.bootstrap)\n  this.concurrency = opts.concurrency || MAX_CONCURRENCY\n  this.backgroundConcurrency = opts.backgroundConcurrency || (this.concurrency / 4) | 0\n  this.k = opts.k || K\n  this.destroyed = false\n\n  this.pending = []\n  this.nodes = null\n\n  this.socket.setMaxListeners(0)\n  this.socket.on('query', onquery)\n  this.socket.on('response', onresponse)\n  this.socket.on('warning', onwarning)\n  this.socket.on('error', onerror)\n  this.socket.on('update', onupdate)\n  this.socket.on('listening', onlistening)\n\n  events.EventEmitter.call(this)\n  this.clear()\n\n  function onupdate () {\n    while (self.pending.length && self.socket.inflight < self.concurrency) {\n      var next = self.pending.shift()\n      self.query(next[0], next[1], next[2])\n    }\n  }\n\n  function onerror (err) {\n    self.emit('error', err)\n  }\n\n  function onlistening () {\n    self.emit('listening')\n  }\n\n  function onwarning (err) {\n    self.emit('warning', err)\n  }\n\n  function onquery (query, peer) {\n    addNode(query.a, peer)\n    self.emit('query', query, peer)\n  }\n\n  function onresponse (reply, peer) {\n    addNode(reply.r, peer)\n  }\n\n  function addNode (data, peer) {\n    if (data && isNodeId(data.id, self._idLength) && !self.nodes.get(data.id) && !equals(data.id, self.id)) {\n      self._addNode({\n        id: data.id,\n        host: peer.address || peer.host,\n        port: peer.port,\n        distance: 0\n      })\n    }\n  }\n}\n\nutil.inherits(RPC, events.EventEmitter)\n\nRPC.prototype.response = function (node, query, response, nodes, cb) {\n  if (typeof nodes === 'function') {\n    cb = nodes\n    nodes = null\n  }\n\n  if (!response.id) response.id = this.id\n  if (nodes) response.nodes = encodeNodes(nodes, this._idLength)\n  this.socket.response(node, query, response, cb)\n}\n\nRPC.prototype.error = function (node, query, error, cb) {\n  this.socket.error(node, query, error, cb)\n}\n\n// bind([port], [address], [callback])\nRPC.prototype.bind = function () {\n  this.socket.bind.apply(this.socket, arguments)\n}\n\nRPC.prototype.address = function () {\n  return this.socket.address()\n}\n\nRPC.prototype.queryAll = function (nodes, message, visit, cb) {\n  if (!message.a) message.a = {}\n  if (!message.a.id) message.a.id = this.id\n\n  var stop = false\n  var missing = nodes.length\n  var hits = 0\n  var error = null\n\n  if (!missing) return cb(new Error('No nodes to query'), 0)\n\n  for (var i = 0; i < nodes.length; i++) {\n    this.query(nodes[i], message, done)\n  }\n\n  function done (err, res, peer) {\n    if (!err) hits++\n    else if (err.code >= 300 && err.code < 400) error = err\n    if (!err && !stop) {\n      if (visit && visit(res, peer) === false) stop = true\n    }\n    if (!--missing) cb(hits ? null : error || new Error('All queries failed'), hits)\n  }\n}\n\nRPC.prototype.query = function (node, message, cb) {\n  if (this.socket.inflight >= this.concurrency) {\n    this.pending.push([node, message, cb])\n  } else {\n    if (!message.a) message.a = {}\n    if (!message.a.id) message.a.id = this.id\n    if (node.token) message.a.token = node.token\n    this.socket.query(node, message, cb)\n  }\n}\n\nRPC.prototype.destroy = function (cb) {\n  this.destroyed = true\n  this.socket.destroy(cb)\n}\n\nRPC.prototype.clear = function () {\n  var self = this\n\n  this.nodes = new KBucket({\n    localNodeId: this.id,\n    numberOfNodesPerKBucket: this.k,\n    numberOfNodesToPing: this.concurrency\n  })\n\n  this.nodes.on('ping', onping)\n\n  function onping (older, newer) {\n    self.emit('ping', older, newer)\n  }\n}\n\nRPC.prototype.populate = function (target, message, cb) {\n  this._closest(target, message, true, null, cb)\n}\n\nRPC.prototype.closest = function (target, message, visit, cb) {\n  this._closest(target, message, false, visit, cb)\n}\n\nRPC.prototype._addNode = function (node) {\n  var old = this.nodes.get(node.id)\n  this.nodes.add(node)\n  if (!old) this.emit('node', node)\n}\n\nRPC.prototype._closest = function (target, message, background, visit, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var count = 0\n  var queried = {}\n  var pending = 0\n  var once = true\n  var stop = false\n\n  if (!message.a) message.a = {}\n  if (!message.a.id) message.a.id = this.id\n\n  var table = new KBucket({\n    localNodeId: target,\n    numberOfNodesPerKBucket: this.k,\n    numberOfNodesToPing: this.concurrency\n  })\n\n  var evt = background ? 'postupdate' : 'update'\n  this.socket.on(evt, kick)\n  kick()\n\n  function kick () {\n    if (self.destroyed || self.socket.inflight >= self.concurrency) return\n\n    var otherInflight = self.pending.length + self.socket.inflight - pending\n    if (background && self.socket.inflight >= self.backgroundConcurrency && otherInflight) return\n\n    var closest = table.closest(target, self.k)\n    if (!closest.length || closest.length < self.bootstrap.length) {\n      closest = self.nodes.closest(target, self.k)\n      if (!closest.length || closest.length < self.bootstrap.length) bootstrap()\n    }\n\n    for (var i = 0; i < closest.length; i++) {\n      if (stop) break\n      if (self.socket.inflight >= self.concurrency) return\n\n      var peer = closest[i]\n      var id = peer.host + ':' + peer.port\n      if (queried[id]) continue\n      queried[id] = true\n\n      pending++\n      self.socket.query(peer, message, afterQuery)\n    }\n\n    if (!pending) {\n      self.socket.removeListener(evt, kick)\n      process.nextTick(done)\n    }\n  }\n\n  function done () {\n    cb(null, count)\n  }\n\n  function bootstrap () {\n    if (!once) return\n    once = false\n    self.bootstrap.forEach(function (peer) {\n      pending++\n      self.socket.query(peer, message, afterQuery)\n    })\n  }\n\n  function afterQuery (err, res, peer) {\n    pending--\n    if (peer) queried[(peer.address || peer.host) + ':' + peer.port] = true // need this for bootstrap nodes\n\n    if (peer && peer.id && self.nodes.get(peer.id)) {\n      if (err && (err.code === 'EUNEXPECTEDNODE' || err.code === 'ETIMEDOUT')) {\n        self.nodes.remove(peer.id)\n      }\n    }\n\n    var r = res && res.r\n    if (!r) return kick()\n\n    if (!err && isNodeId(r.id, self._idLength)) {\n      count++\n      add({\n        id: r.id,\n        port: peer.port,\n        host: peer.host || peer.address,\n        distance: 0\n      })\n    }\n\n    var nodes = r.nodes ? parseNodes(r.nodes, self._idLength) : []\n    for (var i = 0; i < nodes.length; i++) add(nodes[i])\n\n    if (visit && visit(res, peer) === false) stop = true\n\n    kick()\n  }\n\n  function add (node) {\n    if (equals(node.id, self.id)) return\n    table.add(node)\n  }\n}\n\nfunction toBootstrapArray (val) {\n  if (val === false) return []\n  if (val === true) return BOOTSTRAP_NODES\n  return [].concat(val || BOOTSTRAP_NODES).map(parsePeer)\n}\n\nfunction isNodeId (id, idLength) {\n  return id && Buffer.isBuffer(id) && id.length === idLength\n}\n\nfunction encodeNodes (nodes, idLength) {\n  var buf = Buffer.allocUnsafe(nodes.length * (idLength + 6))\n  var ptr = 0\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i]\n    if (!isNodeId(node.id, idLength)) continue\n    node.id.copy(buf, ptr)\n    ptr += idLength\n    var ip = (node.host || node.address).split('.')\n    for (var j = 0; j < 4; j++) buf[ptr++] = parseInt(ip[j] || 0, 10)\n    buf.writeUInt16BE(node.port, ptr)\n    ptr += 2\n  }\n\n  if (ptr === buf.length) return buf\n  return buf.slice(0, ptr)\n}\n\nfunction parseNodes (buf, idLength) {\n  var contacts = []\n\n  try {\n    for (var i = 0; i < buf.length; i += (idLength + 6)) {\n      var port = buf.readUInt16BE(i + (idLength + 4))\n      if (!port) continue\n      contacts.push({\n        id: buf.slice(i, i + idLength),\n        host: parseIp(buf, i + idLength),\n        port: port,\n        distance: 0,\n        token: null\n      })\n    }\n  } catch (err) {\n    // do nothing\n  }\n\n  return contacts\n}\n\nfunction parseIp (buf, offset) {\n  return buf[offset++] + '.' + buf[offset++] + '.' + buf[offset++] + '.' + buf[offset++]\n}\n\nfunction parsePeer (peer) {\n  if (typeof peer === 'string') return {host: peer.split(':')[0], port: Number(peer.split(':')[1])}\n  return peer\n}\n\nfunction noop () {}\n\nfunction toBuffer (str) {\n  if (Buffer.isBuffer(str)) return str\n  if (ArrayBuffer.isView(str)) return Buffer.from(str.buffer, str.byteOffset, str.byteLength)\n  if (typeof str === 'string') return Buffer.from(str, 'hex')\n  throw new Error('Pass a buffer or a string')\n}\n","var dgram = require('dgram')\nvar bencode = require('bencode')\nvar isIP = require('net').isIP\nvar dns = require('dns')\nvar util = require('util')\nvar events = require('events')\nvar Buffer = require('safe-buffer').Buffer\nvar equals = require('buffer-equals')\n\nvar ETIMEDOUT = new Error('Query timed out')\nETIMEDOUT.code = 'ETIMEDOUT'\n\nvar EUNEXPECTEDNODE = new Error('Unexpected node id')\nEUNEXPECTEDNODE.code = 'EUNEXPECTEDNODE'\n\nmodule.exports = RPC\n\nfunction RPC (opts) {\n  if (!(this instanceof RPC)) return new RPC(opts)\n  if (!opts) opts = {}\n\n  var self = this\n\n  this.timeout = opts.timeout || 2000\n  this.inflight = 0\n  this.destroyed = false\n  this.isIP = opts.isIP || isIP\n  this.socket = opts.socket || dgram.createSocket('udp4')\n  this.socket.on('message', onmessage)\n  this.socket.on('error', onerror)\n  this.socket.on('listening', onlistening)\n\n  this._tick = 0\n  this._ids = []\n  this._reqs = []\n  this._timer = setInterval(check, (this.timeout / 4) | 0)\n\n  events.EventEmitter.call(this)\n\n  function check () {\n    var missing = self.inflight\n    if (!missing) return\n    for (var i = 0; i < self._reqs.length; i++) {\n      var req = self._reqs[i]\n      if (!req) continue\n      if (req.ttl) req.ttl--\n      else self._cancel(i, ETIMEDOUT)\n      if (!--missing) return\n    }\n  }\n\n  function onlistening () {\n    self.emit('listening')\n  }\n\n  function onerror (err) {\n    if (err.code === 'EACCES' || err.code === 'EADDRINUSE') self.emit('error', err)\n    else self.emit('warning', err)\n  }\n\n  function onmessage (buf, rinfo) {\n    if (self.destroyed) return\n    if (!rinfo.port) return // seems like a node bug that this is nessesary?\n\n    try {\n      var message = bencode.decode(buf)\n    } catch (e) {\n      return self.emit('warning', e)\n    }\n\n    var type = message && message.y && message.y.toString()\n\n    if (type === 'r' || type === 'e') {\n      if (!Buffer.isBuffer(message.t)) return\n\n      try {\n        var tid = message.t.readUInt16BE(0)\n      } catch (err) {\n        return self.emit('warning', err)\n      }\n\n      var index = self._ids.indexOf(tid)\n      if (index === -1 || tid === 0) {\n        self.emit('response', message, rinfo)\n        self.emit('warning', new Error('Unexpected transaction id: ' + tid))\n        return\n      }\n\n      var req = self._reqs[index]\n      if (req.peer.host !== rinfo.address) {\n        self.emit('response', message, rinfo)\n        self.emit('warning', new Error('Out of order response'))\n        return\n      }\n\n      self._ids[index] = 0\n      self._reqs[index] = null\n      self.inflight--\n\n      if (type === 'e') {\n        var isArray = Array.isArray(message.e)\n        var err = new Error(isArray ? message.e.join(' ') : 'Unknown error')\n        err.code = isArray && message.e.length && typeof message.e[0] === 'number' ? message.e[0] : 0\n        req.callback(err, message, rinfo, req.message)\n        self.emit('update')\n        self.emit('postupdate')\n        return\n      }\n\n      var rid = message.r && message.r.id\n      if (req.peer && req.peer.id && rid && !equals(req.peer.id, rid)) {\n        req.callback(EUNEXPECTEDNODE, null, rinfo)\n        self.emit('update')\n        self.emit('postupdate')\n        return\n      }\n\n      req.callback(null, message, rinfo, req.message)\n      self.emit('update')\n      self.emit('postupdate')\n      self.emit('response', message, rinfo)\n    } else if (type === 'q') {\n      self.emit('query', message, rinfo)\n    } else {\n      self.emit('warning', new Error('Unknown type: ' + type))\n    }\n  }\n}\n\nutil.inherits(RPC, events.EventEmitter)\n\nRPC.prototype.address = function () {\n  return this.socket.address()\n}\n\nRPC.prototype.response = function (peer, req, res, cb) {\n  this.send(peer, {t: req.t, y: 'r', r: res}, cb)\n}\n\nRPC.prototype.error = function (peer, req, error, cb) {\n  this.send(peer, {t: req.t, y: 'e', e: [].concat(error.message || error)}, cb)\n}\n\nRPC.prototype.send = function (peer, message, cb) {\n  var buf = bencode.encode(message)\n  this.socket.send(buf, 0, buf.length, peer.port, peer.address || peer.host, cb || noop)\n}\n\n// bind([port], [address], [callback])\nRPC.prototype.bind = function () {\n  this.socket.bind.apply(this.socket, arguments)\n}\n\nRPC.prototype.destroy = function (cb) {\n  this.destroyed = true\n  clearInterval(this._timer)\n  if (cb) this.socket.on('close', cb)\n  for (var i = 0; i < this._ids.length; i++) this._cancel(i)\n  this.socket.close()\n}\n\nRPC.prototype.query = function (peer, query, cb) {\n  if (!cb) cb = noop\n  if (!this.isIP(peer.host)) return this._resolveAndQuery(peer, query, cb)\n\n  var message = {\n    t: Buffer.allocUnsafe(2),\n    y: 'q',\n    q: query.q,\n    a: query.a\n  }\n\n  var req = {\n    ttl: 4,\n    peer: peer,\n    message: message,\n    callback: cb\n  }\n\n  if (this._tick === 65535) this._tick = 0\n  var tid = ++this._tick\n\n  var free = this._ids.indexOf(0)\n  if (free === -1) free = this._ids.push(0) - 1\n  this._ids[free] = tid\n  while (this._reqs.length < free) this._reqs.push(null)\n  this._reqs[free] = req\n\n  this.inflight++\n  message.t.writeUInt16BE(tid, 0)\n  this.send(peer, message)\n  return tid\n}\n\nRPC.prototype.cancel = function (tid, err) {\n  var index = this._ids.indexOf(tid)\n  if (index > -1) this._cancel(index, err)\n}\n\nRPC.prototype._cancel = function (index, err) {\n  var req = this._reqs[index]\n  this._ids[index] = 0\n  this._reqs[index] = null\n  if (req) {\n    this.inflight--\n    req.callback(err || new Error('Query was cancelled'), null, req.peer)\n    this.emit('update')\n    this.emit('postupdate')\n  }\n}\n\nRPC.prototype._resolveAndQuery = function (peer, query, cb) {\n  var self = this\n\n  dns.lookup(peer.host, function (err, ip) {\n    if (err) return cb(err)\n    if (self.destroyed) return cb(new Error('k-rpc-socket is destroyed'))\n    self.query({host: ip, port: peer.port}, query, cb)\n  })\n}\n\nfunction noop () {}\n","var bencode = module.exports\n\nbencode.encode = require('./encode')\nbencode.decode = require('./decode')\n\n/**\n * Determines the amount of bytes\n * needed to encode the given value\n * @param  {Object|Array|Buffer|String|Number|Boolean} value\n * @return {Number} byteCount\n */\nbencode.byteLength = bencode.encodingLength = function (value) {\n  return bencode.encode(value).length\n}\n","var Buffer = require('safe-buffer').Buffer\n\n/**\n * Encodes data in bencode.\n *\n * @param  {Buffer|Array|String|Object|Number|Boolean} data\n * @return {Buffer}\n */\nfunction encode (data, buffer, offset) {\n  var buffers = []\n  var result = null\n\n  encode._encode(buffers, data)\n  result = Buffer.concat(buffers)\n  encode.bytes = result.length\n\n  if (Buffer.isBuffer(buffer)) {\n    result.copy(buffer, offset)\n    return buffer\n  }\n\n  return result\n}\n\nencode.bytes = -1\nencode._floatConversionDetected = false\n\nencode.getType = function (value) {\n  if (Buffer.isBuffer(value)) return 'buffer'\n  if (Array.isArray(value)) return 'array'\n  if (ArrayBuffer.isView(value)) return 'arraybufferview'\n  if (value instanceof Number) return 'number'\n  if (value instanceof Boolean) return 'boolean'\n  if (value instanceof ArrayBuffer) return 'arraybuffer'\n  return typeof value\n}\n\nencode._encode = function (buffers, data) {\n  if (data == null) { return }\n\n  switch (encode.getType(data)) {\n    case 'buffer': encode.buffer(buffers, data); break\n    case 'object': encode.dict(buffers, data); break\n    case 'array': encode.list(buffers, data); break\n    case 'string': encode.string(buffers, data); break\n    case 'number': encode.number(buffers, data); break\n    case 'boolean': encode.number(buffers, data); break\n    case 'arraybufferview': encode.buffer(buffers, Buffer.from(data.buffer, data.byteOffset, data.byteLength)); break\n    case 'arraybuffer': encode.buffer(buffers, Buffer.from(data)); break\n  }\n}\n\nvar buffE = Buffer.from('e')\nvar buffD = Buffer.from('d')\nvar buffL = Buffer.from('l')\n\nencode.buffer = function (buffers, data) {\n  buffers.push(new Buffer(data.length + ':'), data)\n}\n\nencode.string = function (buffers, data) {\n  buffers.push(Buffer.from(Buffer.byteLength(data) + ':' + data))\n}\n\nencode.number = function (buffers, data) {\n  var maxLo = 0x80000000\n  var hi = (data / maxLo) << 0\n  var lo = (data % maxLo) << 0\n  var val = hi * maxLo + lo\n\n  buffers.push(Buffer.from('i' + val + 'e'))\n\n  if (val !== data && !encode._floatConversionDetected) {\n    encode._floatConversionDetected = true\n    console.warn(\n      'WARNING: Possible data corruption detected with value \"' + data + '\":',\n      'Bencoding only defines support for integers, value was converted to \"' + val + '\"'\n    )\n    console.trace()\n  }\n}\n\nencode.dict = function (buffers, data) {\n  buffers.push(buffD)\n\n  var j = 0\n  var k\n  // fix for issue #13 - sorted dicts\n  var keys = Object.keys(data).sort()\n  var kl = keys.length\n\n  for (; j < kl; j++) {\n    k = keys[j]\n    if (data[k] == null) continue\n    encode.string(buffers, k)\n    encode._encode(buffers, data[k])\n  }\n\n  buffers.push(buffE)\n}\n\nencode.list = function (buffers, data) {\n  var i = 0\n  var c = data.length\n  buffers.push(buffL)\n\n  for (; i < c; i++) {\n    if (data[i] == null) continue\n    encode._encode(buffers, data[i])\n  }\n\n  buffers.push(buffE)\n}\n\nmodule.exports = encode\n","const INTEGER_START = 0x69 // 'i'\nconst STRING_DELIM = 0x3A // ':'\nconst DICTIONARY_START = 0x64 // 'd'\nconst LIST_START = 0x6C // 'l'\nconst END_OF_TYPE = 0x65 // 'e'\n\n/**\n * replaces parseInt(buffer.toString('ascii', start, end)).\n * For strings with less then ~30 charachters, this is actually a lot faster.\n *\n * @param {Buffer} data\n * @param {Number} start\n * @param {Number} end\n * @return {Number} calculated number\n */\nfunction getIntFromBuffer (buffer, start, end) {\n  var sum = 0\n  var sign = 1\n\n  for (var i = start; i < end; i++) {\n    var num = buffer[i]\n\n    if (num < 58 && num >= 48) {\n      sum = sum * 10 + (num - 48)\n      continue\n    }\n\n    if (i === start && num === 43) { // +\n      continue\n    }\n\n    if (i === start && num === 45) { // -\n      sign = -1\n      continue\n    }\n\n    if (num === 46) { // .\n      // its a float. break here.\n      break\n    }\n\n    throw new Error('not a number: buffer[' + i + '] = ' + num)\n  }\n\n  return sum * sign\n}\n\n/**\n * Decodes bencoded data.\n *\n * @param  {Buffer} data\n * @param  {Number} start (optional)\n * @param  {Number} end (optional)\n * @param  {String} encoding (optional)\n * @return {Object|Array|Buffer|String|Number}\n */\nfunction decode (data, start, end, encoding) {\n  if (data == null || data.length === 0) {\n    return null\n  }\n\n  if (typeof start !== 'number' && encoding == null) {\n    encoding = start\n    start = undefined\n  }\n\n  if (typeof end !== 'number' && encoding == null) {\n    encoding = end\n    end = undefined\n  }\n\n  decode.position = 0\n  decode.encoding = encoding || null\n\n  decode.data = !(Buffer.isBuffer(data))\n    ? new Buffer(data)\n    : data.slice(start, end)\n\n  decode.bytes = decode.data.length\n\n  return decode.next()\n}\n\ndecode.bytes = 0\ndecode.position = 0\ndecode.data = null\ndecode.encoding = null\n\ndecode.next = function () {\n  switch (decode.data[decode.position]) {\n    case DICTIONARY_START:\n      return decode.dictionary()\n    case LIST_START:\n      return decode.list()\n    case INTEGER_START:\n      return decode.integer()\n    default:\n      return decode.buffer()\n  }\n}\n\ndecode.find = function (chr) {\n  var i = decode.position\n  var c = decode.data.length\n  var d = decode.data\n\n  while (i < c) {\n    if (d[i] === chr) return i\n    i++\n  }\n\n  throw new Error(\n    'Invalid data: Missing delimiter \"' +\n    String.fromCharCode(chr) + '\" [0x' +\n    chr.toString(16) + ']'\n  )\n}\n\ndecode.dictionary = function () {\n  decode.position++\n\n  var dict = {}\n\n  while (decode.data[decode.position] !== END_OF_TYPE) {\n    dict[decode.buffer()] = decode.next()\n  }\n\n  decode.position++\n\n  return dict\n}\n\ndecode.list = function () {\n  decode.position++\n\n  var lst = []\n\n  while (decode.data[decode.position] !== END_OF_TYPE) {\n    lst.push(decode.next())\n  }\n\n  decode.position++\n\n  return lst\n}\n\ndecode.integer = function () {\n  var end = decode.find(END_OF_TYPE)\n  var number = getIntFromBuffer(decode.data, decode.position + 1, end)\n\n  decode.position += end + 1 - decode.position\n\n  return number\n}\n\ndecode.buffer = function () {\n  var sep = decode.find(STRING_DELIM)\n  var length = getIntFromBuffer(decode.data, decode.position, sep)\n  var end = ++sep + length\n\n  decode.position = end\n\n  return decode.encoding\n    ? decode.data.toString(decode.encoding, sep, end)\n    : decode.data.slice(sep, end)\n}\n\nmodule.exports = decode\n","module.exports = require(\"dns\");","/*\nindex.js - Kademlia DHT K-bucket implementation as a binary tree.\n\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 Tristan Slominski\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n'use strict'\n\nvar randomBytes = require('randombytes')\nvar EventEmitter = require('events').EventEmitter\nvar inherits = require('inherits')\n\nmodule.exports = KBucket\n\n// array1: Uint8Array\n// array2: Uint8Array\n// Return: boolean\nfunction arrayEquals (array1, array2) {\n  if (array1 === array2) {\n    return true\n  }\n  if (array1.length !== array2.length) {\n    return false\n  }\n  for (var i = 0, length = array1.length; i < length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction createNode () {\n  return { contacts: [], dontSplit: false, left: null, right: null }\n}\n\n/*\n  * `options`:\n    * `distance`: _Function_\n        `function (firstId, secondId) { return distance }` An optional\n        `distance` function that gets two `id` Uint8Arrays\n        and return distance (as number) between them.\n    * `arbiter`: _Function_ _(Default: vectorClock arbiter)_\n        `function (incumbent, candidate) { return contact; }` An optional\n        `arbiter` function that givent two `contact` objects with the same `id`\n        returns the desired object to be used for updating the k-bucket. For\n        more details, see [arbiter function](#arbiter-function).\n    * `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.\n        If not provided, a local node id will be created via `randomBytes(20)`.\n    * `metadata`: _Object_ _(Default: {})_ Optional satellite data to include\n        with the k-bucket. `metadata` property is guaranteed not be altered by,\n        it is provided as an explicit container for users of k-bucket to store\n        implementation-specific data.\n    * `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes\n        that a k-bucket can contain before being full or split.\n    * `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to\n        ping when a bucket that should not be split becomes full. KBucket will\n        emit a `ping` event that contains `numberOfNodesToPing` nodes that have\n        not been contacted the longest.\n*/\nfunction KBucket (options) {\n  EventEmitter.call(this)\n  options = options || {}\n\n  this.localNodeId = options.localNodeId || randomBytes(20)\n  if (!(this.localNodeId instanceof Uint8Array)) throw new TypeError('localNodeId is not a Uint8Array')\n  this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20\n  this.numberOfNodesToPing = options.numberOfNodesToPing || 3\n  this.distance = options.distance || KBucket.distance\n  // use an arbiter from options or vectorClock arbiter by default\n  this.arbiter = options.arbiter || KBucket.arbiter\n\n  this.root = createNode()\n\n  this.metadata = Object.assign({}, options.metadata)\n}\n\ninherits(KBucket, EventEmitter)\n\nKBucket.arbiter = function (incumbent, candidate) {\n  return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate\n}\n\nKBucket.distance = function (firstId, secondId) {\n  var distance = 0\n  var min = Math.min(firstId.length, secondId.length)\n  var max = Math.max(firstId.length, secondId.length)\n  for (var i = 0; i < min; ++i) distance = distance * 256 + (firstId[i] ^ secondId[i])\n  for (; i < max; ++i) distance = distance * 256 + 255\n  return distance\n}\n\n// contact: *required* the contact object to add\nKBucket.prototype.add = function (contact) {\n  if (!contact || !(contact.id instanceof Uint8Array)) throw new TypeError('contact.id is not a Uint8Array')\n  var bitIndex = 0\n\n  var node = this.root\n  while (node.contacts === null) {\n    // this is not a leaf node but an inner node with 'low' and 'high'\n    // branches; we will check the appropriate bit of the identifier and\n    // delegate to the appropriate node for further processing\n    node = this._determineNode(node, contact.id, bitIndex++)\n  }\n\n  // check if the contact already exists\n  var index = this._indexOf(node, contact.id)\n  if (index >= 0) {\n    this._update(node, index, contact)\n    return this\n  }\n\n  if (node.contacts.length < this.numberOfNodesPerKBucket) {\n    node.contacts.push(contact)\n    this.emit('added', contact)\n    return this\n  }\n\n  // the bucket is full\n  if (node.dontSplit) {\n    // we are not allowed to split the bucket\n    // we need to ping the first this.numberOfNodesToPing\n    // in order to determine if they are alive\n    // only if one of the pinged nodes does not respond, can the new contact\n    // be added (this prevents DoS flodding with new invalid contacts)\n    this.emit('ping', node.contacts.slice(0, this.numberOfNodesToPing), contact)\n    return this\n  }\n\n  this._split(node, bitIndex)\n  return this.add(contact)\n}\n\n// id: Uint8Array *required* node id\n// n: Integer (Default: Infinity) maximum number of closest contacts to return\n// Return: Array of maximum of `n` closest contacts to the node id\nKBucket.prototype.closest = function (id, n) {\n  if (!(id instanceof Uint8Array)) throw new TypeError('id is not a Uint8Array')\n  if (n === undefined) n = Infinity\n  if (typeof n !== 'number' || isNaN(n) || n <= 0) throw new TypeError('n is not positive number')\n  var contacts = []\n\n  for (var nodes = [ this.root ], bitIndex = 0; nodes.length > 0 && contacts.length < n;) {\n    var node = nodes.pop()\n    if (node.contacts === null) {\n      var detNode = this._determineNode(node, id, bitIndex++)\n      nodes.push(node.left === detNode ? node.right : node.left)\n      nodes.push(detNode)\n    } else {\n      contacts = contacts.concat(node.contacts)\n    }\n  }\n\n  var self = this\n  return contacts\n    .map(function (a) {\n      return [self.distance(a.id, id), a]\n    })\n    .sort(function (a, b) {\n      return a[0] - b[0]\n    })\n    .slice(0, n)\n    .map(function (a) {\n      return a[1]\n    })\n}\n\n// Counts the number of contacts recursively.\n// If this is a leaf, just return the number of contacts contained. Otherwise,\n// return the length of the high and low branches combined.\nKBucket.prototype.count = function () {\n  // return this.toArray().length\n  var count = 0\n  for (var nodes = [ this.root ]; nodes.length > 0;) {\n    var node = nodes.pop()\n    if (node.contacts === null) nodes.push(node.right, node.left)\n    else count += node.contacts.length\n  }\n  return count\n}\n\n// Determines whether the id at the bitIndex is 0 or 1.\n// Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise\n// node: internal object that has 2 leafs: left and right\n// id: a Uint8Array to compare localNodeId with\n// bitIndex: the bitIndex to which bit to check in the id Uint8Array\nKBucket.prototype._determineNode = function (node, id, bitIndex) {\n  // **NOTE** remember that id is a Uint8Array and has granularity of\n  // bytes (8 bits), whereas the bitIndex is the _bit_ index (not byte)\n\n  // id's that are too short are put in low bucket (1 byte = 8 bits)\n  // ~~(bitIndex / 8) finds how many bytes the bitIndex describes, \"~~\" is\n  // equivalent to \"parseInt\"\n  // bitIndex % 8 checks if we have extra bits beyond byte multiples\n  // if number of bytes is <= no. of bytes described by bitIndex and there\n  // are extra bits to consider, this means id has less bits than what\n  // bitIndex describes, id therefore is too short, and will be put in low\n  // bucket\n  var bytesDescribedByBitIndex = ~~(bitIndex / 8)\n  var bitIndexWithinByte = bitIndex % 8\n  if ((id.length <= bytesDescribedByBitIndex) && (bitIndexWithinByte !== 0)) return node.left\n\n  var byteUnderConsideration = id[bytesDescribedByBitIndex]\n\n  // byteUnderConsideration is an integer from 0 to 255 represented by 8 bits\n  // where 255 is 11111111 and 0 is 00000000\n  // in order to find out whether the bit at bitIndexWithinByte is set\n  // we construct Math.pow(2, (7 - bitIndexWithinByte)) which will consist\n  // of all bits being 0, with only one bit set to 1\n  // for example, if bitIndexWithinByte is 3, we will construct 00010000 by\n  // Math.pow(2, (7 - 3)) -> Math.pow(2, 4) -> 16\n  if (byteUnderConsideration & Math.pow(2, (7 - bitIndexWithinByte))) return node.right\n\n  return node.left\n}\n\n// Get a contact by its exact ID.\n// If this is a leaf, loop through the bucket contents and return the correct\n// contact if we have it or null if not. If this is an inner node, determine\n// which branch of the tree to traverse and repeat.\n// id: Uint8Array *required* The ID of the contact to fetch.\nKBucket.prototype.get = function (id) {\n  if (!(id instanceof Uint8Array)) throw new TypeError('id is not a Uint8Array')\n  var bitIndex = 0\n\n  var node = this.root\n  while (node.contacts === null) {\n    node = this._determineNode(node, id, bitIndex++)\n  }\n\n  var index = this._indexOf(node, id) // index of uses contact id for matching\n  return index >= 0 ? node.contacts[index] : null\n}\n\n// node: internal object that has 2 leafs: left and right\n// id: Uint8Array Contact node id.\n// Returns the index of the contact with the given id if it exists\nKBucket.prototype._indexOf = function (node, id) {\n  for (var i = 0; i < node.contacts.length; ++i) {\n    if (arrayEquals(node.contacts[i].id, id)) return i\n  }\n\n  return -1\n}\n\n// id: Uint8Array *required* The ID of the contact to remove.\nKBucket.prototype.remove = function (id) {\n  if (!(id instanceof Uint8Array)) throw new TypeError('id is not a Uint8Array')\n  var bitIndex = 0\n\n  var node = this.root\n  while (node.contacts === null) {\n    node = this._determineNode(node, id, bitIndex++)\n  }\n\n  var index = this._indexOf(node, id)\n  if (index >= 0) {\n    var contact = node.contacts.splice(index, 1)[0]\n    this.emit('removed', contact)\n  }\n\n  return this\n}\n\n// Splits the node, redistributes contacts to the new nodes, and marks the\n// node that was split as an inner node of the binary tree of nodes by\n// setting this.root.contacts = null\n// node: *required* node for splitting\n// bitIndex: *required* the bitIndex to which byte to check in the Uint8Array\n//          for navigating the binary tree\nKBucket.prototype._split = function (node, bitIndex) {\n  node.left = createNode()\n  node.right = createNode()\n\n  // redistribute existing contacts amongst the two newly created nodes\n  for (var i = 0; i < node.contacts.length; ++i) {\n    var contact = node.contacts[i]\n    this._determineNode(node, contact.id, bitIndex).contacts.push(contact)\n  }\n  node.contacts = null // mark as inner tree node\n\n  // don't split the \"far away\" node\n  // we check where the local node would end up and mark the other one as\n  // \"dontSplit\" (i.e. \"far away\")\n  var detNode = this._determineNode(node, this.localNodeId, bitIndex)\n  var otherNode = node.left === detNode ? node.right : node.left\n  otherNode.dontSplit = true\n}\n\n// Returns all the contacts contained in the tree as an array.\n// If this is a leaf, return a copy of the bucket. `slice` is used so that we\n// don't accidentally leak an internal reference out that might be accidentally\n// misused. If this is not a leaf, return the union of the low and high\n// branches (themselves also as arrays).\nKBucket.prototype.toArray = function () {\n  var result = []\n  for (var nodes = [ this.root ]; nodes.length > 0;) {\n    var node = nodes.pop()\n    if (node.contacts === null) nodes.push(node.right, node.left)\n    else result = result.concat(node.contacts)\n  }\n  return result\n}\n\n// Updates the contact selected by the arbiter.\n// If the selection is our old contact and the candidate is some new contact\n// then the new contact is abandoned (not added).\n// If the selection is our old contact and the candidate is our old contact\n// then we are refreshing the contact and it is marked as most recently\n// contacted (by being moved to the right/end of the bucket array).\n// If the selection is our new contact, the old contact is removed and the new\n// contact is marked as most recently contacted.\n// node: internal object that has 2 leafs: left and right\n// contact: *required* the contact to update\n// index: *required* the index in the bucket where contact exists\n//        (index has already been computed in a previous calculation)\nKBucket.prototype._update = function (node, index, contact) {\n  // sanity check\n  if (!arrayEquals(node.contacts[index].id, contact.id)) throw new Error('wrong index for _update')\n\n  var incumbent = node.contacts[index]\n  var selection = this.arbiter(incumbent, contact)\n  // if the selection is our old contact and the candidate is some new\n  // contact, then there is nothing to do\n  if (selection === incumbent && incumbent !== contact) return\n\n  node.contacts.splice(index, 1) // remove old contact\n  node.contacts.push(selection) // add more recent contact version\n  this.emit('updated', incumbent, selection)\n}\n","var events = require('events')\nvar inherits = require('inherits')\n\nmodule.exports = LRU\n\nfunction LRU (opts) {\n  if (!(this instanceof LRU)) return new LRU(opts)\n  if (typeof opts === 'number') opts = {max: opts}\n  if (!opts) opts = {}\n  events.EventEmitter.call(this)\n  this.cache = {}\n  this.head = this.tail = null\n  this.length = 0\n  this.max = opts.max || 1000\n  this.maxAge = opts.maxAge || 0\n}\n\ninherits(LRU, events.EventEmitter)\n\nObject.defineProperty(LRU.prototype, 'keys', {\n  get: function () { return Object.keys(this.cache) }\n})\n\nLRU.prototype.clear = function () {\n  this.cache = {}\n  this.head = this.tail = null\n  this.length = 0\n}\n\nLRU.prototype.remove = function (key) {\n  if (typeof key !== 'string') key = '' + key\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n  delete this.cache[key]\n  this._unlink(key, element.prev, element.next)\n  return element.value\n}\n\nLRU.prototype._unlink = function (key, prev, next) {\n  this.length--\n\n  if (this.length === 0) {\n    this.head = this.tail = null\n  } else {\n    if (this.head === key) {\n      this.head = prev\n      this.cache[this.head].next = null\n    } else if (this.tail === key) {\n      this.tail = next\n      this.cache[this.tail].prev = null\n    } else {\n      this.cache[prev].next = next\n      this.cache[next].prev = prev\n    }\n  }\n}\n\nLRU.prototype.peek = function (key) {\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n\n  if (!this._checkAge(key, element)) return\n  return element.value\n}\n\nLRU.prototype.set = function (key, value) {\n  if (typeof key !== 'string') key = '' + key\n\n  var element\n\n  if (this.cache.hasOwnProperty(key)) {\n    element = this.cache[key]\n    element.value = value\n    if (this.maxAge) element.modified = Date.now()\n\n    // If it's already the head, there's nothing more to do:\n    if (key === this.head) return value\n    this._unlink(key, element.prev, element.next)\n  } else {\n    element = {value: value, modified: 0, next: null, prev: null}\n    if (this.maxAge) element.modified = Date.now()\n    this.cache[key] = element\n\n    // Eviction is only possible if the key didn't already exist:\n    if (this.length === this.max) this.evict()\n  }\n\n  this.length++\n  element.next = null\n  element.prev = this.head\n\n  if (this.head) this.cache[this.head].next = key\n  this.head = key\n\n  if (!this.tail) this.tail = key\n  return value\n}\n\nLRU.prototype._checkAge = function (key, element) {\n  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {\n    this.remove(key)\n    this.emit('evict', {key: key, value: element.value})\n    return false\n  }\n  return true\n}\n\nLRU.prototype.get = function (key) {\n  if (typeof key !== 'string') key = '' + key\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n\n  if (!this._checkAge(key, element)) return\n\n  if (this.head !== key) {\n    if (key === this.tail) {\n      this.tail = element.next\n      this.cache[this.tail].prev = null\n    } else {\n      // Set prev.next -> element.next:\n      this.cache[element.prev].next = element.next\n    }\n\n    // Set element.next.prev -> element.prev:\n    this.cache[element.next].prev = element.prev\n\n    // Element is the new head\n    this.cache[this.head].next = key\n    element.prev = this.head\n    element.next = null\n    this.head = key\n  }\n\n  return element.value\n}\n\nLRU.prototype.evict = function () {\n  if (!this.tail) return\n  var key = this.tail\n  var value = this.remove(this.tail)\n  this.emit('evict', {key: key, value: value})\n}\n","var crypto = require('crypto')\n\nfunction sha1 (buf, cb) {\n  var hash = sha1sync(buf)\n  process.nextTick(function () {\n    cb(hash)\n  })\n}\n\nfunction sha1sync (buf) {\n  return crypto.createHash('sha1')\n    .update(buf)\n    .digest('hex')\n}\n\nmodule.exports = sha1\nmodule.exports.sync = sha1sync\n","var LRU = require('lru')\n\nmodule.exports = PeerStore\n\nfunction PeerStore (opts) {\n  if (!(this instanceof PeerStore)) return new PeerStore(opts)\n  if (!opts) opts = {}\n  this.max = opts.max || 10000\n  this.maxAge = opts.maxAge || Infinity\n  this.used = 0\n  this.peers = LRU(Infinity)\n}\n\nPeerStore.prototype.add = function (key, peer) {\n  var peers = this.peers.get(key)\n\n  if (!peers) {\n    peers = {\n      values: [],\n      map: LRU(Infinity)\n    }\n    this.peers.set(key, peers)\n  }\n\n  var id = peer.toString('hex')\n  var node = peers.map.get(id)\n  if (node) {\n    node.modified = Date.now()\n    return\n  }\n\n  node = {index: peers.values.length, peer: peer, modified: Date.now()}\n  peers.map.set(id, node)\n  peers.values.push(node)\n  if (++this.used > this.max) this._evict()\n}\n\nPeerStore.prototype._evict = function () {\n  var a = this.peers.peek(this.peers.tail)\n  var b = a.map.remove(a.map.tail)\n  var values = a.values\n  swap(values, b.index, values.length - 1)\n  values.pop()\n  this.used--\n  if (!values.length) this.peers.remove(this.peers.tail)\n}\n\nPeerStore.prototype.get = function (key, n) {\n  var node = this.peers.get(key)\n  if (!node) return []\n  var picked = pick(this, node.values, n || 100)\n  if (picked.length) return picked\n  this.peers.remove(key)\n  return []\n}\n\nfunction swap (list, a, b) {\n  if (a === b) return\n  var tmp = list[a]\n  list[a] = list[b]\n  list[b] = tmp\n  list[a].index = a\n  list[b].index = b\n}\n\nfunction pick (self, values, n) {\n  var ptr = 0\n  var res = []\n  var now = Date.now()\n\n  while (values.length && res.length < n && ptr < values.length) {\n    var next = ptr + (Math.random() * (values.length - ptr)) | 0\n    var val = values[next]\n\n    if (now - val.modified < self.maxAge) {\n      res.push(val.peer)\n      swap(values, ptr++, next)\n    } else {\n      swap(values, values.length - 1, next)\n      values.pop()\n      self.used--\n    }\n  }\n\n  return res\n}\n","/**\n * TODO: DHT Bootstrap Server\n *\n * For now, just export the client, which will work just fine. But, later, it'll\n * be important to give out nodes evenly from across the DHT.\n */\nmodule.exports = require('./client')\n","var isError = function(err) { // inlined from util so this works in the browser\n\treturn Object.prototype.toString.call(err) === '[object Error]';\n};\n\nvar thunky = function(fn) {\n\tvar run = function(callback) {\n\t\tvar stack = [callback];\n\n\t\tstate = function(callback) {\n\t\t\tstack.push(callback);\n\t\t};\n\n\t\tfn(function(err) {\n\t\t\tvar args = arguments;\n\t\t\tvar apply = function(callback) {\n\t\t\t\tif (callback) callback.apply(null, args);\n\t\t\t};\n\n\t\t\tstate = isError(err) ? run : apply;\n\t\t\twhile (stack.length) apply(stack.shift());\n\t\t});\n\t};\n\n\tvar state = run;\n\n\treturn function(callback) {\n\t\tstate(callback);\n\t};\n};\n\nmodule.exports = thunky;","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","var once = require('once')\nvar eos = require('end-of-stream')\nvar fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n","module.exports = toBuffer\n\nvar makeBuffer = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from : bufferFrom\n\nfunction bufferFrom (buf, enc) {\n  return new Buffer(buf, enc)\n}\n\nfunction toBuffer (buf, enc) {\n  if (Buffer.isBuffer(buf)) return buf\n  if (typeof buf === 'string') return makeBuffer(buf, enc)\n  if (Array.isArray(buf)) return makeBuffer(buf)\n  throw new Error('Input should be a buffer or a string')\n}\n","var varint = require('varint');\n\nvar POOL_SIZE = 100000;\nvar MINIMUM_POOL_LENGTH = 100;\nvar pool = new Buffer(POOL_SIZE);\n\nexports.read = function(stream, cb) {\n  var msglen = 0;\n  var prev = null;\n  var lock = false;\n\n  var unlock = function() {\n    lock = false\n  };\n\n  var readable = function() {\n    if (lock) return;\n    lock = true;\n\n    if (!msglen) {\n      var buf = stream.read();\n      if (!buf) return unlock();\n      if (prev) {\n        buf = Buffer.concat([prev, buf]);\n        prev = null;\n      }\n\n      for (var i = 0; i < buf.length; i++) {\n        if (!(buf[i] & 0x80)) {\n          msglen = varint.decode(buf);\n          break;\n        }\n      }\n      if (!msglen) {\n        prev = buf;\n        return unlock();\n      }\n      buf = buf.slice(varint.decode.bytes);\n      stream.unshift(buf);\n    }\n\n    var chunk = stream.read(msglen);\n    if (!chunk) return unlock();\n\n    stream.removeListener('readable', readable);\n    cb(chunk)\n  };\n\n  stream.on('readable', readable);\n  readable();\n};\n\nexports.write = function(stream, msg) {\n  if (typeof msg === 'string') msg = new Buffer(msg);\n  varint.encode(msg.length, pool);\n  var lenBuf = pool.slice(0, varint.encode.bytes);\n  pool = pool.slice(varint.encode.bytes);\n  if (pool.length < MINIMUM_POOL_LENGTH) pool = new Buffer(POOL_SIZE);\n\n  stream.write(lenBuf);\n  stream.write(msg);\n};\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n  \n  do {\n    if(counter >= l) {\n      read.bytesRead = 0\n      return undefined\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n  \n  read.bytes = counter - offset\n  \n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  :              8\n  )\n}\n","var events = require('events')\n\nmodule.exports = function (servers) {\n  var sockets = []\n\n  if (!Array.isArray(servers)) servers = [servers]\n\n  for (var i = 0; i < servers.length; i++) {\n    servers[i].on('connection', add)\n  }\n\n  var obj = new events.EventEmitter()\n  obj.sockets = sockets\n  obj.destroy = destroy\n  obj.add = add\n\n  return obj\n\n  function add (socket) {\n    sockets.push(socket)\n    socket.on('close', onclose)\n    obj.emit('connection', socket)\n  }\n\n  function onclose () {\n    sockets.splice(sockets.indexOf(this), 1)\n    obj.emit('close', this)\n    if (sockets.length === 0) obj.emit('idle')\n  }\n\n  function destroy () {\n    for (var i = 0; i < sockets.length; i++) {\n      sockets[i].destroy()\n    }\n  }\n}\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","var events = require('events')\nvar util = require('util')\nvar timers = require('./timers')\nvar stream = require('readable-stream')\nvar utp = require('node-gyp-build')(__dirname)\nvar net = require('net')\nvar dns = require('dns')\n\nvar UTP_ERRORS = [\n  'UTP_ECONNREFUSED',\n  'UTP_ECONNRESET',\n  'UTP_ETIMEDOUT'\n]\n\nvar IPV4_ONLY = new Error('Only IPv4 is supported currently. Open an issue for IPv6 support')\nvar unenroll = timers.unenroll\nvar active = timers.active\nvar enroll = timers.enroll\n\nmodule.exports = UTP\n\nfunction UTP () {\n  if (!(this instanceof UTP)) return new UTP()\n  events.EventEmitter.call(this)\n\n  this.connections = []\n\n  this._refs = 1\n  this._closed = false\n  this._bound = false\n  this._firewalled = true\n  this._maxConnections = 0\n  this._sending = new Array(64)\n  this._sendingFree = []\n  this._sendingPending = []\n  for (var i = 63; i >= 0; i--) this._sendingFree.push(i)\n\n  this._handle = utp.utp()\n  this._handle.context(this)\n  this._handle.onclose(this._onclose)\n  this._handle.onmessage(this._onmessage)\n  this._handle.onsend(this._onsend)\n  this._handle.onerror(this._onerror)\n}\n\nutil.inherits(UTP, events.EventEmitter)\n\nUTP.createServer = function (onconnection) {\n  var server = UTP()\n  if (onconnection) server.on('connection', onconnection)\n  return server\n}\n\nUTP.client = null // reuse a global client\n\nUTP.connect = function (port, host) {\n  if (UTP.client) return UTP.client.connect(port, host)\n  UTP.client = UTP()\n  UTP.client.once('closeable', oncloseable)\n  return UTP.client.connect(port, host)\n}\n\nfunction oncloseable () {\n  UTP.client.close()\n  UTP.client.on('error', noop)\n  UTP.client = null\n}\n\nUTP.prototype._onmessage = function (buf, rinfo) {\n  this.emit('message', buf, rinfo)\n}\n\nUTP.prototype._onsend = function (ptr, error) {\n  var req = this._sending[ptr]\n  this._sending[ptr] = null\n  this._sendingFree.push(ptr)\n  this._free()\n  if (error) req.callback(new Error('Send failed'))\n  else req.callback(null, req.buffer.length)\n}\n\nUTP.prototype._onclose = function () {\n  this._handle = null\n  this.emit('close')\n}\n\nUTP.prototype._onerror = function () {\n  this.emit(new Error('Unknown UDP error'))\n}\n\nUTP.prototype.address = function () {\n  return this._handle.address()\n}\n\nUTP.prototype.send = function (buf, offset, len, port, host, cb) {\n  if (typeof host === 'function') return this.send(buf, offset, len, port, null, host)\n  if (!Buffer.isBuffer(buf)) throw new Error('Buffer should be a buffer')\n  if (typeof offset !== 'number') throw new Error('Offset should be a number')\n  if (typeof len !== 'number') throw new Error('Length should be a number')\n  if (typeof port !== 'number') throw new Error('Port should be a number')\n  if (host && typeof host !== 'string') throw new Error('Host should be a string')\n\n  if (!this._bound) this.bind()\n  if (!cb) cb = noop\n  if (host && !net.isIPv4(host)) return this._resolveAndSend(buf, offset, len, port, host, cb)\n  if (!this._sendingFree.length) return this._deferSend(buf, offset, len, port, host, cb)\n\n  var free = this._sendingFree.pop()\n  this._sending[free] = new SendRequest(buf, offset, len, port, host, cb)\n\n  try {\n    this._handle.send(free, buf, offset, len, Number(port), host || '127.0.0.1')\n  } catch (err) {\n    this._sending[free] = null\n    this._sendingFree.push(free)\n    this._free()\n    next(cb, err)\n  }\n}\n\nObject.defineProperty(UTP.prototype, 'maxConnections', {\n  get: function () {\n    return this._maxConnections\n  },\n  set: function (val) {\n    this._maxConnections = val\n    this._handle.maxSockets(val)\n  }\n})\n\nUTP.prototype._deferSend = function (buf, offset, len, port, host, cb) {\n  this._sendingPending.push(new SendRequest(buf, offset, len, port, host, cb))\n}\n\nUTP.prototype._free = function () {\n  if (this._sendingPending.length) {\n    var req = this._sendingPending.shift()\n    this.send(req.buffer, req.offset, req.length, req.port, req.host, req.callback)\n  }\n}\n\nUTP.prototype._resolveAndSend = function (buf, offset, len, port, host, cb) {\n  if (!cb) cb = noop\n  var self = this\n  dns.lookup(host, function (err, ip, family) {\n    if (err) return cb(err)\n    if (family !== 4) return cb(IPV4_ONLY)\n    self.send(buf, offset, len, port, ip, cb)\n  })\n}\n\nUTP.prototype.connect = function (port, host) {\n  if (port && typeof port === 'object') return this.connect(port.port, port.host)\n  if (typeof port === 'string') port = Number(port)\n  if (host && typeof host !== 'string') throw new Error('Host should be a string')\n  if (!port) throw new Error('Port should be a number')\n\n  if (!this._bound) this.bind()\n\n  var conn = new Connection(this)\n\n  if (!host || net.isIPv4(host)) conn._connect(port, host || '127.0.0.1')\n  else conn._resolveAndConnect(port, host)\n\n  return conn\n}\n\nUTP.prototype.bind = function (port, ip, onlistening) {\n  if (typeof port === 'function') return this.bind(0, null, port)\n  if (typeof ip === 'function') return this.bind(port, null, ip)\n  if (ip && typeof ip !== 'string') throw new Error('IP must be a string')\n\n  if (onlistening) this.once('listening', onlistening)\n\n  if (this._bound) throw new Error('Socket is already bound')\n\n  try {\n    this._handle.bind(Number(port) || 0, ip || '0.0.0.0')\n    this._bound = true\n  } catch (err) {\n    emit(this, 'error', err)\n    return\n  }\n\n  emit(this, 'listening')\n}\n\nUTP.prototype.listen = function (port, ip, onlistening) {\n  if (this._bound && port) throw new Error('Socket is already bound')\n  if (port !== undefined) this.bind(port, ip, onlistening)\n  else this.bind()\n\n  if (!this._firewalled) return\n  this._firewalled = false\n  this._handle.onsocket(this._onsocket)\n}\n\nUTP.prototype._onsocket = function (socket) {\n  this.emit('connection', new Connection(this, socket))\n}\n\nUTP.prototype.ref = function () {\n  if (++this._refs === 1) this._handle.ref()\n}\n\nUTP.prototype.unref = function () {\n  if (--this._refs === 0) this._handle.unref()\n}\n\nUTP.prototype.close = function (cb) {\n  if (this._handle) {\n    if (cb) this.once('close', cb)\n    if (this._closed) return\n    this._closed = true\n    this._handle.destroy()\n    return\n  }\n\n  if (cb) process.nextTick(cb)\n}\n\nfunction Connection (utp, socket) {\n  stream.Duplex.call(this)\n\n  this.remoteAddress = ''\n  this.remotePort = 0\n\n  this._utp = utp\n  this._socket = null\n  this._index = this._utp.connections.push(this) - 1\n  this._dataReq = null\n  this._batchReq = null\n  this._drain = null\n  this._ended = false\n  this._resolved = false\n\n  // set by timer\n  this._idleTimeout = -1\n  this._idleNext = null\n  this._idlePrev = null\n  this._idleStart = 0\n  this._timeout = null\n  this._called = false\n\n  this.destroyed = false\n  this.on('finish', this._onend)\n\n  if (socket) this._onsocket(socket)\n}\n\nutil.inherits(Connection, stream.Duplex)\n\nConnection.prototype._connect = function (port, ip) {\n  if (this._utp) this._onsocket(this._utp._handle.connect(port, ip || '127.0.0.1'))\n}\n\nConnection.prototype._onTimeout = function () {\n  this.emit('timeout')\n}\n\nConnection.prototype._resolveAndConnect = function (port, host) {\n  var self = this\n  dns.lookup(host, function (err, ip, family) {\n    if (self.destroyed) return\n    self._resolved = true\n    if (err) return self.destroy(err)\n    if (family !== 4) return self.destroy(IPV4_ONLY)\n    self._connect(port, ip)\n  })\n}\n\nConnection.prototype.setTimeout = function (ms, ontimeout) {\n  if (!ms) {\n    unenroll(this)\n    if (ontimeout) this.removeListener('timeout', ontimeout)\n  } else if (!this.destroyed) {\n    enroll(this, ms)\n    active(this)\n    if (ontimeout) this.once('timeout', ontimeout)\n  }\n  return this\n}\n\nConnection.prototype._onsocket = function (socket) {\n  this._resolved = true\n  this._socket = socket\n\n  socket.context(this)\n  socket.ondrain(this._ondrain)\n  socket.ondata(this._ondata)\n  socket.onend(this._onend)\n  socket.onclose(this._onclose)\n  socket.onerror(this._onerror)\n  socket.onconnect(this._onconnect)\n\n  var address = socket.remoteAddress()\n  this.remoteAddress = address.address\n  this.remotePort = address.port\n\n  this.emit('resolve')\n}\n\nConnection.prototype._onclose = function () {\n  this.destroyed = true\n  this._cleanup()\n  this.emit('close')\n}\n\nConnection.prototype._ondrain = function () {\n  var drain = this._drain\n  this._drain = null\n  this._batchReq = null\n  this._dataReq = null\n  if (drain) drain()\n}\n\nConnection.prototype._ondata = function (data) {\n  if (this.destroyed) return\n  active(this)\n  this.push(data)\n}\n\nConnection.prototype._onerror = function (error) {\n  this.destroy(new Error(UTP_ERRORS[error] || 'UTP_UNKNOWN_ERROR'))\n}\n\nConnection.prototype._onconnect = function () {\n  this.emit('connect')\n}\n\nConnection.prototype.ref = function () {\n  this._utp.ref()\n}\n\nConnection.prototype.unref = function () {\n  this._utp.unref()\n}\n\nConnection.prototype.address = function () {\n  return this._utp && this._utp.address()\n}\n\nConnection.prototype._write = function (data, enc, cb) {\n  if (this.destroyed) return cb()\n  if (!this._resolved) return this.once('resolve', this._write.bind(this, data, enc, cb))\n  active(this)\n\n  if (this._socket.write(data)) return cb()\n  this._dataReq = data\n  this._drain = cb\n}\n\nConnection.prototype._writev = function (batch, cb) {\n  if (this.destroyed) return cb()\n  if (!this._resolved) return this.once('resolve', this._writev.bind(this, batch, cb))\n  active(this)\n\n  if (this._socket.writev(batch)) return cb()\n  this._batchReq = batch\n  this._drain = cb\n}\n\nConnection.prototype._onend = function () {\n  if (!this._resolved) return this.once('resolve', this._onend)\n  if (this._ended) return\n  this._ended = true\n  if (this._socket) this._socket.end()\n  if (!this.destroyed) this.push(null)\n}\n\nConnection.prototype.destroy = function (err) {\n  if (!this._resolved) return this.once('resolve', this._destroy.bind(this, err))\n  if (this.destroyed) return\n  this.destroyed = true\n\n  unenroll(this)\n  if (err) this.emit('error', err)\n\n  this._onend()\n\n  if (!this._socket) {\n    this._cleanup()\n    this.emit('close')\n  }\n}\n\nConnection.prototype._read = function () {\n  // no readable backpressure atm\n}\n\nConnection.prototype._cleanup = function () {\n  var last = this._utp.connections.pop()\n  if (last !== this) {\n    this._utp.connections[this._index] = last\n    last._index = this._index\n  }\n\n  if (!this._utp.connections.length) this._utp.emit('closeable')\n  unenroll(this)\n  this._utp = null\n  this._socket = null\n}\n\nfunction SendRequest (buffer, offset, len, port, host, callback) {\n  this.buffer = buffer\n  this.offset = offset\n  this.length = len\n  this.port = port\n  this.host = host\n  this.callback = callback\n}\n\nfunction next (fn, arg) {\n  process.nextTick(function () {\n    fn(arg)\n  })\n}\n\nfunction emit (self, name, arg) {\n  process.nextTick(function () {\n    if (arg) self.emit(name, arg)\n    else self.emit(name)\n  })\n}\n\nfunction noop () {}\n","var timeout = setTimeout(noop, 1000)\n\nif (timeout.refresh) {\n  exports.enroll = function (inst, ms) {\n    if (inst._timeout) exports.unenroll(inst)\n    inst._timeout = setTimeout(ontimeout, ms, inst)\n    inst._timeout.unref()\n  }\n  exports.unenroll = function (inst) {\n    if (!inst._timeout) return\n    clearTimeout(inst._timeout)\n    inst._timeout = null\n  }\n  exports.active = function (inst) {\n    if (inst._timeout) inst._timeout.refresh()\n  }\n} else {\n  var timers = require('timers')\n  exports.enroll = timers.enroll || noop\n  exports.active = timers._unrefActive || timers.active || noop\n  exports.unenroll = timers.unenroll || noop\n}\n\nclearTimeout(timeout)\n\nfunction ontimeout (inst) {\n  inst._timeout = null\n  inst.emit('timeout')\n}\n\nfunction noop () {}\n","module.exports = require(\"timers\");","var assert = require('assert')\nvar EventEmitter = require('events').EventEmitter\nvar each = require('stream-each')\nvar networkSpeed = require('hyperdrive-network-speed')\nvar bitfield = require('sparse-bitfield')\n\nmodule.exports = function (archive) {\n  assert.ok(archive, 'lib/stats archive required')\n  var stats = new EventEmitter()\n  var counted = bitfield()\n\n  var count = {\n    files: 0,\n    byteLength: 0,\n    length: 0,\n    version: 0\n  }\n\n  update()\n  if (!archive.writable) {\n    count.downloaded = 0\n    downloadStats()\n  }\n\n  // TODO: put in hyperdrive-stats\n  stats.get = function () {\n    return count\n  }\n  stats.network = networkSpeed(archive, { timeout: 2000 })\n\n  Object.defineProperties(stats, {\n    peers: {\n      enumerable: true,\n      get: function () {\n        if (!archive.content || !archive.content.peers) return {} // TODO: how to handle this?\n        var peers = archive.content.peers\n        var total = peers.length\n        var complete = peers.filter(function (peer) {\n          return peer.remoteLength === archive.content.length\n        }).length\n\n        return {\n          total: total,\n          complete: complete\n        }\n      }\n    }\n  })\n\n  return stats\n\n  function downloadStats () {\n    if (!archive.content) return archive.once('content', downloadStats)\n\n    var feed = archive.content\n    count.downloaded = 0\n    for (var i = 0; i < feed.length; i++) {\n      if (feed.has(i) && counted.set(i, true)) count.downloaded++\n    }\n    stats.emit('update')\n\n    archive.content.on('download', countDown)\n    archive.content.on('clear', checkDownloaded)\n\n    function checkDownloaded (start, end) {\n      for (; start < end; start++) {\n        if (counted.set(start, false)) count.downloaded--\n      }\n      stats.emit('update')\n    }\n\n    function countDown (index, data) {\n      if (counted.set(index, true)) count.downloaded++\n      stats.emit('update')\n    }\n  }\n\n  function update () {\n    if (stableVersion()) return wait()\n\n    // get current size of archive\n    var current = archive.tree.checkout(archive.version)\n    var initial = archive.tree.checkout(count.version)\n    var stream = initial.diff(current, { dels: true, puts: true })\n    each(stream, ondata, function () {\n      count.version = current.version\n      stats.emit('update', count)\n      if (!stableVersion()) return update()\n      wait()\n    })\n\n    function ondata (data, next) {\n      if (data.type === 'del') {\n        count.byteLength -= data.value.size\n        count.length -= data.value.blocks\n        count.files--\n      } else {\n        count.byteLength += data.value.size\n        count.length += data.value.blocks\n        count.files++\n      }\n      next()\n    }\n\n    function stableVersion () {\n      if (archive.version < 0) return false\n      return count.version === archive.version\n    }\n\n    function wait () {\n      archive.metadata.update(update)\n    }\n  }\n}\n","var assert = require('assert')\nvar speedometer = require('speedometer')\nvar debug = require('debug')('dat-network')\n\nmodule.exports = function (archive, opts) {\n  assert.ok(archive, 'archive required')\n  opts = opts || {}\n\n  var speed = {}\n  var downloadSpeed = speedometer()\n  var uploadSpeed = speedometer()\n  var timeout = opts.timeout || 1000\n  var upTimeout = null\n  var downTimeout = null\n  var totalTransfer = {\n    up: 0,\n    down: 0\n  }\n\n  if (debug.enabled) {\n    setInterval(function () {\n      if (totalTransfer.up) debug('Uploaded data:', totalTransfer.up)\n      if (totalTransfer.down) debug('Downloaded data:', totalTransfer.down)\n    }, 500)\n  }\n\n  archive.metadata.on('download', function (block, data) {\n    totalTransfer.down += data.length\n    ondownload(data.length)\n  })\n\n  archive.metadata.on('upload', function (block, data) {\n    totalTransfer.up += data.length\n    onupload(data.length)\n  })\n\n  if (archive.content) trackContent()\n  else archive.on('content', trackContent)\n\n  Object.defineProperty(speed, 'downloadSpeed', {\n    enumerable: true,\n    get: function () { return downloadSpeed() }\n  })\n\n  Object.defineProperty(speed, 'uploadSpeed', {\n    enumerable: true,\n    get: function () { return uploadSpeed() }\n  })\n\n  Object.defineProperty(speed, 'downloadTotal', {\n    enumerable: true,\n    get: function () { return totalTransfer.down }\n  })\n\n  Object.defineProperty(speed, 'uploadTotal', {\n    enumerable: true,\n    get: function () { return totalTransfer.up }\n  })\n\n  return speed\n\n  function trackContent () {\n    archive.content.on('download', function (block, data) {\n      totalTransfer.down += data.length\n      ondownload(data.length)\n    })\n\n    archive.content.on('upload', function (block, data) {\n      totalTransfer.up += data.length\n      onupload(data.length)\n    })\n  }\n\n  // Zero out for uploads & disconnections\n  function downZero () {\n    downloadSpeed = speedometer()\n    if (downTimeout) clearTimeout(downTimeout)\n  }\n\n  function upZero () {\n    uploadSpeed = speedometer()\n    if (upTimeout) clearTimeout(upTimeout)\n  }\n\n  function ondownload (bytes) {\n    downloadSpeed(bytes)\n    if (downTimeout) clearTimeout(downTimeout)\n    downTimeout = setTimeout(downZero, timeout)\n  }\n\n  function onupload (bytes) {\n    uploadSpeed(bytes)\n    if (upTimeout) clearTimeout(upTimeout)\n    upTimeout = setTimeout(upZero, timeout)\n  }\n}\n","var assert = require('assert')\nvar http = require('http')\nvar serve = require('hyperdrive-http')\nvar debug = require('debug')('dat-node')\n\nmodule.exports = function (archive, opts) {\n  assert.ok(archive, 'lib/serve: archive required')\n  opts = Object.assign({\n    port: 8080,\n    live: true,\n    footer: 'Served via Dat.'\n  }, opts)\n\n  var server = http.createServer(serve(archive, opts))\n  server.listen(opts.port)\n  server.on('listening', function () {\n    debug(`http serving on PORT:${opts.port}`)\n  })\n\n  return server\n}\n","var toHTML = require('directory-index-html')\nvar pump = require('pump')\nvar mime = require('mime')\nvar range = require('range-parser')\nvar qs = require('querystring')\nvar corsify = require('corsify')\nvar pkg = require('./package.json')\n\nmodule.exports = serve\n\nfunction serve (archive, opts) {\n  if (!opts) opts = {}\n\n  return corsify(onrequest)\n\n  function onrequest (req, res) {\n    var name = decodeURI(req.url.split('?')[0])\n    var query = qs.parse(req.url.split('?')[1] || '')\n\n    var wait = (query.wait && Number(query.wait.toString())) || 0\n    var have = archive.metadata ? archive.metadata.length : -1\n\n    if (wait <= have) return ready()\n    waitFor(archive, wait, ready)\n\n    function ready () {\n      var arch = /^\\d+$/.test(query.version) ? archive.checkout(Number(query.version)) : archive\n      if (name[name.length - 1] === '/') ondirectory(arch, name, req, res, opts)\n      else onfile(arch, name, req, res)\n    }\n  }\n}\n\nfunction onfile (archive, name, req, res) {\n  archive.stat(name, function (err, st) {\n    if (err) return on404(archive, req, res)\n\n    if (st.isDirectory()) {\n      res.statusCode = 302\n      res.setHeader('Location', name + '/')\n      return\n    }\n\n    var r = req.headers.range && range(st.size, req.headers.range)[0]\n    res.setHeader('Accept-Ranges', 'bytes')\n    res.setHeader('Content-Type', mime.getType(name))\n\n    if (r) {\n      res.statusCode = 206\n      res.setHeader('Content-Range', 'bytes ' + r.start + '-' + r.end + '/' + st.size)\n      res.setHeader('Content-Length', r.end - r.start + 1)\n    } else {\n      res.setHeader('Content-Length', st.size)\n    }\n\n    if (req.method === 'HEAD') return res.end()\n    pump(archive.createReadStream(name, r), res)\n  })\n}\n\nfunction on404 (archive, req, res) {\n  getManifest(archive, function (err, parsed) {\n    if (err) return onerror(res, 404, err)\n\n    var fallbackPage = parsed.fallback_page\n\n    if (!fallbackPage) return onerror(res, 404, new Error('Not Found, No Fallback'))\n\n    archive.stat(fallbackPage, function (err) {\n      if (err) return onerror(res, 404, err)\n      onfile(archive, fallbackPage, req, res)\n    })\n  })\n}\n\nfunction ondirectory (archive, name, req, res, opts) {\n  archive.stat(name + 'index.html', function (err) {\n    if (err) return ondirectoryindex(archive, name, req, res, opts)\n    onfile(archive, name + 'index.html', req, res)\n  })\n}\n\nfunction ondirectoryindex (archive, name, req, res, opts) {\n  list(archive, name, function (err, entries) {\n    if (err) entries = []\n\n    var wait = archive.metadata ? archive.metadata.length + 1 : 0\n    var script = `\n      function liveUpdate () {\n        var xhr = new XMLHttpRequest()\n        xhr.open(\"GET\", \".${name}?wait=${wait}\", true)\n        xhr.onload = function () {\n          if (xhr.status !== 200) return onerror()\n          document.open()\n          document.write(xhr.responseText)\n          document.close()\n        }\n        xhr.onerror = onerror\n        xhr.send(null)\n\n        function onerror () {\n          setTimeout(liveUpdate, 1000)\n        }\n      }\n\n      liveUpdate()\n    `\n\n    var footer = opts.footer ? 'Archive version: ' + archive.version : null\n    var html = toHTML({directory: name, script: (!opts.live || archive._checkout) ? null : script, footer: footer}, entries)\n    res.setHeader('Content-Type', 'text/html; charset=utf-8')\n    res.setHeader('Content-Length', Buffer.byteLength(html))\n    if (opts.exposeHeaders) {\n      res.setHeader('Hyperdrive-Key', archive.key.toString('hex'))\n      res.setHeader('Hyperdrive-Version', archive.version)\n      res.setHeader('Hyperdrive-Http-Version', pkg.version)\n    }\n    res.end(html)\n  })\n}\n\nfunction getManifest (archive, cb) {\n  archive.readFile('/dat.json', 'utf-8', function (err, data) {\n    if (err) cb(err)\n    try {\n      var parsed = JSON.parse(data)\n    } catch (e) {\n      return cb(err)\n    }\n\n    if (!parsed || Array.isArray(parsed) || (typeof parsed !== 'object')) {\n      return cb(new Error('Invalid dat.json format'))\n    }\n\n    cb(null, parsed)\n  })\n}\n\nfunction waitFor (archive, until, cb) { // this feels a bit hacky, TODO: make less complicated?\n  archive.setMaxListeners(0)\n  if (!archive.metadata) archive.once('ready', waitFor.bind(null, archive, until, cb))\n  if (archive.metadata.length >= until) return cb()\n  archive.metadata.setMaxListeners(0)\n  archive.metadata.once('append', waitFor.bind(null, archive, until, cb))\n}\n\nfunction onerror (res, status, err) {\n  res.statusCode = status\n  if (!res.headersSent) {\n    res.setHeader('Content-Type', 'text/plain; charset=utf-8')\n  }\n  res.end(err.stack)\n}\n\nfunction list (archive, name, cb) {\n  archive.readdir(name, function (err, names) {\n    if (err) return cb(err)\n\n    var error = null\n    var missing = names.length\n    var entries = []\n\n    if (!missing) return cb(null, [])\n    for (var i = 0; i < names.length; i++) stat(name + names[i], names[i])\n\n    function stat (name, base) {\n      archive.stat(name, function (err, st) {\n        if (err) error = err\n\n        if (st) {\n          entries.push({\n            type: st.isDirectory() ? 'directory' : 'file',\n            name: base,\n            size: st.size,\n            mtime: st.mtime\n          })\n        }\n\n        if (--missing) return\n        if (error) return cb(error)\n        cb(null, entries.sort(sort))\n      })\n    }\n  })\n}\n\nfunction sort (a, b) {\n  return a.name.localeCompare(b.name)\n}\n","var constants = require('cons' + 'tants') // be browserify friendly\n\nvar PADDING_NAME = '                                                   '\nvar PADDING_DATE = '                    '\nvar MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nmodule.exports = toHTML\n\nfunction trim (src) {\n  return src.trim().split('\\n').map(map).join('\\n')\n\n  function map (line) {\n    return line.trim()\n  }\n}\n\nfunction isDirectory (mode) {\n  if (typeof mode !== 'number' || typeof constants.S_IFDIR !== 'number') return false\n  return (mode & constants.S_IFMT) === constants.S_IFDIR\n}\n\nfunction pad (s) {\n  return s < 10 ? ('0' + s) : ('' + s)\n}\n\nfunction toHTML (opts, list) {\n  if (typeof opts === 'string') opts = {directory: opts}\n\n  var dir = opts.directory\n  var footer = opts.footer\n  var script = opts.script\n\n  if (dir[dir.length - 1] === '/') dir = dir.slice(0, -1)\n\n  var prev = `<a href=\"../\">../</a>\\n`\n  var pre = prev + list.map(map).join('')\n  var dirname = dir || '/'\n\n  return trim(`\n    <html>\n    <head><title>Index of ${dirname}</title></head>\n    <body bgcolor=\"white\"><h1>Index of ${dirname}</h1><hr><pre>${pre}</pre><hr>${footer ? '<i>' + footer + '</i>' : ''}\n    ${script ? '<script>' + script + '</script>' : ''}\n    </body>\n    </html>\n  `)\n\n  function map (entry) {\n    var name = entry.name\n    var isDir = name[name - 1] === '/' || isDirectory(entry.mode) || entry.type === 'directory'\n    var size = isDir ? '-' : (typeof entry.size === 'number' ? '' + entry.size : '-')\n    var mtime = typeof entry.mtime === 'number' ? new Date(entry.mtime) : entry.mtime\n\n    var time = '-'\n    if (mtime) {\n      var d = pad(mtime.getDate())\n      var m = MONTHS[mtime.getMonth()]\n      var y = mtime.getFullYear()\n      var h = pad(mtime.getHours())\n      var min = pad(mtime.getMinutes())\n      time = `${d}-${m}-${y} ${h}:${min}`\n    }\n\n    if (isDir && name[name.length - 1] !== '/') name += '/'\n\n    var fname = fmt(name)\n    var p1 = PADDING_NAME.slice(fname.length)\n    var p2 = PADDING_DATE.slice(0, -size.length)\n    var href = entry.href || encodeURI(name)\n    if (opts.query) href += '?' + opts.query\n\n    return `<a href=\"${href}\" title=\"${name}\">${fname}</a>${p1 + time + p2 + size}\\n`\n  }\n}\n\nfunction fmt (name) {\n  if (name.length > 50) return name.slice(0, 47) + '..>'\n  return name\n}\n","'use strict';\n\nvar Mime = require('./Mime');\nmodule.exports = new Mime(require('./types/standard'), require('./types/other'));\n","'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (var i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n\n/**\n * Define mimetype -> xtension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function(typeMap, force) {\n  for (var type in typeMap) {\n    var extensions = typeMap[type];\n    for (var i = 0; i < extensions.length; i++) {\n      var ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] == '*') {\n        continue;\n      }\n\n      if (!force && (ext in this._types)) {\n        throw new Error(\n          'Attempt to change mapping for \"' + ext +\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\n          '\" from the list of extensions for \"' + type + '\".'\n        );\n      }\n\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      var ext = extensions[0];\n      this._extensions[type] = (ext[0] != '*') ? ext : ext.substr(1)\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function(path) {\n  path = String(path);\n  var last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  var ext = last.replace(/^.*\\./, '').toLowerCase();\n\n  var hasPath = last.length < path.length;\n  var hasDot = ext.length < last.length - 1;\n\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function(type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;\n","/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n","var methods = require(\"http-methods\")\n\n/* \ntype Handler := (req, res) => void | { \n    GET?: (req, res) => void, \n    POST?: (req, res) => void,\n    DELETE?: (req, res) => void,\n    PUT?: (req, res) => void,\n    OPTIONS?: (req, res) => void\n}\n\nCorsify := (opts: Options, handler: Handler) => Handler &\n    (opts: Options) => (handler: Handler) => Handler &\n    (handler: Handler) => Handler\n\n*/\nmodule.exports = Corsify\n\nfunction Corsify(opts, handler) {\n    if (typeof opts === \"function\") {\n        handler = opts\n        opts = {}\n    }\n\n    if (!handler && opts && !isOptions(opts)) {\n        handler = opts\n        opts = {}\n    }\n\n    if (!handler) {\n        return Corsify.bind(null, opts)\n    }\n\n    if (typeof handler !== \"function\") {\n        handler = methods(handler)\n    }\n\n    return routeHandler\n\n    function routeHandler(req, res) {\n        addCrossDomainHeaders(req, res, opts)\n        if (opts.endOptions !== false && req.method === \"OPTIONS\") {\n            res.end()\n        } else {\n            handler.apply(this, arguments)\n        }\n    }\n}\n\nfunction isOptions(opts) {\n    return \"endOptions\" in opts ||\n        \"getOrigin\" in opts ||\n        \"Access-Control-Allow-Origin\" in opts ||\n        \"Access-Control-Allow-Methods\" in opts ||\n        \"Access-Control-Allow-Credentials\" in opts ||\n        \"Access-Control-Max-Age\" in opts ||\n        \"Access-Control-Allow-Headers\" in opts\n}\n\nfunction addCrossDomainHeaders(req, res, opts) {\n    var origin = \"getOrigin\" in opts ?\n        opts.getOrigin(req, res) :\n        opts[\"Access-Control-Allow-Origin\"] || req.headers.origin\n\n    if (origin) {\n        res.setHeader(\"Access-Control-Allow-Origin\", origin)\n        res.setHeader(\"Access-Control-Allow-Methods\",\n            opts[\"Access-Control-Allow-Methods\"] ||\n                \"POST, GET, PUT, DELETE, OPTIONS, XMODIFY\")\n        res.setHeader(\"Access-Control-Allow-Credentials\",\n            opts[\"Access-Control-Allow-Credentials\"] || \"true\")\n        res.setHeader(\"Access-Control-Max-Age\",\n            opts[\"Access-Control-Max-Age\"] || \"86400\")\n        res.setHeader(\"Access-Control-Allow-Headers\",\n            opts[\"Access-Control-Allow-Headers\"] ||\n                \"X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept\")\n    }\n}\n","var contentTypes = require(\"content-types\")\n    , body = require(\"body\")\n    , jsonBody = body.json\n    , formBody = body.form\n\nmodule.exports = methods\n\nfunction methods(routes, handleHttpForms) {\n    return handleHttpForms ? formRequestHandler : requestHandler\n\n    function requestHandler(req) {\n        var method = req.method\n            , f = routes[method] || routes.notFound || notFound\n\n        return f.apply(this, arguments)\n    }\n\n    function formRequestHandler(req, res) {\n        var args = arguments\n            , self = this\n\n        contentTypes(req, res, {\n            \"application/json\": jsonBody\n            , \"application/x-www-form-urlencoded\": formBody\n            , \"default\": callRequestHandler\n        })(req, res, extractMethod)\n\n        function callRequestHandler() {\n            requestHandler.apply(self, args)\n        }\n\n        function extractMethod(err, body) {\n            var method = body._method\n                , f = routes[method] || routes.notFound || notFound\n\n            return f.apply(self, args)\n        }\n    }\n}\n\nfunction notFound(req, res) {\n    res.statusCode = 405\n    res.end(\"405 Method Not Allowed \" + req.url)\n}","var some = require(\"iterators\").someSync\n\nmodule.exports = contentTypes\n\nfunction contentTypes(req, res, object) {\n    var contentType = req.headers[\"content-type\"] || \"\"\n\n    // Content-Type is allowed to have parameters in it\n    return some(object, findFirstMatch, contentType) || object.default\n}\n\nfunction findFirstMatch(value, key) {\n    if (this.indexOf(key) !== -1) {\n        return value\n    }\n}","module.exports = {\n    // sync\n    forEachSync: require(\"./lib/sync/forEach\")\n    , filterSync: require(\"./lib/sync/filter\")\n    , mapSync: require(\"./lib/sync/map\")\n    , reduceSync: require(\"./lib/sync/reduce\")\n    , reduceRightSync: require(\"./lib/sync/reduceRight\")\n    , everySync: require(\"./lib/sync/every\")\n    , someSync: require(\"./lib/sync/some\")\n    // async\n    , forEach: require(\"./lib/async/forEach\")\n    , filter: require(\"./lib/async/filter\")\n    , map: require(\"./lib/async/map\")\n    , reduce: require(\"./lib/async/reduce\")\n    , reduceRight: require(\"./lib/async/reduceRight\")\n    , every: require(\"./lib/async/every\")\n    , some: require(\"./lib/async/some\")\n}","module.exports = forEach\n\nfunction forEach(list, iterator, context) {\n    var keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        iterator.call(context, value, key, list)\n    }\n}","module.exports = filter\n\nfunction filter(list, iterator, context) {\n    var returnValue = Array.isArray(list) ? [] : {}\n        , keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n            , keepValue = iterator.call(context, value, key, list)\n\n        if (keepValue) {\n            if (Array.isArray(returnValue)) {\n                returnValue.push(value)\n            } else {\n                returnValue[key] = value\n            }\n        }\n    }\n\n    return returnValue\n}","module.exports = map\n\nfunction map(list, iterator, context) {\n    var returnValue = Array.isArray(list) ? [] : {}\n        , keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n            , newValue = iterator.call(context, value, key, list)\n\n        returnValue[key] = newValue\n    }\n\n    return returnValue\n}","module.exports = reduce\n\nfunction reduce(list, iterator, context, accumulator) {\n    var keys = Object.keys(list)\n        , i = 0\n\n    if (arguments.length === 2) {\n        context = this\n        accumulator = list[0]\n        i = 1\n    } else if (arguments.length === 3) {\n        accumulator = context\n        context = this\n    }\n\n    for (var len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n\n        accumulator = iterator.call(context, accumulator, value, key, list)\n    }\n\n    return accumulator\n}","module.exports = reduceRight\n\nfunction reduceRight(list, iterator, context, accumulator) {\n    var keys = Object.keys(list)\n        , len = keys.length\n        , i = len - 1\n\n    if (arguments.length === 2) {\n        context = this\n        accumulator = list[i]\n        i--\n    } else if (arguments.length === 3) {\n        accumulator = context\n        context = this\n    }\n\n    for (; i >= 0; i--) {\n        var key = keys[i]\n            , value = list[key]\n\n        accumulator = iterator.call(context, accumulator, value, key, list)\n    }\n\n    return accumulator\n}","module.exports = every\n\nfunction every(list, iterator, context) {\n    var keys = Object.keys(list)\n        , result\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        result = iterator.call(context, value, key, list)\n\n        if (!result) {\n            return result\n        }\n    }\n\n    return result\n}","module.exports = every\n\nfunction every(list, iterator, context) {\n    var keys = Object.keys(list)\n        , result\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        result = iterator.call(context, value, key, list)\n\n        if (result) {\n            return result\n        }\n    }\n\n    return result\n}","module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (--count === 0) {\n            callback && callback(null)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}","var partial = require(\"ap\").partial\n\nmodule.exports = filter\n\nfunction filter(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , returnValue = Array.isArray(list) ? [] : {}\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator,\n            partial(next, value, key), context, value, key, list)\n    }\n\n    function next(value, key, err, keepValue) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (keepValue) {\n            if (Array.isArray(returnValue)) {\n                returnValue.push(value)\n            } else {\n                returnValue[key] = value\n            }\n        }\n\n        if (--count === 0) {\n            callback && callback(null, returnValue)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}","exports = module.exports = ap;\nfunction ap (args, fn) {\n    return function () {\n        return fn.apply(this, args.concat.apply(args, arguments));\n    };\n}\n\nexports.pa = pa;\nfunction pa (args, fn) {\n    return function () {\n        return fn.apply(this, [].slice.call(arguments).concat(args));\n    };\n}\n\nexports.apa = apa;\nfunction apa (left, right, fn) {\n    return function () {\n        return fn.apply(this,\n            left.concat.apply(left, arguments).concat(right)\n        );\n    };\n}\n\nexports.partial = partial;\nfunction partial (fn) {\n    var args = [].slice.call(arguments, 1);\n    return ap(args, fn);\n}\n\nexports.partialRight = partialRight;\nfunction partialRight (fn) {\n    var args = [].slice.call(arguments, 1);\n    return pa(args, fn);\n}\n\nexports.curry = curry;\nfunction curry (fn) {\n    return partial(partial, fn);\n}\n\nexports.curryRight = function curryRight (fn) {\n    return partial(partialRight, fn);\n}\n","var partial = require(\"ap\").partial\n\nmodule.exports = map\n\nfunction map(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , returnValue = Array.isArray(list) ? [] : {}\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator,\n            partial(next, key), context, value, key, list)\n    }\n\n    function next(key, err, newValue) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        returnValue[key] = newValue\n\n        if (--count === 0) {\n            callback && callback(null, returnValue)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}","module.exports = forEach\n\nfunction forEach(list, iterator, context, accumulator, callback) {\n    var keys = Object.keys(list)\n        , i = 0\n        , count = keys.length\n\n    if (arguments.length === 3) {\n        callback = context\n        context = this\n        accumulator = list[0]\n        i = 1\n        count--\n    } else if (arguments.length === 4) {\n        callback = accumulator\n        accumulator = context\n        context = this\n    }\n\n    for (var len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, accumulator, value, key, list)\n    }\n\n    function next(err, value) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        accumulator = value\n\n        if (--count === 0) {\n            callback && callback(null, accumulator)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, acc, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, acc, done)\n    } else if (length === 3) {\n        iterator.call(context, acc, value, done)\n    } else if (length === 4) {\n        iterator.call(context, acc, value, key, done)\n    } else {\n        iterator.call(context, acc, value, key, list, done)\n    }\n}","module.exports = forEach\n\nfunction forEach(list, iterator, context, accumulator, callback) {\n    var keys = Object.keys(list)\n        , len = keys.length\n        , i = len - 1\n        , count = keys.length\n\n    if (arguments.length === 3) {\n        callback = context\n        context = this\n        accumulator = list[i]\n        i--\n        count--\n    } else if (arguments.length === 4) {\n        callback = accumulator\n        accumulator = context\n        context = this\n    }\n\n    for (; i >= 0; i--) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, accumulator, value, key, list)\n    }\n\n    function next(err, value) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        accumulator = value\n\n        if (--count === 0) {\n            callback && callback(null, accumulator)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, acc, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, acc, done)\n    } else if (length === 3) {\n        iterator.call(context, acc, value, done)\n    } else if (length === 4) {\n        iterator.call(context, acc, value, key, done)\n    } else {\n        iterator.call(context, acc, value, key, list, done)\n    }\n}","module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err, result) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (!result) {\n            return callback && callback(null, result)\n        }\n\n        if (--count === 0) {\n            callback && callback(null, result)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}","module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err, result) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (result) {\n            return callback && callback(null, result)\n        }\n\n        if (--count === 0) {\n            callback && callback(null, result)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}","var StringDecoder = require(\"string_decoder\").StringDecoder\n    , querystring = require(\"querystring\")\n    , contentTypes = require(\"content-types\")\n\nbody.form = formBody\nbody.json = jsonBody\nbody.any = anyBody\n\nmodule.exports = body\n\nfunction body(req, res, callback) {\n    if (req.__body__) {\n        callback(req.__body__)\n    }\n\n    var requestBody = \"\",\n        stringDecoder = new StringDecoder\n\n    req.on(\"data\", addToBody)\n\n    req.on(\"end\", returnBody)\n\n    function addToBody(buffer) {\n        requestBody += stringDecoder.write(buffer)\n    }\n\n    function returnBody() {\n        req.__body__ = requestBody\n        callback(null, requestBody)\n    }\n}\n\nfunction anyBody(req, res, callback) {\n    contentTypes(req, res, {\n        \"application/json\": jsonBody,\n        \"application/x-www-form-urlencoded\": formBody,\n        \"default\": body\n    })(req, res, callback)\n}\n\nfunction formBody(req, res, callback)  {\n    body(req, res, parseBody)\n\n    function parseBody(err, body) {\n        callback(null, querystring.parse(body))\n    }\n}\n\nfunction jsonBody(req, res, callback) {\n    body(req, res, extractJSON)\n\n    function extractJSON(err, body) {\n        var json\n        try {\n            json = JSON.parse(body)\n        } catch (error) {\n            return callback(error)\n        }\n        callback(null, json)\n    }\n}","module.exports = require(\"string_decoder\");"],"sourceRoot":""}